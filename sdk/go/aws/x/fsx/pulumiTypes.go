// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package fsx

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi-aws/sdk/v6/go/aws/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumix"
)

var _ = internal.GetEnvOrDefault

type DataRepositoryAssociationS3 struct {
	// Specifies the type of updated objects that will be automatically exported from your file system to the linked S3 bucket. See the `events` configuration block.
	AutoExportPolicy *DataRepositoryAssociationS3AutoExportPolicy `pulumi:"autoExportPolicy"`
	// Specifies the type of updated objects that will be automatically imported from the linked S3 bucket to your file system. See the `events` configuration block.
	AutoImportPolicy *DataRepositoryAssociationS3AutoImportPolicy `pulumi:"autoImportPolicy"`
}

type DataRepositoryAssociationS3Args struct {
	// Specifies the type of updated objects that will be automatically exported from your file system to the linked S3 bucket. See the `events` configuration block.
	AutoExportPolicy pulumix.Input[*DataRepositoryAssociationS3AutoExportPolicyArgs] `pulumi:"autoExportPolicy"`
	// Specifies the type of updated objects that will be automatically imported from the linked S3 bucket to your file system. See the `events` configuration block.
	AutoImportPolicy pulumix.Input[*DataRepositoryAssociationS3AutoImportPolicyArgs] `pulumi:"autoImportPolicy"`
}

func (DataRepositoryAssociationS3Args) ElementType() reflect.Type {
	return reflect.TypeOf((*DataRepositoryAssociationS3)(nil)).Elem()
}

func (i DataRepositoryAssociationS3Args) ToDataRepositoryAssociationS3Output() DataRepositoryAssociationS3Output {
	return i.ToDataRepositoryAssociationS3OutputWithContext(context.Background())
}

func (i DataRepositoryAssociationS3Args) ToDataRepositoryAssociationS3OutputWithContext(ctx context.Context) DataRepositoryAssociationS3Output {
	return pulumi.ToOutputWithContext(ctx, i).(DataRepositoryAssociationS3Output)
}

func (i *DataRepositoryAssociationS3Args) ToOutput(ctx context.Context) pulumix.Output[*DataRepositoryAssociationS3Args] {
	return pulumix.Val(i)
}

type DataRepositoryAssociationS3Output struct{ *pulumi.OutputState }

func (DataRepositoryAssociationS3Output) ElementType() reflect.Type {
	return reflect.TypeOf((*DataRepositoryAssociationS3)(nil)).Elem()
}

func (o DataRepositoryAssociationS3Output) ToDataRepositoryAssociationS3Output() DataRepositoryAssociationS3Output {
	return o
}

func (o DataRepositoryAssociationS3Output) ToDataRepositoryAssociationS3OutputWithContext(ctx context.Context) DataRepositoryAssociationS3Output {
	return o
}

func (o DataRepositoryAssociationS3Output) ToOutput(ctx context.Context) pulumix.Output[DataRepositoryAssociationS3] {
	return pulumix.Output[DataRepositoryAssociationS3]{
		OutputState: o.OutputState,
	}
}

// Specifies the type of updated objects that will be automatically exported from your file system to the linked S3 bucket. See the `events` configuration block.
func (o DataRepositoryAssociationS3Output) AutoExportPolicy() pulumix.GPtrOutput[DataRepositoryAssociationS3AutoExportPolicy, DataRepositoryAssociationS3AutoExportPolicyOutput] {
	value := pulumix.Apply[DataRepositoryAssociationS3](o, func(v DataRepositoryAssociationS3) *DataRepositoryAssociationS3AutoExportPolicy {
		return v.AutoExportPolicy
	})
	return pulumix.GPtrOutput[DataRepositoryAssociationS3AutoExportPolicy, DataRepositoryAssociationS3AutoExportPolicyOutput]{OutputState: value.OutputState}
}

// Specifies the type of updated objects that will be automatically imported from the linked S3 bucket to your file system. See the `events` configuration block.
func (o DataRepositoryAssociationS3Output) AutoImportPolicy() pulumix.GPtrOutput[DataRepositoryAssociationS3AutoImportPolicy, DataRepositoryAssociationS3AutoImportPolicyOutput] {
	value := pulumix.Apply[DataRepositoryAssociationS3](o, func(v DataRepositoryAssociationS3) *DataRepositoryAssociationS3AutoImportPolicy {
		return v.AutoImportPolicy
	})
	return pulumix.GPtrOutput[DataRepositoryAssociationS3AutoImportPolicy, DataRepositoryAssociationS3AutoImportPolicyOutput]{OutputState: value.OutputState}
}

type DataRepositoryAssociationS3AutoExportPolicy struct {
	// A list of file event types to automatically export to your linked S3 bucket or import from the linked S3 bucket. Valid values are `NEW`, `CHANGED`, `DELETED`. Max of 3.
	Events []string `pulumi:"events"`
}

type DataRepositoryAssociationS3AutoExportPolicyArgs struct {
	// A list of file event types to automatically export to your linked S3 bucket or import from the linked S3 bucket. Valid values are `NEW`, `CHANGED`, `DELETED`. Max of 3.
	Events pulumix.Input[[]string] `pulumi:"events"`
}

func (DataRepositoryAssociationS3AutoExportPolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DataRepositoryAssociationS3AutoExportPolicy)(nil)).Elem()
}

func (i DataRepositoryAssociationS3AutoExportPolicyArgs) ToDataRepositoryAssociationS3AutoExportPolicyOutput() DataRepositoryAssociationS3AutoExportPolicyOutput {
	return i.ToDataRepositoryAssociationS3AutoExportPolicyOutputWithContext(context.Background())
}

func (i DataRepositoryAssociationS3AutoExportPolicyArgs) ToDataRepositoryAssociationS3AutoExportPolicyOutputWithContext(ctx context.Context) DataRepositoryAssociationS3AutoExportPolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DataRepositoryAssociationS3AutoExportPolicyOutput)
}

func (i *DataRepositoryAssociationS3AutoExportPolicyArgs) ToOutput(ctx context.Context) pulumix.Output[*DataRepositoryAssociationS3AutoExportPolicyArgs] {
	return pulumix.Val(i)
}

type DataRepositoryAssociationS3AutoExportPolicyOutput struct{ *pulumi.OutputState }

func (DataRepositoryAssociationS3AutoExportPolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DataRepositoryAssociationS3AutoExportPolicy)(nil)).Elem()
}

func (o DataRepositoryAssociationS3AutoExportPolicyOutput) ToDataRepositoryAssociationS3AutoExportPolicyOutput() DataRepositoryAssociationS3AutoExportPolicyOutput {
	return o
}

func (o DataRepositoryAssociationS3AutoExportPolicyOutput) ToDataRepositoryAssociationS3AutoExportPolicyOutputWithContext(ctx context.Context) DataRepositoryAssociationS3AutoExportPolicyOutput {
	return o
}

func (o DataRepositoryAssociationS3AutoExportPolicyOutput) ToOutput(ctx context.Context) pulumix.Output[DataRepositoryAssociationS3AutoExportPolicy] {
	return pulumix.Output[DataRepositoryAssociationS3AutoExportPolicy]{
		OutputState: o.OutputState,
	}
}

// A list of file event types to automatically export to your linked S3 bucket or import from the linked S3 bucket. Valid values are `NEW`, `CHANGED`, `DELETED`. Max of 3.
func (o DataRepositoryAssociationS3AutoExportPolicyOutput) Events() pulumix.ArrayOutput[string] {
	value := pulumix.Apply[DataRepositoryAssociationS3AutoExportPolicy](o, func(v DataRepositoryAssociationS3AutoExportPolicy) []string { return v.Events })
	return pulumix.ArrayOutput[string]{OutputState: value.OutputState}
}

type DataRepositoryAssociationS3AutoImportPolicy struct {
	// A list of file event types to automatically export to your linked S3 bucket or import from the linked S3 bucket. Valid values are `NEW`, `CHANGED`, `DELETED`. Max of 3.
	Events []string `pulumi:"events"`
}

type DataRepositoryAssociationS3AutoImportPolicyArgs struct {
	// A list of file event types to automatically export to your linked S3 bucket or import from the linked S3 bucket. Valid values are `NEW`, `CHANGED`, `DELETED`. Max of 3.
	Events pulumix.Input[[]string] `pulumi:"events"`
}

func (DataRepositoryAssociationS3AutoImportPolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DataRepositoryAssociationS3AutoImportPolicy)(nil)).Elem()
}

func (i DataRepositoryAssociationS3AutoImportPolicyArgs) ToDataRepositoryAssociationS3AutoImportPolicyOutput() DataRepositoryAssociationS3AutoImportPolicyOutput {
	return i.ToDataRepositoryAssociationS3AutoImportPolicyOutputWithContext(context.Background())
}

func (i DataRepositoryAssociationS3AutoImportPolicyArgs) ToDataRepositoryAssociationS3AutoImportPolicyOutputWithContext(ctx context.Context) DataRepositoryAssociationS3AutoImportPolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DataRepositoryAssociationS3AutoImportPolicyOutput)
}

func (i *DataRepositoryAssociationS3AutoImportPolicyArgs) ToOutput(ctx context.Context) pulumix.Output[*DataRepositoryAssociationS3AutoImportPolicyArgs] {
	return pulumix.Val(i)
}

type DataRepositoryAssociationS3AutoImportPolicyOutput struct{ *pulumi.OutputState }

func (DataRepositoryAssociationS3AutoImportPolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DataRepositoryAssociationS3AutoImportPolicy)(nil)).Elem()
}

func (o DataRepositoryAssociationS3AutoImportPolicyOutput) ToDataRepositoryAssociationS3AutoImportPolicyOutput() DataRepositoryAssociationS3AutoImportPolicyOutput {
	return o
}

func (o DataRepositoryAssociationS3AutoImportPolicyOutput) ToDataRepositoryAssociationS3AutoImportPolicyOutputWithContext(ctx context.Context) DataRepositoryAssociationS3AutoImportPolicyOutput {
	return o
}

func (o DataRepositoryAssociationS3AutoImportPolicyOutput) ToOutput(ctx context.Context) pulumix.Output[DataRepositoryAssociationS3AutoImportPolicy] {
	return pulumix.Output[DataRepositoryAssociationS3AutoImportPolicy]{
		OutputState: o.OutputState,
	}
}

// A list of file event types to automatically export to your linked S3 bucket or import from the linked S3 bucket. Valid values are `NEW`, `CHANGED`, `DELETED`. Max of 3.
func (o DataRepositoryAssociationS3AutoImportPolicyOutput) Events() pulumix.ArrayOutput[string] {
	value := pulumix.Apply[DataRepositoryAssociationS3AutoImportPolicy](o, func(v DataRepositoryAssociationS3AutoImportPolicy) []string { return v.Events })
	return pulumix.ArrayOutput[string]{OutputState: value.OutputState}
}

type FileCacheDataRepositoryAssociation struct {
	AssociationId *string `pulumi:"associationId"`
	// The path to the S3 or NFS data repository that links to the cache.
	DataRepositoryPath string `pulumi:"dataRepositoryPath"`
	// A list of NFS Exports that will be linked with this data repository association. The Export paths are in the format /exportpath1. To use this parameter, you must configure DataRepositoryPath as the domain name of the NFS file system. The NFS file system domain name in effect is the root of the subdirectories. Note that DataRepositorySubdirectories is not supported for S3 data repositories. Max of 500.
	DataRepositorySubdirectories []string `pulumi:"dataRepositorySubdirectories"`
	// The system-generated, unique ID of the cache.
	FileCacheId *string `pulumi:"fileCacheId"`
	// A path on the cache that points to a high-level directory (such as /ns1/) or subdirectory (such as /ns1/subdir/) that will be mapped 1-1 with DataRepositoryPath. The leading forward slash in the name is required. Two data repository associations cannot have overlapping cache paths. For example, if a data repository is associated with cache path /ns1/, then you cannot link another data repository with cache path /ns1/ns2. This path specifies where in your cache files will be exported from. This cache directory can be linked to only one data repository, and no data repository other can be linked to the directory. Note: The cache path can only be set to root (/) on an NFS DRA when DataRepositorySubdirectories is specified. If you specify root (/) as the cache path, you can create only one DRA on the cache. The cache path cannot be set to root (/) for an S3 DRA.
	FileCachePath         string  `pulumi:"fileCachePath"`
	FileSystemId          *string `pulumi:"fileSystemId"`
	FileSystemPath        *string `pulumi:"fileSystemPath"`
	ImportedFileChunkSize *int    `pulumi:"importedFileChunkSize"`
	// (Optional) See the `nfs` configuration block.
	Nfs         []FileCacheDataRepositoryAssociationNf `pulumi:"nfs"`
	ResourceArn *string                                `pulumi:"resourceArn"`
	// A map of tags to assign to the file cache. If configured with a provider `defaultTags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
	Tags map[string]string `pulumi:"tags"`
}

type FileCacheDataRepositoryAssociationArgs struct {
	AssociationId pulumix.Input[*string] `pulumi:"associationId"`
	// The path to the S3 or NFS data repository that links to the cache.
	DataRepositoryPath pulumix.Input[string] `pulumi:"dataRepositoryPath"`
	// A list of NFS Exports that will be linked with this data repository association. The Export paths are in the format /exportpath1. To use this parameter, you must configure DataRepositoryPath as the domain name of the NFS file system. The NFS file system domain name in effect is the root of the subdirectories. Note that DataRepositorySubdirectories is not supported for S3 data repositories. Max of 500.
	DataRepositorySubdirectories pulumix.Input[[]string] `pulumi:"dataRepositorySubdirectories"`
	// The system-generated, unique ID of the cache.
	FileCacheId pulumix.Input[*string] `pulumi:"fileCacheId"`
	// A path on the cache that points to a high-level directory (such as /ns1/) or subdirectory (such as /ns1/subdir/) that will be mapped 1-1 with DataRepositoryPath. The leading forward slash in the name is required. Two data repository associations cannot have overlapping cache paths. For example, if a data repository is associated with cache path /ns1/, then you cannot link another data repository with cache path /ns1/ns2. This path specifies where in your cache files will be exported from. This cache directory can be linked to only one data repository, and no data repository other can be linked to the directory. Note: The cache path can only be set to root (/) on an NFS DRA when DataRepositorySubdirectories is specified. If you specify root (/) as the cache path, you can create only one DRA on the cache. The cache path cannot be set to root (/) for an S3 DRA.
	FileCachePath         pulumix.Input[string]  `pulumi:"fileCachePath"`
	FileSystemId          pulumix.Input[*string] `pulumi:"fileSystemId"`
	FileSystemPath        pulumix.Input[*string] `pulumi:"fileSystemPath"`
	ImportedFileChunkSize pulumix.Input[*int]    `pulumi:"importedFileChunkSize"`
	// (Optional) See the `nfs` configuration block.
	Nfs         pulumix.Input[[]*FileCacheDataRepositoryAssociationNfArgs] `pulumi:"nfs"`
	ResourceArn pulumix.Input[*string]                                     `pulumi:"resourceArn"`
	// A map of tags to assign to the file cache. If configured with a provider `defaultTags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
	Tags pulumix.Input[map[string]string] `pulumi:"tags"`
}

func (FileCacheDataRepositoryAssociationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FileCacheDataRepositoryAssociation)(nil)).Elem()
}

func (i FileCacheDataRepositoryAssociationArgs) ToFileCacheDataRepositoryAssociationOutput() FileCacheDataRepositoryAssociationOutput {
	return i.ToFileCacheDataRepositoryAssociationOutputWithContext(context.Background())
}

func (i FileCacheDataRepositoryAssociationArgs) ToFileCacheDataRepositoryAssociationOutputWithContext(ctx context.Context) FileCacheDataRepositoryAssociationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FileCacheDataRepositoryAssociationOutput)
}

func (i *FileCacheDataRepositoryAssociationArgs) ToOutput(ctx context.Context) pulumix.Output[*FileCacheDataRepositoryAssociationArgs] {
	return pulumix.Val(i)
}

type FileCacheDataRepositoryAssociationOutput struct{ *pulumi.OutputState }

func (FileCacheDataRepositoryAssociationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FileCacheDataRepositoryAssociation)(nil)).Elem()
}

func (o FileCacheDataRepositoryAssociationOutput) ToFileCacheDataRepositoryAssociationOutput() FileCacheDataRepositoryAssociationOutput {
	return o
}

func (o FileCacheDataRepositoryAssociationOutput) ToFileCacheDataRepositoryAssociationOutputWithContext(ctx context.Context) FileCacheDataRepositoryAssociationOutput {
	return o
}

func (o FileCacheDataRepositoryAssociationOutput) ToOutput(ctx context.Context) pulumix.Output[FileCacheDataRepositoryAssociation] {
	return pulumix.Output[FileCacheDataRepositoryAssociation]{
		OutputState: o.OutputState,
	}
}

func (o FileCacheDataRepositoryAssociationOutput) AssociationId() pulumix.Output[*string] {
	return pulumix.Apply[FileCacheDataRepositoryAssociation](o, func(v FileCacheDataRepositoryAssociation) *string { return v.AssociationId })
}

// The path to the S3 or NFS data repository that links to the cache.
func (o FileCacheDataRepositoryAssociationOutput) DataRepositoryPath() pulumix.Output[string] {
	return pulumix.Apply[FileCacheDataRepositoryAssociation](o, func(v FileCacheDataRepositoryAssociation) string { return v.DataRepositoryPath })
}

// A list of NFS Exports that will be linked with this data repository association. The Export paths are in the format /exportpath1. To use this parameter, you must configure DataRepositoryPath as the domain name of the NFS file system. The NFS file system domain name in effect is the root of the subdirectories. Note that DataRepositorySubdirectories is not supported for S3 data repositories. Max of 500.
func (o FileCacheDataRepositoryAssociationOutput) DataRepositorySubdirectories() pulumix.ArrayOutput[string] {
	value := pulumix.Apply[FileCacheDataRepositoryAssociation](o, func(v FileCacheDataRepositoryAssociation) []string { return v.DataRepositorySubdirectories })
	return pulumix.ArrayOutput[string]{OutputState: value.OutputState}
}

// The system-generated, unique ID of the cache.
func (o FileCacheDataRepositoryAssociationOutput) FileCacheId() pulumix.Output[*string] {
	return pulumix.Apply[FileCacheDataRepositoryAssociation](o, func(v FileCacheDataRepositoryAssociation) *string { return v.FileCacheId })
}

// A path on the cache that points to a high-level directory (such as /ns1/) or subdirectory (such as /ns1/subdir/) that will be mapped 1-1 with DataRepositoryPath. The leading forward slash in the name is required. Two data repository associations cannot have overlapping cache paths. For example, if a data repository is associated with cache path /ns1/, then you cannot link another data repository with cache path /ns1/ns2. This path specifies where in your cache files will be exported from. This cache directory can be linked to only one data repository, and no data repository other can be linked to the directory. Note: The cache path can only be set to root (/) on an NFS DRA when DataRepositorySubdirectories is specified. If you specify root (/) as the cache path, you can create only one DRA on the cache. The cache path cannot be set to root (/) for an S3 DRA.
func (o FileCacheDataRepositoryAssociationOutput) FileCachePath() pulumix.Output[string] {
	return pulumix.Apply[FileCacheDataRepositoryAssociation](o, func(v FileCacheDataRepositoryAssociation) string { return v.FileCachePath })
}

func (o FileCacheDataRepositoryAssociationOutput) FileSystemId() pulumix.Output[*string] {
	return pulumix.Apply[FileCacheDataRepositoryAssociation](o, func(v FileCacheDataRepositoryAssociation) *string { return v.FileSystemId })
}

func (o FileCacheDataRepositoryAssociationOutput) FileSystemPath() pulumix.Output[*string] {
	return pulumix.Apply[FileCacheDataRepositoryAssociation](o, func(v FileCacheDataRepositoryAssociation) *string { return v.FileSystemPath })
}

func (o FileCacheDataRepositoryAssociationOutput) ImportedFileChunkSize() pulumix.Output[*int] {
	return pulumix.Apply[FileCacheDataRepositoryAssociation](o, func(v FileCacheDataRepositoryAssociation) *int { return v.ImportedFileChunkSize })
}

// (Optional) See the `nfs` configuration block.
func (o FileCacheDataRepositoryAssociationOutput) Nfs() pulumix.GArrayOutput[FileCacheDataRepositoryAssociationNf, FileCacheDataRepositoryAssociationNfOutput] {
	value := pulumix.Apply[FileCacheDataRepositoryAssociation](o, func(v FileCacheDataRepositoryAssociation) []FileCacheDataRepositoryAssociationNf { return v.Nfs })
	return pulumix.GArrayOutput[FileCacheDataRepositoryAssociationNf, FileCacheDataRepositoryAssociationNfOutput]{OutputState: value.OutputState}
}

func (o FileCacheDataRepositoryAssociationOutput) ResourceArn() pulumix.Output[*string] {
	return pulumix.Apply[FileCacheDataRepositoryAssociation](o, func(v FileCacheDataRepositoryAssociation) *string { return v.ResourceArn })
}

// A map of tags to assign to the file cache. If configured with a provider `defaultTags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
func (o FileCacheDataRepositoryAssociationOutput) Tags() pulumix.MapOutput[string] {
	value := pulumix.Apply[FileCacheDataRepositoryAssociation](o, func(v FileCacheDataRepositoryAssociation) map[string]string { return v.Tags })
	return pulumix.MapOutput[string]{OutputState: value.OutputState}
}

type FileCacheDataRepositoryAssociationNf struct {
	// A list of up to 2 IP addresses of DNS servers used to resolve the NFS file system domain name. The provided IP addresses can either be the IP addresses of a DNS forwarder or resolver that the customer manages and runs inside the customer VPC, or the IP addresses of the on-premises DNS servers.
	DnsIps []string `pulumi:"dnsIps"`
	// The version of the NFS (Network File System) protocol of the NFS data repository. The only supported value is NFS3, which indicates that the data repository must support the NFSv3 protocol. The only supported value is `NFS3`.
	Version string `pulumi:"version"`
}

type FileCacheDataRepositoryAssociationNfArgs struct {
	// A list of up to 2 IP addresses of DNS servers used to resolve the NFS file system domain name. The provided IP addresses can either be the IP addresses of a DNS forwarder or resolver that the customer manages and runs inside the customer VPC, or the IP addresses of the on-premises DNS servers.
	DnsIps pulumix.Input[[]string] `pulumi:"dnsIps"`
	// The version of the NFS (Network File System) protocol of the NFS data repository. The only supported value is NFS3, which indicates that the data repository must support the NFSv3 protocol. The only supported value is `NFS3`.
	Version pulumix.Input[string] `pulumi:"version"`
}

func (FileCacheDataRepositoryAssociationNfArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FileCacheDataRepositoryAssociationNf)(nil)).Elem()
}

func (i FileCacheDataRepositoryAssociationNfArgs) ToFileCacheDataRepositoryAssociationNfOutput() FileCacheDataRepositoryAssociationNfOutput {
	return i.ToFileCacheDataRepositoryAssociationNfOutputWithContext(context.Background())
}

func (i FileCacheDataRepositoryAssociationNfArgs) ToFileCacheDataRepositoryAssociationNfOutputWithContext(ctx context.Context) FileCacheDataRepositoryAssociationNfOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FileCacheDataRepositoryAssociationNfOutput)
}

func (i *FileCacheDataRepositoryAssociationNfArgs) ToOutput(ctx context.Context) pulumix.Output[*FileCacheDataRepositoryAssociationNfArgs] {
	return pulumix.Val(i)
}

type FileCacheDataRepositoryAssociationNfOutput struct{ *pulumi.OutputState }

func (FileCacheDataRepositoryAssociationNfOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FileCacheDataRepositoryAssociationNf)(nil)).Elem()
}

func (o FileCacheDataRepositoryAssociationNfOutput) ToFileCacheDataRepositoryAssociationNfOutput() FileCacheDataRepositoryAssociationNfOutput {
	return o
}

func (o FileCacheDataRepositoryAssociationNfOutput) ToFileCacheDataRepositoryAssociationNfOutputWithContext(ctx context.Context) FileCacheDataRepositoryAssociationNfOutput {
	return o
}

func (o FileCacheDataRepositoryAssociationNfOutput) ToOutput(ctx context.Context) pulumix.Output[FileCacheDataRepositoryAssociationNf] {
	return pulumix.Output[FileCacheDataRepositoryAssociationNf]{
		OutputState: o.OutputState,
	}
}

// A list of up to 2 IP addresses of DNS servers used to resolve the NFS file system domain name. The provided IP addresses can either be the IP addresses of a DNS forwarder or resolver that the customer manages and runs inside the customer VPC, or the IP addresses of the on-premises DNS servers.
func (o FileCacheDataRepositoryAssociationNfOutput) DnsIps() pulumix.ArrayOutput[string] {
	value := pulumix.Apply[FileCacheDataRepositoryAssociationNf](o, func(v FileCacheDataRepositoryAssociationNf) []string { return v.DnsIps })
	return pulumix.ArrayOutput[string]{OutputState: value.OutputState}
}

// The version of the NFS (Network File System) protocol of the NFS data repository. The only supported value is NFS3, which indicates that the data repository must support the NFSv3 protocol. The only supported value is `NFS3`.
func (o FileCacheDataRepositoryAssociationNfOutput) Version() pulumix.Output[string] {
	return pulumix.Apply[FileCacheDataRepositoryAssociationNf](o, func(v FileCacheDataRepositoryAssociationNf) string { return v.Version })
}

type FileCacheLustreConfiguration struct {
	// Specifies the cache deployment type. The only supported value is `CACHE_1`.
	DeploymentType    string                                         `pulumi:"deploymentType"`
	LogConfigurations []FileCacheLustreConfigurationLogConfiguration `pulumi:"logConfigurations"`
	// The configuration for a Lustre MDT (Metadata Target) storage volume. See the `metadataConfiguration` block.
	MetadataConfigurations []FileCacheLustreConfigurationMetadataConfiguration `pulumi:"metadataConfigurations"`
	MountName              *string                                             `pulumi:"mountName"`
	// Provisions the amount of read and write throughput for each 1 tebibyte (TiB) of cache storage capacity, in MB/s/TiB. The only supported value is `1000`.
	PerUnitStorageThroughput int `pulumi:"perUnitStorageThroughput"`
	// A recurring weekly time, in the format `D:HH:MM`. `D` is the day of the week, for which `1` represents Monday and `7` represents Sunday. `HH` is the zero-padded hour of the day (0-23), and `MM` is the zero-padded minute of the hour. For example, 1:05:00 specifies maintenance at 5 AM Monday. See the [ISO week date](https://en.wikipedia.org/wiki/ISO_week_date) for more information.
	WeeklyMaintenanceStartTime *string `pulumi:"weeklyMaintenanceStartTime"`
}

type FileCacheLustreConfigurationArgs struct {
	// Specifies the cache deployment type. The only supported value is `CACHE_1`.
	DeploymentType    pulumix.Input[string]                                              `pulumi:"deploymentType"`
	LogConfigurations pulumix.Input[[]*FileCacheLustreConfigurationLogConfigurationArgs] `pulumi:"logConfigurations"`
	// The configuration for a Lustre MDT (Metadata Target) storage volume. See the `metadataConfiguration` block.
	MetadataConfigurations pulumix.Input[[]*FileCacheLustreConfigurationMetadataConfigurationArgs] `pulumi:"metadataConfigurations"`
	MountName              pulumix.Input[*string]                                                  `pulumi:"mountName"`
	// Provisions the amount of read and write throughput for each 1 tebibyte (TiB) of cache storage capacity, in MB/s/TiB. The only supported value is `1000`.
	PerUnitStorageThroughput pulumix.Input[int] `pulumi:"perUnitStorageThroughput"`
	// A recurring weekly time, in the format `D:HH:MM`. `D` is the day of the week, for which `1` represents Monday and `7` represents Sunday. `HH` is the zero-padded hour of the day (0-23), and `MM` is the zero-padded minute of the hour. For example, 1:05:00 specifies maintenance at 5 AM Monday. See the [ISO week date](https://en.wikipedia.org/wiki/ISO_week_date) for more information.
	WeeklyMaintenanceStartTime pulumix.Input[*string] `pulumi:"weeklyMaintenanceStartTime"`
}

func (FileCacheLustreConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FileCacheLustreConfiguration)(nil)).Elem()
}

func (i FileCacheLustreConfigurationArgs) ToFileCacheLustreConfigurationOutput() FileCacheLustreConfigurationOutput {
	return i.ToFileCacheLustreConfigurationOutputWithContext(context.Background())
}

func (i FileCacheLustreConfigurationArgs) ToFileCacheLustreConfigurationOutputWithContext(ctx context.Context) FileCacheLustreConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FileCacheLustreConfigurationOutput)
}

func (i *FileCacheLustreConfigurationArgs) ToOutput(ctx context.Context) pulumix.Output[*FileCacheLustreConfigurationArgs] {
	return pulumix.Val(i)
}

type FileCacheLustreConfigurationOutput struct{ *pulumi.OutputState }

func (FileCacheLustreConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FileCacheLustreConfiguration)(nil)).Elem()
}

func (o FileCacheLustreConfigurationOutput) ToFileCacheLustreConfigurationOutput() FileCacheLustreConfigurationOutput {
	return o
}

func (o FileCacheLustreConfigurationOutput) ToFileCacheLustreConfigurationOutputWithContext(ctx context.Context) FileCacheLustreConfigurationOutput {
	return o
}

func (o FileCacheLustreConfigurationOutput) ToOutput(ctx context.Context) pulumix.Output[FileCacheLustreConfiguration] {
	return pulumix.Output[FileCacheLustreConfiguration]{
		OutputState: o.OutputState,
	}
}

// Specifies the cache deployment type. The only supported value is `CACHE_1`.
func (o FileCacheLustreConfigurationOutput) DeploymentType() pulumix.Output[string] {
	return pulumix.Apply[FileCacheLustreConfiguration](o, func(v FileCacheLustreConfiguration) string { return v.DeploymentType })
}

func (o FileCacheLustreConfigurationOutput) LogConfigurations() pulumix.GArrayOutput[FileCacheLustreConfigurationLogConfiguration, FileCacheLustreConfigurationLogConfigurationOutput] {
	value := pulumix.Apply[FileCacheLustreConfiguration](o, func(v FileCacheLustreConfiguration) []FileCacheLustreConfigurationLogConfiguration {
		return v.LogConfigurations
	})
	return pulumix.GArrayOutput[FileCacheLustreConfigurationLogConfiguration, FileCacheLustreConfigurationLogConfigurationOutput]{OutputState: value.OutputState}
}

// The configuration for a Lustre MDT (Metadata Target) storage volume. See the `metadataConfiguration` block.
func (o FileCacheLustreConfigurationOutput) MetadataConfigurations() pulumix.GArrayOutput[FileCacheLustreConfigurationMetadataConfiguration, FileCacheLustreConfigurationMetadataConfigurationOutput] {
	value := pulumix.Apply[FileCacheLustreConfiguration](o, func(v FileCacheLustreConfiguration) []FileCacheLustreConfigurationMetadataConfiguration {
		return v.MetadataConfigurations
	})
	return pulumix.GArrayOutput[FileCacheLustreConfigurationMetadataConfiguration, FileCacheLustreConfigurationMetadataConfigurationOutput]{OutputState: value.OutputState}
}

func (o FileCacheLustreConfigurationOutput) MountName() pulumix.Output[*string] {
	return pulumix.Apply[FileCacheLustreConfiguration](o, func(v FileCacheLustreConfiguration) *string { return v.MountName })
}

// Provisions the amount of read and write throughput for each 1 tebibyte (TiB) of cache storage capacity, in MB/s/TiB. The only supported value is `1000`.
func (o FileCacheLustreConfigurationOutput) PerUnitStorageThroughput() pulumix.Output[int] {
	return pulumix.Apply[FileCacheLustreConfiguration](o, func(v FileCacheLustreConfiguration) int { return v.PerUnitStorageThroughput })
}

// A recurring weekly time, in the format `D:HH:MM`. `D` is the day of the week, for which `1` represents Monday and `7` represents Sunday. `HH` is the zero-padded hour of the day (0-23), and `MM` is the zero-padded minute of the hour. For example, 1:05:00 specifies maintenance at 5 AM Monday. See the [ISO week date](https://en.wikipedia.org/wiki/ISO_week_date) for more information.
func (o FileCacheLustreConfigurationOutput) WeeklyMaintenanceStartTime() pulumix.Output[*string] {
	return pulumix.Apply[FileCacheLustreConfiguration](o, func(v FileCacheLustreConfiguration) *string { return v.WeeklyMaintenanceStartTime })
}

type FileCacheLustreConfigurationLogConfiguration struct {
	Destination *string `pulumi:"destination"`
	Level       *string `pulumi:"level"`
}

type FileCacheLustreConfigurationLogConfigurationArgs struct {
	Destination pulumix.Input[*string] `pulumi:"destination"`
	Level       pulumix.Input[*string] `pulumi:"level"`
}

func (FileCacheLustreConfigurationLogConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FileCacheLustreConfigurationLogConfiguration)(nil)).Elem()
}

func (i FileCacheLustreConfigurationLogConfigurationArgs) ToFileCacheLustreConfigurationLogConfigurationOutput() FileCacheLustreConfigurationLogConfigurationOutput {
	return i.ToFileCacheLustreConfigurationLogConfigurationOutputWithContext(context.Background())
}

func (i FileCacheLustreConfigurationLogConfigurationArgs) ToFileCacheLustreConfigurationLogConfigurationOutputWithContext(ctx context.Context) FileCacheLustreConfigurationLogConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FileCacheLustreConfigurationLogConfigurationOutput)
}

func (i *FileCacheLustreConfigurationLogConfigurationArgs) ToOutput(ctx context.Context) pulumix.Output[*FileCacheLustreConfigurationLogConfigurationArgs] {
	return pulumix.Val(i)
}

type FileCacheLustreConfigurationLogConfigurationOutput struct{ *pulumi.OutputState }

func (FileCacheLustreConfigurationLogConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FileCacheLustreConfigurationLogConfiguration)(nil)).Elem()
}

func (o FileCacheLustreConfigurationLogConfigurationOutput) ToFileCacheLustreConfigurationLogConfigurationOutput() FileCacheLustreConfigurationLogConfigurationOutput {
	return o
}

func (o FileCacheLustreConfigurationLogConfigurationOutput) ToFileCacheLustreConfigurationLogConfigurationOutputWithContext(ctx context.Context) FileCacheLustreConfigurationLogConfigurationOutput {
	return o
}

func (o FileCacheLustreConfigurationLogConfigurationOutput) ToOutput(ctx context.Context) pulumix.Output[FileCacheLustreConfigurationLogConfiguration] {
	return pulumix.Output[FileCacheLustreConfigurationLogConfiguration]{
		OutputState: o.OutputState,
	}
}

func (o FileCacheLustreConfigurationLogConfigurationOutput) Destination() pulumix.Output[*string] {
	return pulumix.Apply[FileCacheLustreConfigurationLogConfiguration](o, func(v FileCacheLustreConfigurationLogConfiguration) *string { return v.Destination })
}

func (o FileCacheLustreConfigurationLogConfigurationOutput) Level() pulumix.Output[*string] {
	return pulumix.Apply[FileCacheLustreConfigurationLogConfiguration](o, func(v FileCacheLustreConfigurationLogConfiguration) *string { return v.Level })
}

type FileCacheLustreConfigurationMetadataConfiguration struct {
	// The storage capacity of the Lustre MDT (Metadata Target) storage volume in gibibytes (GiB). The only supported value is `2400` GiB.
	StorageCapacity int `pulumi:"storageCapacity"`
}

type FileCacheLustreConfigurationMetadataConfigurationArgs struct {
	// The storage capacity of the Lustre MDT (Metadata Target) storage volume in gibibytes (GiB). The only supported value is `2400` GiB.
	StorageCapacity pulumix.Input[int] `pulumi:"storageCapacity"`
}

func (FileCacheLustreConfigurationMetadataConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FileCacheLustreConfigurationMetadataConfiguration)(nil)).Elem()
}

func (i FileCacheLustreConfigurationMetadataConfigurationArgs) ToFileCacheLustreConfigurationMetadataConfigurationOutput() FileCacheLustreConfigurationMetadataConfigurationOutput {
	return i.ToFileCacheLustreConfigurationMetadataConfigurationOutputWithContext(context.Background())
}

func (i FileCacheLustreConfigurationMetadataConfigurationArgs) ToFileCacheLustreConfigurationMetadataConfigurationOutputWithContext(ctx context.Context) FileCacheLustreConfigurationMetadataConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FileCacheLustreConfigurationMetadataConfigurationOutput)
}

func (i *FileCacheLustreConfigurationMetadataConfigurationArgs) ToOutput(ctx context.Context) pulumix.Output[*FileCacheLustreConfigurationMetadataConfigurationArgs] {
	return pulumix.Val(i)
}

type FileCacheLustreConfigurationMetadataConfigurationOutput struct{ *pulumi.OutputState }

func (FileCacheLustreConfigurationMetadataConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FileCacheLustreConfigurationMetadataConfiguration)(nil)).Elem()
}

func (o FileCacheLustreConfigurationMetadataConfigurationOutput) ToFileCacheLustreConfigurationMetadataConfigurationOutput() FileCacheLustreConfigurationMetadataConfigurationOutput {
	return o
}

func (o FileCacheLustreConfigurationMetadataConfigurationOutput) ToFileCacheLustreConfigurationMetadataConfigurationOutputWithContext(ctx context.Context) FileCacheLustreConfigurationMetadataConfigurationOutput {
	return o
}

func (o FileCacheLustreConfigurationMetadataConfigurationOutput) ToOutput(ctx context.Context) pulumix.Output[FileCacheLustreConfigurationMetadataConfiguration] {
	return pulumix.Output[FileCacheLustreConfigurationMetadataConfiguration]{
		OutputState: o.OutputState,
	}
}

// The storage capacity of the Lustre MDT (Metadata Target) storage volume in gibibytes (GiB). The only supported value is `2400` GiB.
func (o FileCacheLustreConfigurationMetadataConfigurationOutput) StorageCapacity() pulumix.Output[int] {
	return pulumix.Apply[FileCacheLustreConfigurationMetadataConfiguration](o, func(v FileCacheLustreConfigurationMetadataConfiguration) int { return v.StorageCapacity })
}

type LustreFileSystemLogConfiguration struct {
	// The Amazon Resource Name (ARN) that specifies the destination of the logs. The name of the Amazon CloudWatch Logs log group must begin with the `/aws/fsx` prefix. If you do not provide a destination, Amazon FSx will create and use a log stream in the CloudWatch Logs `/aws/fsx/lustre` log group.
	Destination *string `pulumi:"destination"`
	// Sets which data repository events are logged by Amazon FSx. Valid values are `WARN_ONLY`, `FAILURE_ONLY`, `ERROR_ONLY`, `WARN_ERROR` and `DISABLED`. Default value is `DISABLED`.
	Level *string `pulumi:"level"`
}

type LustreFileSystemLogConfigurationArgs struct {
	// The Amazon Resource Name (ARN) that specifies the destination of the logs. The name of the Amazon CloudWatch Logs log group must begin with the `/aws/fsx` prefix. If you do not provide a destination, Amazon FSx will create and use a log stream in the CloudWatch Logs `/aws/fsx/lustre` log group.
	Destination pulumix.Input[*string] `pulumi:"destination"`
	// Sets which data repository events are logged by Amazon FSx. Valid values are `WARN_ONLY`, `FAILURE_ONLY`, `ERROR_ONLY`, `WARN_ERROR` and `DISABLED`. Default value is `DISABLED`.
	Level pulumix.Input[*string] `pulumi:"level"`
}

func (LustreFileSystemLogConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LustreFileSystemLogConfiguration)(nil)).Elem()
}

func (i LustreFileSystemLogConfigurationArgs) ToLustreFileSystemLogConfigurationOutput() LustreFileSystemLogConfigurationOutput {
	return i.ToLustreFileSystemLogConfigurationOutputWithContext(context.Background())
}

func (i LustreFileSystemLogConfigurationArgs) ToLustreFileSystemLogConfigurationOutputWithContext(ctx context.Context) LustreFileSystemLogConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LustreFileSystemLogConfigurationOutput)
}

func (i *LustreFileSystemLogConfigurationArgs) ToOutput(ctx context.Context) pulumix.Output[*LustreFileSystemLogConfigurationArgs] {
	return pulumix.Val(i)
}

type LustreFileSystemLogConfigurationOutput struct{ *pulumi.OutputState }

func (LustreFileSystemLogConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LustreFileSystemLogConfiguration)(nil)).Elem()
}

func (o LustreFileSystemLogConfigurationOutput) ToLustreFileSystemLogConfigurationOutput() LustreFileSystemLogConfigurationOutput {
	return o
}

func (o LustreFileSystemLogConfigurationOutput) ToLustreFileSystemLogConfigurationOutputWithContext(ctx context.Context) LustreFileSystemLogConfigurationOutput {
	return o
}

func (o LustreFileSystemLogConfigurationOutput) ToOutput(ctx context.Context) pulumix.Output[LustreFileSystemLogConfiguration] {
	return pulumix.Output[LustreFileSystemLogConfiguration]{
		OutputState: o.OutputState,
	}
}

// The Amazon Resource Name (ARN) that specifies the destination of the logs. The name of the Amazon CloudWatch Logs log group must begin with the `/aws/fsx` prefix. If you do not provide a destination, Amazon FSx will create and use a log stream in the CloudWatch Logs `/aws/fsx/lustre` log group.
func (o LustreFileSystemLogConfigurationOutput) Destination() pulumix.Output[*string] {
	return pulumix.Apply[LustreFileSystemLogConfiguration](o, func(v LustreFileSystemLogConfiguration) *string { return v.Destination })
}

// Sets which data repository events are logged by Amazon FSx. Valid values are `WARN_ONLY`, `FAILURE_ONLY`, `ERROR_ONLY`, `WARN_ERROR` and `DISABLED`. Default value is `DISABLED`.
func (o LustreFileSystemLogConfigurationOutput) Level() pulumix.Output[*string] {
	return pulumix.Apply[LustreFileSystemLogConfiguration](o, func(v LustreFileSystemLogConfiguration) *string { return v.Level })
}

type LustreFileSystemRootSquashConfiguration struct {
	// When root squash is enabled, you can optionally specify an array of NIDs of clients for which root squash does not apply. A client NID is a Lustre Network Identifier used to uniquely identify a client. You can specify the NID as either a single address or a range of addresses: 1. A single address is described in standard Lustre NID format by specifying the client’s IP address followed by the Lustre network ID (for example, 10.0.1.6@tcp). 2. An address range is described using a dash to separate the range (for example, 10.0.[2-10].[1-255]@tcp).
	NoSquashNids []string `pulumi:"noSquashNids"`
	// You enable root squash by setting a user ID (UID) and group ID (GID) for the file system in the format UID:GID (for example, 365534:65534). The UID and GID values can range from 0 to 4294967294.
	RootSquash *string `pulumi:"rootSquash"`
}

type LustreFileSystemRootSquashConfigurationArgs struct {
	// When root squash is enabled, you can optionally specify an array of NIDs of clients for which root squash does not apply. A client NID is a Lustre Network Identifier used to uniquely identify a client. You can specify the NID as either a single address or a range of addresses: 1. A single address is described in standard Lustre NID format by specifying the client’s IP address followed by the Lustre network ID (for example, 10.0.1.6@tcp). 2. An address range is described using a dash to separate the range (for example, 10.0.[2-10].[1-255]@tcp).
	NoSquashNids pulumix.Input[[]string] `pulumi:"noSquashNids"`
	// You enable root squash by setting a user ID (UID) and group ID (GID) for the file system in the format UID:GID (for example, 365534:65534). The UID and GID values can range from 0 to 4294967294.
	RootSquash pulumix.Input[*string] `pulumi:"rootSquash"`
}

func (LustreFileSystemRootSquashConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LustreFileSystemRootSquashConfiguration)(nil)).Elem()
}

func (i LustreFileSystemRootSquashConfigurationArgs) ToLustreFileSystemRootSquashConfigurationOutput() LustreFileSystemRootSquashConfigurationOutput {
	return i.ToLustreFileSystemRootSquashConfigurationOutputWithContext(context.Background())
}

func (i LustreFileSystemRootSquashConfigurationArgs) ToLustreFileSystemRootSquashConfigurationOutputWithContext(ctx context.Context) LustreFileSystemRootSquashConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LustreFileSystemRootSquashConfigurationOutput)
}

func (i *LustreFileSystemRootSquashConfigurationArgs) ToOutput(ctx context.Context) pulumix.Output[*LustreFileSystemRootSquashConfigurationArgs] {
	return pulumix.Val(i)
}

type LustreFileSystemRootSquashConfigurationOutput struct{ *pulumi.OutputState }

func (LustreFileSystemRootSquashConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LustreFileSystemRootSquashConfiguration)(nil)).Elem()
}

func (o LustreFileSystemRootSquashConfigurationOutput) ToLustreFileSystemRootSquashConfigurationOutput() LustreFileSystemRootSquashConfigurationOutput {
	return o
}

func (o LustreFileSystemRootSquashConfigurationOutput) ToLustreFileSystemRootSquashConfigurationOutputWithContext(ctx context.Context) LustreFileSystemRootSquashConfigurationOutput {
	return o
}

func (o LustreFileSystemRootSquashConfigurationOutput) ToOutput(ctx context.Context) pulumix.Output[LustreFileSystemRootSquashConfiguration] {
	return pulumix.Output[LustreFileSystemRootSquashConfiguration]{
		OutputState: o.OutputState,
	}
}

// When root squash is enabled, you can optionally specify an array of NIDs of clients for which root squash does not apply. A client NID is a Lustre Network Identifier used to uniquely identify a client. You can specify the NID as either a single address or a range of addresses: 1. A single address is described in standard Lustre NID format by specifying the client’s IP address followed by the Lustre network ID (for example, 10.0.1.6@tcp). 2. An address range is described using a dash to separate the range (for example, 10.0.[2-10].[1-255]@tcp).
func (o LustreFileSystemRootSquashConfigurationOutput) NoSquashNids() pulumix.ArrayOutput[string] {
	value := pulumix.Apply[LustreFileSystemRootSquashConfiguration](o, func(v LustreFileSystemRootSquashConfiguration) []string { return v.NoSquashNids })
	return pulumix.ArrayOutput[string]{OutputState: value.OutputState}
}

// You enable root squash by setting a user ID (UID) and group ID (GID) for the file system in the format UID:GID (for example, 365534:65534). The UID and GID values can range from 0 to 4294967294.
func (o LustreFileSystemRootSquashConfigurationOutput) RootSquash() pulumix.Output[*string] {
	return pulumix.Apply[LustreFileSystemRootSquashConfiguration](o, func(v LustreFileSystemRootSquashConfiguration) *string { return v.RootSquash })
}

type OntapFileSystemDiskIopsConfiguration struct {
	// The total number of SSD IOPS provisioned for the file system.
	Iops *int `pulumi:"iops"`
	// Specifies whether the number of IOPS for the file system is using the system. Valid values are `AUTOMATIC` and `USER_PROVISIONED`. Default value is `AUTOMATIC`.
	Mode *string `pulumi:"mode"`
}

type OntapFileSystemDiskIopsConfigurationArgs struct {
	// The total number of SSD IOPS provisioned for the file system.
	Iops pulumix.Input[*int] `pulumi:"iops"`
	// Specifies whether the number of IOPS for the file system is using the system. Valid values are `AUTOMATIC` and `USER_PROVISIONED`. Default value is `AUTOMATIC`.
	Mode pulumix.Input[*string] `pulumi:"mode"`
}

func (OntapFileSystemDiskIopsConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*OntapFileSystemDiskIopsConfiguration)(nil)).Elem()
}

func (i OntapFileSystemDiskIopsConfigurationArgs) ToOntapFileSystemDiskIopsConfigurationOutput() OntapFileSystemDiskIopsConfigurationOutput {
	return i.ToOntapFileSystemDiskIopsConfigurationOutputWithContext(context.Background())
}

func (i OntapFileSystemDiskIopsConfigurationArgs) ToOntapFileSystemDiskIopsConfigurationOutputWithContext(ctx context.Context) OntapFileSystemDiskIopsConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OntapFileSystemDiskIopsConfigurationOutput)
}

func (i *OntapFileSystemDiskIopsConfigurationArgs) ToOutput(ctx context.Context) pulumix.Output[*OntapFileSystemDiskIopsConfigurationArgs] {
	return pulumix.Val(i)
}

type OntapFileSystemDiskIopsConfigurationOutput struct{ *pulumi.OutputState }

func (OntapFileSystemDiskIopsConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*OntapFileSystemDiskIopsConfiguration)(nil)).Elem()
}

func (o OntapFileSystemDiskIopsConfigurationOutput) ToOntapFileSystemDiskIopsConfigurationOutput() OntapFileSystemDiskIopsConfigurationOutput {
	return o
}

func (o OntapFileSystemDiskIopsConfigurationOutput) ToOntapFileSystemDiskIopsConfigurationOutputWithContext(ctx context.Context) OntapFileSystemDiskIopsConfigurationOutput {
	return o
}

func (o OntapFileSystemDiskIopsConfigurationOutput) ToOutput(ctx context.Context) pulumix.Output[OntapFileSystemDiskIopsConfiguration] {
	return pulumix.Output[OntapFileSystemDiskIopsConfiguration]{
		OutputState: o.OutputState,
	}
}

// The total number of SSD IOPS provisioned for the file system.
func (o OntapFileSystemDiskIopsConfigurationOutput) Iops() pulumix.Output[*int] {
	return pulumix.Apply[OntapFileSystemDiskIopsConfiguration](o, func(v OntapFileSystemDiskIopsConfiguration) *int { return v.Iops })
}

// Specifies whether the number of IOPS for the file system is using the system. Valid values are `AUTOMATIC` and `USER_PROVISIONED`. Default value is `AUTOMATIC`.
func (o OntapFileSystemDiskIopsConfigurationOutput) Mode() pulumix.Output[*string] {
	return pulumix.Apply[OntapFileSystemDiskIopsConfiguration](o, func(v OntapFileSystemDiskIopsConfiguration) *string { return v.Mode })
}

type OntapFileSystemEndpoint struct {
	// An endpoint for managing your file system by setting up NetApp SnapMirror with other ONTAP systems. See Endpoint.
	Interclusters []OntapFileSystemEndpointIntercluster `pulumi:"interclusters"`
	// An endpoint for managing your file system using the NetApp ONTAP CLI and NetApp ONTAP API. See Endpoint.
	Managements []OntapFileSystemEndpointManagement `pulumi:"managements"`
}

type OntapFileSystemEndpointArgs struct {
	// An endpoint for managing your file system by setting up NetApp SnapMirror with other ONTAP systems. See Endpoint.
	Interclusters pulumix.Input[[]*OntapFileSystemEndpointInterclusterArgs] `pulumi:"interclusters"`
	// An endpoint for managing your file system using the NetApp ONTAP CLI and NetApp ONTAP API. See Endpoint.
	Managements pulumix.Input[[]*OntapFileSystemEndpointManagementArgs] `pulumi:"managements"`
}

func (OntapFileSystemEndpointArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*OntapFileSystemEndpoint)(nil)).Elem()
}

func (i OntapFileSystemEndpointArgs) ToOntapFileSystemEndpointOutput() OntapFileSystemEndpointOutput {
	return i.ToOntapFileSystemEndpointOutputWithContext(context.Background())
}

func (i OntapFileSystemEndpointArgs) ToOntapFileSystemEndpointOutputWithContext(ctx context.Context) OntapFileSystemEndpointOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OntapFileSystemEndpointOutput)
}

func (i *OntapFileSystemEndpointArgs) ToOutput(ctx context.Context) pulumix.Output[*OntapFileSystemEndpointArgs] {
	return pulumix.Val(i)
}

type OntapFileSystemEndpointOutput struct{ *pulumi.OutputState }

func (OntapFileSystemEndpointOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*OntapFileSystemEndpoint)(nil)).Elem()
}

func (o OntapFileSystemEndpointOutput) ToOntapFileSystemEndpointOutput() OntapFileSystemEndpointOutput {
	return o
}

func (o OntapFileSystemEndpointOutput) ToOntapFileSystemEndpointOutputWithContext(ctx context.Context) OntapFileSystemEndpointOutput {
	return o
}

func (o OntapFileSystemEndpointOutput) ToOutput(ctx context.Context) pulumix.Output[OntapFileSystemEndpoint] {
	return pulumix.Output[OntapFileSystemEndpoint]{
		OutputState: o.OutputState,
	}
}

// An endpoint for managing your file system by setting up NetApp SnapMirror with other ONTAP systems. See Endpoint.
func (o OntapFileSystemEndpointOutput) Interclusters() pulumix.GArrayOutput[OntapFileSystemEndpointIntercluster, OntapFileSystemEndpointInterclusterOutput] {
	value := pulumix.Apply[OntapFileSystemEndpoint](o, func(v OntapFileSystemEndpoint) []OntapFileSystemEndpointIntercluster { return v.Interclusters })
	return pulumix.GArrayOutput[OntapFileSystemEndpointIntercluster, OntapFileSystemEndpointInterclusterOutput]{OutputState: value.OutputState}
}

// An endpoint for managing your file system using the NetApp ONTAP CLI and NetApp ONTAP API. See Endpoint.
func (o OntapFileSystemEndpointOutput) Managements() pulumix.GArrayOutput[OntapFileSystemEndpointManagement, OntapFileSystemEndpointManagementOutput] {
	value := pulumix.Apply[OntapFileSystemEndpoint](o, func(v OntapFileSystemEndpoint) []OntapFileSystemEndpointManagement { return v.Managements })
	return pulumix.GArrayOutput[OntapFileSystemEndpointManagement, OntapFileSystemEndpointManagementOutput]{OutputState: value.OutputState}
}

type OntapFileSystemEndpointIntercluster struct {
	// The Domain Name Service (DNS) name for the file system. You can mount your file system using its DNS name.
	DnsName *string `pulumi:"dnsName"`
	// IP addresses of the file system endpoint.
	IpAddresses []string `pulumi:"ipAddresses"`
}

type OntapFileSystemEndpointInterclusterArgs struct {
	// The Domain Name Service (DNS) name for the file system. You can mount your file system using its DNS name.
	DnsName pulumix.Input[*string] `pulumi:"dnsName"`
	// IP addresses of the file system endpoint.
	IpAddresses pulumix.Input[[]string] `pulumi:"ipAddresses"`
}

func (OntapFileSystemEndpointInterclusterArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*OntapFileSystemEndpointIntercluster)(nil)).Elem()
}

func (i OntapFileSystemEndpointInterclusterArgs) ToOntapFileSystemEndpointInterclusterOutput() OntapFileSystemEndpointInterclusterOutput {
	return i.ToOntapFileSystemEndpointInterclusterOutputWithContext(context.Background())
}

func (i OntapFileSystemEndpointInterclusterArgs) ToOntapFileSystemEndpointInterclusterOutputWithContext(ctx context.Context) OntapFileSystemEndpointInterclusterOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OntapFileSystemEndpointInterclusterOutput)
}

func (i *OntapFileSystemEndpointInterclusterArgs) ToOutput(ctx context.Context) pulumix.Output[*OntapFileSystemEndpointInterclusterArgs] {
	return pulumix.Val(i)
}

type OntapFileSystemEndpointInterclusterOutput struct{ *pulumi.OutputState }

func (OntapFileSystemEndpointInterclusterOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*OntapFileSystemEndpointIntercluster)(nil)).Elem()
}

func (o OntapFileSystemEndpointInterclusterOutput) ToOntapFileSystemEndpointInterclusterOutput() OntapFileSystemEndpointInterclusterOutput {
	return o
}

func (o OntapFileSystemEndpointInterclusterOutput) ToOntapFileSystemEndpointInterclusterOutputWithContext(ctx context.Context) OntapFileSystemEndpointInterclusterOutput {
	return o
}

func (o OntapFileSystemEndpointInterclusterOutput) ToOutput(ctx context.Context) pulumix.Output[OntapFileSystemEndpointIntercluster] {
	return pulumix.Output[OntapFileSystemEndpointIntercluster]{
		OutputState: o.OutputState,
	}
}

// The Domain Name Service (DNS) name for the file system. You can mount your file system using its DNS name.
func (o OntapFileSystemEndpointInterclusterOutput) DnsName() pulumix.Output[*string] {
	return pulumix.Apply[OntapFileSystemEndpointIntercluster](o, func(v OntapFileSystemEndpointIntercluster) *string { return v.DnsName })
}

// IP addresses of the file system endpoint.
func (o OntapFileSystemEndpointInterclusterOutput) IpAddresses() pulumix.ArrayOutput[string] {
	value := pulumix.Apply[OntapFileSystemEndpointIntercluster](o, func(v OntapFileSystemEndpointIntercluster) []string { return v.IpAddresses })
	return pulumix.ArrayOutput[string]{OutputState: value.OutputState}
}

type OntapFileSystemEndpointManagement struct {
	// The Domain Name Service (DNS) name for the file system. You can mount your file system using its DNS name.
	DnsName *string `pulumi:"dnsName"`
	// IP addresses of the file system endpoint.
	IpAddresses []string `pulumi:"ipAddresses"`
}

type OntapFileSystemEndpointManagementArgs struct {
	// The Domain Name Service (DNS) name for the file system. You can mount your file system using its DNS name.
	DnsName pulumix.Input[*string] `pulumi:"dnsName"`
	// IP addresses of the file system endpoint.
	IpAddresses pulumix.Input[[]string] `pulumi:"ipAddresses"`
}

func (OntapFileSystemEndpointManagementArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*OntapFileSystemEndpointManagement)(nil)).Elem()
}

func (i OntapFileSystemEndpointManagementArgs) ToOntapFileSystemEndpointManagementOutput() OntapFileSystemEndpointManagementOutput {
	return i.ToOntapFileSystemEndpointManagementOutputWithContext(context.Background())
}

func (i OntapFileSystemEndpointManagementArgs) ToOntapFileSystemEndpointManagementOutputWithContext(ctx context.Context) OntapFileSystemEndpointManagementOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OntapFileSystemEndpointManagementOutput)
}

func (i *OntapFileSystemEndpointManagementArgs) ToOutput(ctx context.Context) pulumix.Output[*OntapFileSystemEndpointManagementArgs] {
	return pulumix.Val(i)
}

type OntapFileSystemEndpointManagementOutput struct{ *pulumi.OutputState }

func (OntapFileSystemEndpointManagementOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*OntapFileSystemEndpointManagement)(nil)).Elem()
}

func (o OntapFileSystemEndpointManagementOutput) ToOntapFileSystemEndpointManagementOutput() OntapFileSystemEndpointManagementOutput {
	return o
}

func (o OntapFileSystemEndpointManagementOutput) ToOntapFileSystemEndpointManagementOutputWithContext(ctx context.Context) OntapFileSystemEndpointManagementOutput {
	return o
}

func (o OntapFileSystemEndpointManagementOutput) ToOutput(ctx context.Context) pulumix.Output[OntapFileSystemEndpointManagement] {
	return pulumix.Output[OntapFileSystemEndpointManagement]{
		OutputState: o.OutputState,
	}
}

// The Domain Name Service (DNS) name for the file system. You can mount your file system using its DNS name.
func (o OntapFileSystemEndpointManagementOutput) DnsName() pulumix.Output[*string] {
	return pulumix.Apply[OntapFileSystemEndpointManagement](o, func(v OntapFileSystemEndpointManagement) *string { return v.DnsName })
}

// IP addresses of the file system endpoint.
func (o OntapFileSystemEndpointManagementOutput) IpAddresses() pulumix.ArrayOutput[string] {
	value := pulumix.Apply[OntapFileSystemEndpointManagement](o, func(v OntapFileSystemEndpointManagement) []string { return v.IpAddresses })
	return pulumix.ArrayOutput[string]{OutputState: value.OutputState}
}

type OntapStorageVirtualMachineActiveDirectoryConfiguration struct {
	// The NetBIOS name of the Active Directory computer object that will be created for your SVM. This is often the same as the SVM name but can be different. AWS limits to 15 characters because of standard NetBIOS naming limits.
	NetbiosName                             *string                                                                                        `pulumi:"netbiosName"`
	SelfManagedActiveDirectoryConfiguration *OntapStorageVirtualMachineActiveDirectoryConfigurationSelfManagedActiveDirectoryConfiguration `pulumi:"selfManagedActiveDirectoryConfiguration"`
}

type OntapStorageVirtualMachineActiveDirectoryConfigurationArgs struct {
	// The NetBIOS name of the Active Directory computer object that will be created for your SVM. This is often the same as the SVM name but can be different. AWS limits to 15 characters because of standard NetBIOS naming limits.
	NetbiosName                             pulumix.Input[*string]                                                                                            `pulumi:"netbiosName"`
	SelfManagedActiveDirectoryConfiguration pulumix.Input[*OntapStorageVirtualMachineActiveDirectoryConfigurationSelfManagedActiveDirectoryConfigurationArgs] `pulumi:"selfManagedActiveDirectoryConfiguration"`
}

func (OntapStorageVirtualMachineActiveDirectoryConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*OntapStorageVirtualMachineActiveDirectoryConfiguration)(nil)).Elem()
}

func (i OntapStorageVirtualMachineActiveDirectoryConfigurationArgs) ToOntapStorageVirtualMachineActiveDirectoryConfigurationOutput() OntapStorageVirtualMachineActiveDirectoryConfigurationOutput {
	return i.ToOntapStorageVirtualMachineActiveDirectoryConfigurationOutputWithContext(context.Background())
}

func (i OntapStorageVirtualMachineActiveDirectoryConfigurationArgs) ToOntapStorageVirtualMachineActiveDirectoryConfigurationOutputWithContext(ctx context.Context) OntapStorageVirtualMachineActiveDirectoryConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OntapStorageVirtualMachineActiveDirectoryConfigurationOutput)
}

func (i *OntapStorageVirtualMachineActiveDirectoryConfigurationArgs) ToOutput(ctx context.Context) pulumix.Output[*OntapStorageVirtualMachineActiveDirectoryConfigurationArgs] {
	return pulumix.Val(i)
}

type OntapStorageVirtualMachineActiveDirectoryConfigurationOutput struct{ *pulumi.OutputState }

func (OntapStorageVirtualMachineActiveDirectoryConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*OntapStorageVirtualMachineActiveDirectoryConfiguration)(nil)).Elem()
}

func (o OntapStorageVirtualMachineActiveDirectoryConfigurationOutput) ToOntapStorageVirtualMachineActiveDirectoryConfigurationOutput() OntapStorageVirtualMachineActiveDirectoryConfigurationOutput {
	return o
}

func (o OntapStorageVirtualMachineActiveDirectoryConfigurationOutput) ToOntapStorageVirtualMachineActiveDirectoryConfigurationOutputWithContext(ctx context.Context) OntapStorageVirtualMachineActiveDirectoryConfigurationOutput {
	return o
}

func (o OntapStorageVirtualMachineActiveDirectoryConfigurationOutput) ToOutput(ctx context.Context) pulumix.Output[OntapStorageVirtualMachineActiveDirectoryConfiguration] {
	return pulumix.Output[OntapStorageVirtualMachineActiveDirectoryConfiguration]{
		OutputState: o.OutputState,
	}
}

// The NetBIOS name of the Active Directory computer object that will be created for your SVM. This is often the same as the SVM name but can be different. AWS limits to 15 characters because of standard NetBIOS naming limits.
func (o OntapStorageVirtualMachineActiveDirectoryConfigurationOutput) NetbiosName() pulumix.Output[*string] {
	return pulumix.Apply[OntapStorageVirtualMachineActiveDirectoryConfiguration](o, func(v OntapStorageVirtualMachineActiveDirectoryConfiguration) *string { return v.NetbiosName })
}

func (o OntapStorageVirtualMachineActiveDirectoryConfigurationOutput) SelfManagedActiveDirectoryConfiguration() pulumix.GPtrOutput[OntapStorageVirtualMachineActiveDirectoryConfigurationSelfManagedActiveDirectoryConfiguration, OntapStorageVirtualMachineActiveDirectoryConfigurationSelfManagedActiveDirectoryConfigurationOutput] {
	value := pulumix.Apply[OntapStorageVirtualMachineActiveDirectoryConfiguration](o, func(v OntapStorageVirtualMachineActiveDirectoryConfiguration) *OntapStorageVirtualMachineActiveDirectoryConfigurationSelfManagedActiveDirectoryConfiguration {
		return v.SelfManagedActiveDirectoryConfiguration
	})
	return pulumix.GPtrOutput[OntapStorageVirtualMachineActiveDirectoryConfigurationSelfManagedActiveDirectoryConfiguration, OntapStorageVirtualMachineActiveDirectoryConfigurationSelfManagedActiveDirectoryConfigurationOutput]{OutputState: value.OutputState}
}

type OntapStorageVirtualMachineActiveDirectoryConfigurationSelfManagedActiveDirectoryConfiguration struct {
	// A list of up to three IP addresses of DNS servers or domain controllers in the self-managed AD directory.
	DnsIps []string `pulumi:"dnsIps"`
	// The fully qualified domain name of the self-managed AD directory. For example, `corp.example.com`.
	DomainName string `pulumi:"domainName"`
	// The name of the domain group whose members are granted administrative privileges for the SVM. The group that you specify must already exist in your domain. Defaults to `Domain Admins`.
	FileSystemAdministratorsGroup *string `pulumi:"fileSystemAdministratorsGroup"`
	// The fully qualified distinguished name of the organizational unit within your self-managed AD directory that the Windows File Server instance will join. For example, `OU=FSx,DC=yourdomain,DC=corp,DC=com`. Only accepts OU as the direct parent of the SVM. If none is provided, the SVM is created in the default location of your self-managed AD directory. To learn more, see [RFC 2253](https://tools.ietf.org/html/rfc2253).
	OrganizationalUnitDistinguishedName *string `pulumi:"organizationalUnitDistinguishedName"`
	// The password for the service account on your self-managed AD domain that Amazon FSx will use to join to your AD domain.
	Password string `pulumi:"password"`
	// The user name for the service account on your self-managed AD domain that Amazon FSx will use to join to your AD domain.
	Username string `pulumi:"username"`
}

type OntapStorageVirtualMachineActiveDirectoryConfigurationSelfManagedActiveDirectoryConfigurationArgs struct {
	// A list of up to three IP addresses of DNS servers or domain controllers in the self-managed AD directory.
	DnsIps pulumix.Input[[]string] `pulumi:"dnsIps"`
	// The fully qualified domain name of the self-managed AD directory. For example, `corp.example.com`.
	DomainName pulumix.Input[string] `pulumi:"domainName"`
	// The name of the domain group whose members are granted administrative privileges for the SVM. The group that you specify must already exist in your domain. Defaults to `Domain Admins`.
	FileSystemAdministratorsGroup pulumix.Input[*string] `pulumi:"fileSystemAdministratorsGroup"`
	// The fully qualified distinguished name of the organizational unit within your self-managed AD directory that the Windows File Server instance will join. For example, `OU=FSx,DC=yourdomain,DC=corp,DC=com`. Only accepts OU as the direct parent of the SVM. If none is provided, the SVM is created in the default location of your self-managed AD directory. To learn more, see [RFC 2253](https://tools.ietf.org/html/rfc2253).
	OrganizationalUnitDistinguishedName pulumix.Input[*string] `pulumi:"organizationalUnitDistinguishedName"`
	// The password for the service account on your self-managed AD domain that Amazon FSx will use to join to your AD domain.
	Password pulumix.Input[string] `pulumi:"password"`
	// The user name for the service account on your self-managed AD domain that Amazon FSx will use to join to your AD domain.
	Username pulumix.Input[string] `pulumi:"username"`
}

func (OntapStorageVirtualMachineActiveDirectoryConfigurationSelfManagedActiveDirectoryConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*OntapStorageVirtualMachineActiveDirectoryConfigurationSelfManagedActiveDirectoryConfiguration)(nil)).Elem()
}

func (i OntapStorageVirtualMachineActiveDirectoryConfigurationSelfManagedActiveDirectoryConfigurationArgs) ToOntapStorageVirtualMachineActiveDirectoryConfigurationSelfManagedActiveDirectoryConfigurationOutput() OntapStorageVirtualMachineActiveDirectoryConfigurationSelfManagedActiveDirectoryConfigurationOutput {
	return i.ToOntapStorageVirtualMachineActiveDirectoryConfigurationSelfManagedActiveDirectoryConfigurationOutputWithContext(context.Background())
}

func (i OntapStorageVirtualMachineActiveDirectoryConfigurationSelfManagedActiveDirectoryConfigurationArgs) ToOntapStorageVirtualMachineActiveDirectoryConfigurationSelfManagedActiveDirectoryConfigurationOutputWithContext(ctx context.Context) OntapStorageVirtualMachineActiveDirectoryConfigurationSelfManagedActiveDirectoryConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OntapStorageVirtualMachineActiveDirectoryConfigurationSelfManagedActiveDirectoryConfigurationOutput)
}

func (i *OntapStorageVirtualMachineActiveDirectoryConfigurationSelfManagedActiveDirectoryConfigurationArgs) ToOutput(ctx context.Context) pulumix.Output[*OntapStorageVirtualMachineActiveDirectoryConfigurationSelfManagedActiveDirectoryConfigurationArgs] {
	return pulumix.Val(i)
}

type OntapStorageVirtualMachineActiveDirectoryConfigurationSelfManagedActiveDirectoryConfigurationOutput struct{ *pulumi.OutputState }

func (OntapStorageVirtualMachineActiveDirectoryConfigurationSelfManagedActiveDirectoryConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*OntapStorageVirtualMachineActiveDirectoryConfigurationSelfManagedActiveDirectoryConfiguration)(nil)).Elem()
}

func (o OntapStorageVirtualMachineActiveDirectoryConfigurationSelfManagedActiveDirectoryConfigurationOutput) ToOntapStorageVirtualMachineActiveDirectoryConfigurationSelfManagedActiveDirectoryConfigurationOutput() OntapStorageVirtualMachineActiveDirectoryConfigurationSelfManagedActiveDirectoryConfigurationOutput {
	return o
}

func (o OntapStorageVirtualMachineActiveDirectoryConfigurationSelfManagedActiveDirectoryConfigurationOutput) ToOntapStorageVirtualMachineActiveDirectoryConfigurationSelfManagedActiveDirectoryConfigurationOutputWithContext(ctx context.Context) OntapStorageVirtualMachineActiveDirectoryConfigurationSelfManagedActiveDirectoryConfigurationOutput {
	return o
}

func (o OntapStorageVirtualMachineActiveDirectoryConfigurationSelfManagedActiveDirectoryConfigurationOutput) ToOutput(ctx context.Context) pulumix.Output[OntapStorageVirtualMachineActiveDirectoryConfigurationSelfManagedActiveDirectoryConfiguration] {
	return pulumix.Output[OntapStorageVirtualMachineActiveDirectoryConfigurationSelfManagedActiveDirectoryConfiguration]{
		OutputState: o.OutputState,
	}
}

// A list of up to three IP addresses of DNS servers or domain controllers in the self-managed AD directory.
func (o OntapStorageVirtualMachineActiveDirectoryConfigurationSelfManagedActiveDirectoryConfigurationOutput) DnsIps() pulumix.ArrayOutput[string] {
	value := pulumix.Apply[OntapStorageVirtualMachineActiveDirectoryConfigurationSelfManagedActiveDirectoryConfiguration](o, func(v OntapStorageVirtualMachineActiveDirectoryConfigurationSelfManagedActiveDirectoryConfiguration) []string {
		return v.DnsIps
	})
	return pulumix.ArrayOutput[string]{OutputState: value.OutputState}
}

// The fully qualified domain name of the self-managed AD directory. For example, `corp.example.com`.
func (o OntapStorageVirtualMachineActiveDirectoryConfigurationSelfManagedActiveDirectoryConfigurationOutput) DomainName() pulumix.Output[string] {
	return pulumix.Apply[OntapStorageVirtualMachineActiveDirectoryConfigurationSelfManagedActiveDirectoryConfiguration](o, func(v OntapStorageVirtualMachineActiveDirectoryConfigurationSelfManagedActiveDirectoryConfiguration) string {
		return v.DomainName
	})
}

// The name of the domain group whose members are granted administrative privileges for the SVM. The group that you specify must already exist in your domain. Defaults to `Domain Admins`.
func (o OntapStorageVirtualMachineActiveDirectoryConfigurationSelfManagedActiveDirectoryConfigurationOutput) FileSystemAdministratorsGroup() pulumix.Output[*string] {
	return pulumix.Apply[OntapStorageVirtualMachineActiveDirectoryConfigurationSelfManagedActiveDirectoryConfiguration](o, func(v OntapStorageVirtualMachineActiveDirectoryConfigurationSelfManagedActiveDirectoryConfiguration) *string {
		return v.FileSystemAdministratorsGroup
	})
}

// The fully qualified distinguished name of the organizational unit within your self-managed AD directory that the Windows File Server instance will join. For example, `OU=FSx,DC=yourdomain,DC=corp,DC=com`. Only accepts OU as the direct parent of the SVM. If none is provided, the SVM is created in the default location of your self-managed AD directory. To learn more, see [RFC 2253](https://tools.ietf.org/html/rfc2253).
func (o OntapStorageVirtualMachineActiveDirectoryConfigurationSelfManagedActiveDirectoryConfigurationOutput) OrganizationalUnitDistinguishedName() pulumix.Output[*string] {
	return pulumix.Apply[OntapStorageVirtualMachineActiveDirectoryConfigurationSelfManagedActiveDirectoryConfiguration](o, func(v OntapStorageVirtualMachineActiveDirectoryConfigurationSelfManagedActiveDirectoryConfiguration) *string {
		return v.OrganizationalUnitDistinguishedName
	})
}

// The password for the service account on your self-managed AD domain that Amazon FSx will use to join to your AD domain.
func (o OntapStorageVirtualMachineActiveDirectoryConfigurationSelfManagedActiveDirectoryConfigurationOutput) Password() pulumix.Output[string] {
	return pulumix.Apply[OntapStorageVirtualMachineActiveDirectoryConfigurationSelfManagedActiveDirectoryConfiguration](o, func(v OntapStorageVirtualMachineActiveDirectoryConfigurationSelfManagedActiveDirectoryConfiguration) string {
		return v.Password
	})
}

// The user name for the service account on your self-managed AD domain that Amazon FSx will use to join to your AD domain.
func (o OntapStorageVirtualMachineActiveDirectoryConfigurationSelfManagedActiveDirectoryConfigurationOutput) Username() pulumix.Output[string] {
	return pulumix.Apply[OntapStorageVirtualMachineActiveDirectoryConfigurationSelfManagedActiveDirectoryConfiguration](o, func(v OntapStorageVirtualMachineActiveDirectoryConfigurationSelfManagedActiveDirectoryConfiguration) string {
		return v.Username
	})
}

type OntapStorageVirtualMachineEndpoint struct {
	// An endpoint for accessing data on your storage virtual machine via iSCSI protocol. See Endpoint.
	Iscsis []OntapStorageVirtualMachineEndpointIscsi `pulumi:"iscsis"`
	// An endpoint for managing your file system using the NetApp ONTAP CLI and NetApp ONTAP API. See Endpoint.
	Managements []OntapStorageVirtualMachineEndpointManagement `pulumi:"managements"`
	// An endpoint for accessing data on your storage virtual machine via NFS protocol. See Endpoint.
	Nfs []OntapStorageVirtualMachineEndpointNf `pulumi:"nfs"`
	// An endpoint for accessing data on your storage virtual machine via SMB protocol. This is only set if an activeDirectoryConfiguration has been set. See Endpoint.
	Smbs []OntapStorageVirtualMachineEndpointSmb `pulumi:"smbs"`
}

type OntapStorageVirtualMachineEndpointArgs struct {
	// An endpoint for accessing data on your storage virtual machine via iSCSI protocol. See Endpoint.
	Iscsis pulumix.Input[[]*OntapStorageVirtualMachineEndpointIscsiArgs] `pulumi:"iscsis"`
	// An endpoint for managing your file system using the NetApp ONTAP CLI and NetApp ONTAP API. See Endpoint.
	Managements pulumix.Input[[]*OntapStorageVirtualMachineEndpointManagementArgs] `pulumi:"managements"`
	// An endpoint for accessing data on your storage virtual machine via NFS protocol. See Endpoint.
	Nfs pulumix.Input[[]*OntapStorageVirtualMachineEndpointNfArgs] `pulumi:"nfs"`
	// An endpoint for accessing data on your storage virtual machine via SMB protocol. This is only set if an activeDirectoryConfiguration has been set. See Endpoint.
	Smbs pulumix.Input[[]*OntapStorageVirtualMachineEndpointSmbArgs] `pulumi:"smbs"`
}

func (OntapStorageVirtualMachineEndpointArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*OntapStorageVirtualMachineEndpoint)(nil)).Elem()
}

func (i OntapStorageVirtualMachineEndpointArgs) ToOntapStorageVirtualMachineEndpointOutput() OntapStorageVirtualMachineEndpointOutput {
	return i.ToOntapStorageVirtualMachineEndpointOutputWithContext(context.Background())
}

func (i OntapStorageVirtualMachineEndpointArgs) ToOntapStorageVirtualMachineEndpointOutputWithContext(ctx context.Context) OntapStorageVirtualMachineEndpointOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OntapStorageVirtualMachineEndpointOutput)
}

func (i *OntapStorageVirtualMachineEndpointArgs) ToOutput(ctx context.Context) pulumix.Output[*OntapStorageVirtualMachineEndpointArgs] {
	return pulumix.Val(i)
}

type OntapStorageVirtualMachineEndpointOutput struct{ *pulumi.OutputState }

func (OntapStorageVirtualMachineEndpointOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*OntapStorageVirtualMachineEndpoint)(nil)).Elem()
}

func (o OntapStorageVirtualMachineEndpointOutput) ToOntapStorageVirtualMachineEndpointOutput() OntapStorageVirtualMachineEndpointOutput {
	return o
}

func (o OntapStorageVirtualMachineEndpointOutput) ToOntapStorageVirtualMachineEndpointOutputWithContext(ctx context.Context) OntapStorageVirtualMachineEndpointOutput {
	return o
}

func (o OntapStorageVirtualMachineEndpointOutput) ToOutput(ctx context.Context) pulumix.Output[OntapStorageVirtualMachineEndpoint] {
	return pulumix.Output[OntapStorageVirtualMachineEndpoint]{
		OutputState: o.OutputState,
	}
}

// An endpoint for accessing data on your storage virtual machine via iSCSI protocol. See Endpoint.
func (o OntapStorageVirtualMachineEndpointOutput) Iscsis() pulumix.GArrayOutput[OntapStorageVirtualMachineEndpointIscsi, OntapStorageVirtualMachineEndpointIscsiOutput] {
	value := pulumix.Apply[OntapStorageVirtualMachineEndpoint](o, func(v OntapStorageVirtualMachineEndpoint) []OntapStorageVirtualMachineEndpointIscsi { return v.Iscsis })
	return pulumix.GArrayOutput[OntapStorageVirtualMachineEndpointIscsi, OntapStorageVirtualMachineEndpointIscsiOutput]{OutputState: value.OutputState}
}

// An endpoint for managing your file system using the NetApp ONTAP CLI and NetApp ONTAP API. See Endpoint.
func (o OntapStorageVirtualMachineEndpointOutput) Managements() pulumix.GArrayOutput[OntapStorageVirtualMachineEndpointManagement, OntapStorageVirtualMachineEndpointManagementOutput] {
	value := pulumix.Apply[OntapStorageVirtualMachineEndpoint](o, func(v OntapStorageVirtualMachineEndpoint) []OntapStorageVirtualMachineEndpointManagement {
		return v.Managements
	})
	return pulumix.GArrayOutput[OntapStorageVirtualMachineEndpointManagement, OntapStorageVirtualMachineEndpointManagementOutput]{OutputState: value.OutputState}
}

// An endpoint for accessing data on your storage virtual machine via NFS protocol. See Endpoint.
func (o OntapStorageVirtualMachineEndpointOutput) Nfs() pulumix.GArrayOutput[OntapStorageVirtualMachineEndpointNf, OntapStorageVirtualMachineEndpointNfOutput] {
	value := pulumix.Apply[OntapStorageVirtualMachineEndpoint](o, func(v OntapStorageVirtualMachineEndpoint) []OntapStorageVirtualMachineEndpointNf { return v.Nfs })
	return pulumix.GArrayOutput[OntapStorageVirtualMachineEndpointNf, OntapStorageVirtualMachineEndpointNfOutput]{OutputState: value.OutputState}
}

// An endpoint for accessing data on your storage virtual machine via SMB protocol. This is only set if an activeDirectoryConfiguration has been set. See Endpoint.
func (o OntapStorageVirtualMachineEndpointOutput) Smbs() pulumix.GArrayOutput[OntapStorageVirtualMachineEndpointSmb, OntapStorageVirtualMachineEndpointSmbOutput] {
	value := pulumix.Apply[OntapStorageVirtualMachineEndpoint](o, func(v OntapStorageVirtualMachineEndpoint) []OntapStorageVirtualMachineEndpointSmb { return v.Smbs })
	return pulumix.GArrayOutput[OntapStorageVirtualMachineEndpointSmb, OntapStorageVirtualMachineEndpointSmbOutput]{OutputState: value.OutputState}
}

type OntapStorageVirtualMachineEndpointIscsi struct {
	// The Domain Name Service (DNS) name for the storage virtual machine. You can mount your storage virtual machine using its DNS name.
	DnsName *string `pulumi:"dnsName"`
	// IP addresses of the storage virtual machine endpoint.
	IpAddresses []string `pulumi:"ipAddresses"`
}

type OntapStorageVirtualMachineEndpointIscsiArgs struct {
	// The Domain Name Service (DNS) name for the storage virtual machine. You can mount your storage virtual machine using its DNS name.
	DnsName pulumix.Input[*string] `pulumi:"dnsName"`
	// IP addresses of the storage virtual machine endpoint.
	IpAddresses pulumix.Input[[]string] `pulumi:"ipAddresses"`
}

func (OntapStorageVirtualMachineEndpointIscsiArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*OntapStorageVirtualMachineEndpointIscsi)(nil)).Elem()
}

func (i OntapStorageVirtualMachineEndpointIscsiArgs) ToOntapStorageVirtualMachineEndpointIscsiOutput() OntapStorageVirtualMachineEndpointIscsiOutput {
	return i.ToOntapStorageVirtualMachineEndpointIscsiOutputWithContext(context.Background())
}

func (i OntapStorageVirtualMachineEndpointIscsiArgs) ToOntapStorageVirtualMachineEndpointIscsiOutputWithContext(ctx context.Context) OntapStorageVirtualMachineEndpointIscsiOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OntapStorageVirtualMachineEndpointIscsiOutput)
}

func (i *OntapStorageVirtualMachineEndpointIscsiArgs) ToOutput(ctx context.Context) pulumix.Output[*OntapStorageVirtualMachineEndpointIscsiArgs] {
	return pulumix.Val(i)
}

type OntapStorageVirtualMachineEndpointIscsiOutput struct{ *pulumi.OutputState }

func (OntapStorageVirtualMachineEndpointIscsiOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*OntapStorageVirtualMachineEndpointIscsi)(nil)).Elem()
}

func (o OntapStorageVirtualMachineEndpointIscsiOutput) ToOntapStorageVirtualMachineEndpointIscsiOutput() OntapStorageVirtualMachineEndpointIscsiOutput {
	return o
}

func (o OntapStorageVirtualMachineEndpointIscsiOutput) ToOntapStorageVirtualMachineEndpointIscsiOutputWithContext(ctx context.Context) OntapStorageVirtualMachineEndpointIscsiOutput {
	return o
}

func (o OntapStorageVirtualMachineEndpointIscsiOutput) ToOutput(ctx context.Context) pulumix.Output[OntapStorageVirtualMachineEndpointIscsi] {
	return pulumix.Output[OntapStorageVirtualMachineEndpointIscsi]{
		OutputState: o.OutputState,
	}
}

// The Domain Name Service (DNS) name for the storage virtual machine. You can mount your storage virtual machine using its DNS name.
func (o OntapStorageVirtualMachineEndpointIscsiOutput) DnsName() pulumix.Output[*string] {
	return pulumix.Apply[OntapStorageVirtualMachineEndpointIscsi](o, func(v OntapStorageVirtualMachineEndpointIscsi) *string { return v.DnsName })
}

// IP addresses of the storage virtual machine endpoint.
func (o OntapStorageVirtualMachineEndpointIscsiOutput) IpAddresses() pulumix.ArrayOutput[string] {
	value := pulumix.Apply[OntapStorageVirtualMachineEndpointIscsi](o, func(v OntapStorageVirtualMachineEndpointIscsi) []string { return v.IpAddresses })
	return pulumix.ArrayOutput[string]{OutputState: value.OutputState}
}

type OntapStorageVirtualMachineEndpointManagement struct {
	// The Domain Name Service (DNS) name for the storage virtual machine. You can mount your storage virtual machine using its DNS name.
	DnsName *string `pulumi:"dnsName"`
	// IP addresses of the storage virtual machine endpoint.
	IpAddresses []string `pulumi:"ipAddresses"`
}

type OntapStorageVirtualMachineEndpointManagementArgs struct {
	// The Domain Name Service (DNS) name for the storage virtual machine. You can mount your storage virtual machine using its DNS name.
	DnsName pulumix.Input[*string] `pulumi:"dnsName"`
	// IP addresses of the storage virtual machine endpoint.
	IpAddresses pulumix.Input[[]string] `pulumi:"ipAddresses"`
}

func (OntapStorageVirtualMachineEndpointManagementArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*OntapStorageVirtualMachineEndpointManagement)(nil)).Elem()
}

func (i OntapStorageVirtualMachineEndpointManagementArgs) ToOntapStorageVirtualMachineEndpointManagementOutput() OntapStorageVirtualMachineEndpointManagementOutput {
	return i.ToOntapStorageVirtualMachineEndpointManagementOutputWithContext(context.Background())
}

func (i OntapStorageVirtualMachineEndpointManagementArgs) ToOntapStorageVirtualMachineEndpointManagementOutputWithContext(ctx context.Context) OntapStorageVirtualMachineEndpointManagementOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OntapStorageVirtualMachineEndpointManagementOutput)
}

func (i *OntapStorageVirtualMachineEndpointManagementArgs) ToOutput(ctx context.Context) pulumix.Output[*OntapStorageVirtualMachineEndpointManagementArgs] {
	return pulumix.Val(i)
}

type OntapStorageVirtualMachineEndpointManagementOutput struct{ *pulumi.OutputState }

func (OntapStorageVirtualMachineEndpointManagementOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*OntapStorageVirtualMachineEndpointManagement)(nil)).Elem()
}

func (o OntapStorageVirtualMachineEndpointManagementOutput) ToOntapStorageVirtualMachineEndpointManagementOutput() OntapStorageVirtualMachineEndpointManagementOutput {
	return o
}

func (o OntapStorageVirtualMachineEndpointManagementOutput) ToOntapStorageVirtualMachineEndpointManagementOutputWithContext(ctx context.Context) OntapStorageVirtualMachineEndpointManagementOutput {
	return o
}

func (o OntapStorageVirtualMachineEndpointManagementOutput) ToOutput(ctx context.Context) pulumix.Output[OntapStorageVirtualMachineEndpointManagement] {
	return pulumix.Output[OntapStorageVirtualMachineEndpointManagement]{
		OutputState: o.OutputState,
	}
}

// The Domain Name Service (DNS) name for the storage virtual machine. You can mount your storage virtual machine using its DNS name.
func (o OntapStorageVirtualMachineEndpointManagementOutput) DnsName() pulumix.Output[*string] {
	return pulumix.Apply[OntapStorageVirtualMachineEndpointManagement](o, func(v OntapStorageVirtualMachineEndpointManagement) *string { return v.DnsName })
}

// IP addresses of the storage virtual machine endpoint.
func (o OntapStorageVirtualMachineEndpointManagementOutput) IpAddresses() pulumix.ArrayOutput[string] {
	value := pulumix.Apply[OntapStorageVirtualMachineEndpointManagement](o, func(v OntapStorageVirtualMachineEndpointManagement) []string { return v.IpAddresses })
	return pulumix.ArrayOutput[string]{OutputState: value.OutputState}
}

type OntapStorageVirtualMachineEndpointNf struct {
	// The Domain Name Service (DNS) name for the storage virtual machine. You can mount your storage virtual machine using its DNS name.
	DnsName *string `pulumi:"dnsName"`
	// IP addresses of the storage virtual machine endpoint.
	IpAddresses []string `pulumi:"ipAddresses"`
}

type OntapStorageVirtualMachineEndpointNfArgs struct {
	// The Domain Name Service (DNS) name for the storage virtual machine. You can mount your storage virtual machine using its DNS name.
	DnsName pulumix.Input[*string] `pulumi:"dnsName"`
	// IP addresses of the storage virtual machine endpoint.
	IpAddresses pulumix.Input[[]string] `pulumi:"ipAddresses"`
}

func (OntapStorageVirtualMachineEndpointNfArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*OntapStorageVirtualMachineEndpointNf)(nil)).Elem()
}

func (i OntapStorageVirtualMachineEndpointNfArgs) ToOntapStorageVirtualMachineEndpointNfOutput() OntapStorageVirtualMachineEndpointNfOutput {
	return i.ToOntapStorageVirtualMachineEndpointNfOutputWithContext(context.Background())
}

func (i OntapStorageVirtualMachineEndpointNfArgs) ToOntapStorageVirtualMachineEndpointNfOutputWithContext(ctx context.Context) OntapStorageVirtualMachineEndpointNfOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OntapStorageVirtualMachineEndpointNfOutput)
}

func (i *OntapStorageVirtualMachineEndpointNfArgs) ToOutput(ctx context.Context) pulumix.Output[*OntapStorageVirtualMachineEndpointNfArgs] {
	return pulumix.Val(i)
}

type OntapStorageVirtualMachineEndpointNfOutput struct{ *pulumi.OutputState }

func (OntapStorageVirtualMachineEndpointNfOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*OntapStorageVirtualMachineEndpointNf)(nil)).Elem()
}

func (o OntapStorageVirtualMachineEndpointNfOutput) ToOntapStorageVirtualMachineEndpointNfOutput() OntapStorageVirtualMachineEndpointNfOutput {
	return o
}

func (o OntapStorageVirtualMachineEndpointNfOutput) ToOntapStorageVirtualMachineEndpointNfOutputWithContext(ctx context.Context) OntapStorageVirtualMachineEndpointNfOutput {
	return o
}

func (o OntapStorageVirtualMachineEndpointNfOutput) ToOutput(ctx context.Context) pulumix.Output[OntapStorageVirtualMachineEndpointNf] {
	return pulumix.Output[OntapStorageVirtualMachineEndpointNf]{
		OutputState: o.OutputState,
	}
}

// The Domain Name Service (DNS) name for the storage virtual machine. You can mount your storage virtual machine using its DNS name.
func (o OntapStorageVirtualMachineEndpointNfOutput) DnsName() pulumix.Output[*string] {
	return pulumix.Apply[OntapStorageVirtualMachineEndpointNf](o, func(v OntapStorageVirtualMachineEndpointNf) *string { return v.DnsName })
}

// IP addresses of the storage virtual machine endpoint.
func (o OntapStorageVirtualMachineEndpointNfOutput) IpAddresses() pulumix.ArrayOutput[string] {
	value := pulumix.Apply[OntapStorageVirtualMachineEndpointNf](o, func(v OntapStorageVirtualMachineEndpointNf) []string { return v.IpAddresses })
	return pulumix.ArrayOutput[string]{OutputState: value.OutputState}
}

type OntapStorageVirtualMachineEndpointSmb struct {
	// The Domain Name Service (DNS) name for the storage virtual machine. You can mount your storage virtual machine using its DNS name.
	DnsName *string `pulumi:"dnsName"`
	// IP addresses of the storage virtual machine endpoint.
	IpAddresses []string `pulumi:"ipAddresses"`
}

type OntapStorageVirtualMachineEndpointSmbArgs struct {
	// The Domain Name Service (DNS) name for the storage virtual machine. You can mount your storage virtual machine using its DNS name.
	DnsName pulumix.Input[*string] `pulumi:"dnsName"`
	// IP addresses of the storage virtual machine endpoint.
	IpAddresses pulumix.Input[[]string] `pulumi:"ipAddresses"`
}

func (OntapStorageVirtualMachineEndpointSmbArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*OntapStorageVirtualMachineEndpointSmb)(nil)).Elem()
}

func (i OntapStorageVirtualMachineEndpointSmbArgs) ToOntapStorageVirtualMachineEndpointSmbOutput() OntapStorageVirtualMachineEndpointSmbOutput {
	return i.ToOntapStorageVirtualMachineEndpointSmbOutputWithContext(context.Background())
}

func (i OntapStorageVirtualMachineEndpointSmbArgs) ToOntapStorageVirtualMachineEndpointSmbOutputWithContext(ctx context.Context) OntapStorageVirtualMachineEndpointSmbOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OntapStorageVirtualMachineEndpointSmbOutput)
}

func (i *OntapStorageVirtualMachineEndpointSmbArgs) ToOutput(ctx context.Context) pulumix.Output[*OntapStorageVirtualMachineEndpointSmbArgs] {
	return pulumix.Val(i)
}

type OntapStorageVirtualMachineEndpointSmbOutput struct{ *pulumi.OutputState }

func (OntapStorageVirtualMachineEndpointSmbOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*OntapStorageVirtualMachineEndpointSmb)(nil)).Elem()
}

func (o OntapStorageVirtualMachineEndpointSmbOutput) ToOntapStorageVirtualMachineEndpointSmbOutput() OntapStorageVirtualMachineEndpointSmbOutput {
	return o
}

func (o OntapStorageVirtualMachineEndpointSmbOutput) ToOntapStorageVirtualMachineEndpointSmbOutputWithContext(ctx context.Context) OntapStorageVirtualMachineEndpointSmbOutput {
	return o
}

func (o OntapStorageVirtualMachineEndpointSmbOutput) ToOutput(ctx context.Context) pulumix.Output[OntapStorageVirtualMachineEndpointSmb] {
	return pulumix.Output[OntapStorageVirtualMachineEndpointSmb]{
		OutputState: o.OutputState,
	}
}

// The Domain Name Service (DNS) name for the storage virtual machine. You can mount your storage virtual machine using its DNS name.
func (o OntapStorageVirtualMachineEndpointSmbOutput) DnsName() pulumix.Output[*string] {
	return pulumix.Apply[OntapStorageVirtualMachineEndpointSmb](o, func(v OntapStorageVirtualMachineEndpointSmb) *string { return v.DnsName })
}

// IP addresses of the storage virtual machine endpoint.
func (o OntapStorageVirtualMachineEndpointSmbOutput) IpAddresses() pulumix.ArrayOutput[string] {
	value := pulumix.Apply[OntapStorageVirtualMachineEndpointSmb](o, func(v OntapStorageVirtualMachineEndpointSmb) []string { return v.IpAddresses })
	return pulumix.ArrayOutput[string]{OutputState: value.OutputState}
}

type OntapVolumeTieringPolicy struct {
	// Specifies the number of days that user data in a volume must remain inactive before it is considered "cold" and moved to the capacity pool. Used with `AUTO` and `SNAPSHOT_ONLY` tiering policies only. Valid values are whole numbers between 2 and 183. Default values are 31 days for `AUTO` and 2 days for `SNAPSHOT_ONLY`.
	CoolingPeriod *int `pulumi:"coolingPeriod"`
	// Specifies the tiering policy for the ONTAP volume for moving data to the capacity pool storage. Valid values are `SNAPSHOT_ONLY`, `AUTO`, `ALL`, `NONE`. Default value is `SNAPSHOT_ONLY`.
	Name *string `pulumi:"name"`
}

type OntapVolumeTieringPolicyArgs struct {
	// Specifies the number of days that user data in a volume must remain inactive before it is considered "cold" and moved to the capacity pool. Used with `AUTO` and `SNAPSHOT_ONLY` tiering policies only. Valid values are whole numbers between 2 and 183. Default values are 31 days for `AUTO` and 2 days for `SNAPSHOT_ONLY`.
	CoolingPeriod pulumix.Input[*int] `pulumi:"coolingPeriod"`
	// Specifies the tiering policy for the ONTAP volume for moving data to the capacity pool storage. Valid values are `SNAPSHOT_ONLY`, `AUTO`, `ALL`, `NONE`. Default value is `SNAPSHOT_ONLY`.
	Name pulumix.Input[*string] `pulumi:"name"`
}

func (OntapVolumeTieringPolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*OntapVolumeTieringPolicy)(nil)).Elem()
}

func (i OntapVolumeTieringPolicyArgs) ToOntapVolumeTieringPolicyOutput() OntapVolumeTieringPolicyOutput {
	return i.ToOntapVolumeTieringPolicyOutputWithContext(context.Background())
}

func (i OntapVolumeTieringPolicyArgs) ToOntapVolumeTieringPolicyOutputWithContext(ctx context.Context) OntapVolumeTieringPolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OntapVolumeTieringPolicyOutput)
}

func (i *OntapVolumeTieringPolicyArgs) ToOutput(ctx context.Context) pulumix.Output[*OntapVolumeTieringPolicyArgs] {
	return pulumix.Val(i)
}

type OntapVolumeTieringPolicyOutput struct{ *pulumi.OutputState }

func (OntapVolumeTieringPolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*OntapVolumeTieringPolicy)(nil)).Elem()
}

func (o OntapVolumeTieringPolicyOutput) ToOntapVolumeTieringPolicyOutput() OntapVolumeTieringPolicyOutput {
	return o
}

func (o OntapVolumeTieringPolicyOutput) ToOntapVolumeTieringPolicyOutputWithContext(ctx context.Context) OntapVolumeTieringPolicyOutput {
	return o
}

func (o OntapVolumeTieringPolicyOutput) ToOutput(ctx context.Context) pulumix.Output[OntapVolumeTieringPolicy] {
	return pulumix.Output[OntapVolumeTieringPolicy]{
		OutputState: o.OutputState,
	}
}

// Specifies the number of days that user data in a volume must remain inactive before it is considered "cold" and moved to the capacity pool. Used with `AUTO` and `SNAPSHOT_ONLY` tiering policies only. Valid values are whole numbers between 2 and 183. Default values are 31 days for `AUTO` and 2 days for `SNAPSHOT_ONLY`.
func (o OntapVolumeTieringPolicyOutput) CoolingPeriod() pulumix.Output[*int] {
	return pulumix.Apply[OntapVolumeTieringPolicy](o, func(v OntapVolumeTieringPolicy) *int { return v.CoolingPeriod })
}

// Specifies the tiering policy for the ONTAP volume for moving data to the capacity pool storage. Valid values are `SNAPSHOT_ONLY`, `AUTO`, `ALL`, `NONE`. Default value is `SNAPSHOT_ONLY`.
func (o OntapVolumeTieringPolicyOutput) Name() pulumix.Output[*string] {
	return pulumix.Apply[OntapVolumeTieringPolicy](o, func(v OntapVolumeTieringPolicy) *string { return v.Name })
}

type OpenZfsFileSystemDiskIopsConfiguration struct {
	// The total number of SSD IOPS provisioned for the file system.
	Iops *int `pulumi:"iops"`
	// Specifies whether the number of IOPS for the file system is using the system. Valid values are `AUTOMATIC` and `USER_PROVISIONED`. Default value is `AUTOMATIC`.
	Mode *string `pulumi:"mode"`
}

type OpenZfsFileSystemDiskIopsConfigurationArgs struct {
	// The total number of SSD IOPS provisioned for the file system.
	Iops pulumix.Input[*int] `pulumi:"iops"`
	// Specifies whether the number of IOPS for the file system is using the system. Valid values are `AUTOMATIC` and `USER_PROVISIONED`. Default value is `AUTOMATIC`.
	Mode pulumix.Input[*string] `pulumi:"mode"`
}

func (OpenZfsFileSystemDiskIopsConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*OpenZfsFileSystemDiskIopsConfiguration)(nil)).Elem()
}

func (i OpenZfsFileSystemDiskIopsConfigurationArgs) ToOpenZfsFileSystemDiskIopsConfigurationOutput() OpenZfsFileSystemDiskIopsConfigurationOutput {
	return i.ToOpenZfsFileSystemDiskIopsConfigurationOutputWithContext(context.Background())
}

func (i OpenZfsFileSystemDiskIopsConfigurationArgs) ToOpenZfsFileSystemDiskIopsConfigurationOutputWithContext(ctx context.Context) OpenZfsFileSystemDiskIopsConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OpenZfsFileSystemDiskIopsConfigurationOutput)
}

func (i *OpenZfsFileSystemDiskIopsConfigurationArgs) ToOutput(ctx context.Context) pulumix.Output[*OpenZfsFileSystemDiskIopsConfigurationArgs] {
	return pulumix.Val(i)
}

type OpenZfsFileSystemDiskIopsConfigurationOutput struct{ *pulumi.OutputState }

func (OpenZfsFileSystemDiskIopsConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*OpenZfsFileSystemDiskIopsConfiguration)(nil)).Elem()
}

func (o OpenZfsFileSystemDiskIopsConfigurationOutput) ToOpenZfsFileSystemDiskIopsConfigurationOutput() OpenZfsFileSystemDiskIopsConfigurationOutput {
	return o
}

func (o OpenZfsFileSystemDiskIopsConfigurationOutput) ToOpenZfsFileSystemDiskIopsConfigurationOutputWithContext(ctx context.Context) OpenZfsFileSystemDiskIopsConfigurationOutput {
	return o
}

func (o OpenZfsFileSystemDiskIopsConfigurationOutput) ToOutput(ctx context.Context) pulumix.Output[OpenZfsFileSystemDiskIopsConfiguration] {
	return pulumix.Output[OpenZfsFileSystemDiskIopsConfiguration]{
		OutputState: o.OutputState,
	}
}

// The total number of SSD IOPS provisioned for the file system.
func (o OpenZfsFileSystemDiskIopsConfigurationOutput) Iops() pulumix.Output[*int] {
	return pulumix.Apply[OpenZfsFileSystemDiskIopsConfiguration](o, func(v OpenZfsFileSystemDiskIopsConfiguration) *int { return v.Iops })
}

// Specifies whether the number of IOPS for the file system is using the system. Valid values are `AUTOMATIC` and `USER_PROVISIONED`. Default value is `AUTOMATIC`.
func (o OpenZfsFileSystemDiskIopsConfigurationOutput) Mode() pulumix.Output[*string] {
	return pulumix.Apply[OpenZfsFileSystemDiskIopsConfiguration](o, func(v OpenZfsFileSystemDiskIopsConfiguration) *string { return v.Mode })
}

type OpenZfsFileSystemRootVolumeConfiguration struct {
	// A boolean flag indicating whether tags for the file system should be copied to snapshots. The default value is false.
	CopyTagsToSnapshots *bool `pulumi:"copyTagsToSnapshots"`
	// Method used to compress the data on the volume. Valid values are `LZ4`, `NONE` or `ZSTD`. Child volumes that don't specify compression option will inherit from parent volume. This option on file system applies to the root volume.
	DataCompressionType *string `pulumi:"dataCompressionType"`
	// NFS export configuration for the root volume. Exactly 1 item. See NFS Exports Below.
	NfsExports *OpenZfsFileSystemRootVolumeConfigurationNfsExports `pulumi:"nfsExports"`
	// specifies whether the volume is read-only. Default is false.
	ReadOnly *bool `pulumi:"readOnly"`
	// Specifies the record size of an OpenZFS root volume, in kibibytes (KiB). Valid values are `4`, `8`, `16`, `32`, `64`, `128`, `256`, `512`, or `1024` KiB. The default is `128` KiB.
	RecordSizeKib *int `pulumi:"recordSizeKib"`
	// Specify how much storage users or groups can use on the volume. Maximum of 100 items. See User and Group Quotas Below.
	UserAndGroupQuotas []OpenZfsFileSystemRootVolumeConfigurationUserAndGroupQuota `pulumi:"userAndGroupQuotas"`
}

type OpenZfsFileSystemRootVolumeConfigurationArgs struct {
	// A boolean flag indicating whether tags for the file system should be copied to snapshots. The default value is false.
	CopyTagsToSnapshots pulumix.Input[*bool] `pulumi:"copyTagsToSnapshots"`
	// Method used to compress the data on the volume. Valid values are `LZ4`, `NONE` or `ZSTD`. Child volumes that don't specify compression option will inherit from parent volume. This option on file system applies to the root volume.
	DataCompressionType pulumix.Input[*string] `pulumi:"dataCompressionType"`
	// NFS export configuration for the root volume. Exactly 1 item. See NFS Exports Below.
	NfsExports pulumix.Input[*OpenZfsFileSystemRootVolumeConfigurationNfsExportsArgs] `pulumi:"nfsExports"`
	// specifies whether the volume is read-only. Default is false.
	ReadOnly pulumix.Input[*bool] `pulumi:"readOnly"`
	// Specifies the record size of an OpenZFS root volume, in kibibytes (KiB). Valid values are `4`, `8`, `16`, `32`, `64`, `128`, `256`, `512`, or `1024` KiB. The default is `128` KiB.
	RecordSizeKib pulumix.Input[*int] `pulumi:"recordSizeKib"`
	// Specify how much storage users or groups can use on the volume. Maximum of 100 items. See User and Group Quotas Below.
	UserAndGroupQuotas pulumix.Input[[]*OpenZfsFileSystemRootVolumeConfigurationUserAndGroupQuotaArgs] `pulumi:"userAndGroupQuotas"`
}

func (OpenZfsFileSystemRootVolumeConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*OpenZfsFileSystemRootVolumeConfiguration)(nil)).Elem()
}

func (i OpenZfsFileSystemRootVolumeConfigurationArgs) ToOpenZfsFileSystemRootVolumeConfigurationOutput() OpenZfsFileSystemRootVolumeConfigurationOutput {
	return i.ToOpenZfsFileSystemRootVolumeConfigurationOutputWithContext(context.Background())
}

func (i OpenZfsFileSystemRootVolumeConfigurationArgs) ToOpenZfsFileSystemRootVolumeConfigurationOutputWithContext(ctx context.Context) OpenZfsFileSystemRootVolumeConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OpenZfsFileSystemRootVolumeConfigurationOutput)
}

func (i *OpenZfsFileSystemRootVolumeConfigurationArgs) ToOutput(ctx context.Context) pulumix.Output[*OpenZfsFileSystemRootVolumeConfigurationArgs] {
	return pulumix.Val(i)
}

type OpenZfsFileSystemRootVolumeConfigurationOutput struct{ *pulumi.OutputState }

func (OpenZfsFileSystemRootVolumeConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*OpenZfsFileSystemRootVolumeConfiguration)(nil)).Elem()
}

func (o OpenZfsFileSystemRootVolumeConfigurationOutput) ToOpenZfsFileSystemRootVolumeConfigurationOutput() OpenZfsFileSystemRootVolumeConfigurationOutput {
	return o
}

func (o OpenZfsFileSystemRootVolumeConfigurationOutput) ToOpenZfsFileSystemRootVolumeConfigurationOutputWithContext(ctx context.Context) OpenZfsFileSystemRootVolumeConfigurationOutput {
	return o
}

func (o OpenZfsFileSystemRootVolumeConfigurationOutput) ToOutput(ctx context.Context) pulumix.Output[OpenZfsFileSystemRootVolumeConfiguration] {
	return pulumix.Output[OpenZfsFileSystemRootVolumeConfiguration]{
		OutputState: o.OutputState,
	}
}

// A boolean flag indicating whether tags for the file system should be copied to snapshots. The default value is false.
func (o OpenZfsFileSystemRootVolumeConfigurationOutput) CopyTagsToSnapshots() pulumix.Output[*bool] {
	return pulumix.Apply[OpenZfsFileSystemRootVolumeConfiguration](o, func(v OpenZfsFileSystemRootVolumeConfiguration) *bool { return v.CopyTagsToSnapshots })
}

// Method used to compress the data on the volume. Valid values are `LZ4`, `NONE` or `ZSTD`. Child volumes that don't specify compression option will inherit from parent volume. This option on file system applies to the root volume.
func (o OpenZfsFileSystemRootVolumeConfigurationOutput) DataCompressionType() pulumix.Output[*string] {
	return pulumix.Apply[OpenZfsFileSystemRootVolumeConfiguration](o, func(v OpenZfsFileSystemRootVolumeConfiguration) *string { return v.DataCompressionType })
}

// NFS export configuration for the root volume. Exactly 1 item. See NFS Exports Below.
func (o OpenZfsFileSystemRootVolumeConfigurationOutput) NfsExports() pulumix.GPtrOutput[OpenZfsFileSystemRootVolumeConfigurationNfsExports, OpenZfsFileSystemRootVolumeConfigurationNfsExportsOutput] {
	value := pulumix.Apply[OpenZfsFileSystemRootVolumeConfiguration](o, func(v OpenZfsFileSystemRootVolumeConfiguration) *OpenZfsFileSystemRootVolumeConfigurationNfsExports {
		return v.NfsExports
	})
	return pulumix.GPtrOutput[OpenZfsFileSystemRootVolumeConfigurationNfsExports, OpenZfsFileSystemRootVolumeConfigurationNfsExportsOutput]{OutputState: value.OutputState}
}

// specifies whether the volume is read-only. Default is false.
func (o OpenZfsFileSystemRootVolumeConfigurationOutput) ReadOnly() pulumix.Output[*bool] {
	return pulumix.Apply[OpenZfsFileSystemRootVolumeConfiguration](o, func(v OpenZfsFileSystemRootVolumeConfiguration) *bool { return v.ReadOnly })
}

// Specifies the record size of an OpenZFS root volume, in kibibytes (KiB). Valid values are `4`, `8`, `16`, `32`, `64`, `128`, `256`, `512`, or `1024` KiB. The default is `128` KiB.
func (o OpenZfsFileSystemRootVolumeConfigurationOutput) RecordSizeKib() pulumix.Output[*int] {
	return pulumix.Apply[OpenZfsFileSystemRootVolumeConfiguration](o, func(v OpenZfsFileSystemRootVolumeConfiguration) *int { return v.RecordSizeKib })
}

// Specify how much storage users or groups can use on the volume. Maximum of 100 items. See User and Group Quotas Below.
func (o OpenZfsFileSystemRootVolumeConfigurationOutput) UserAndGroupQuotas() pulumix.GArrayOutput[OpenZfsFileSystemRootVolumeConfigurationUserAndGroupQuota, OpenZfsFileSystemRootVolumeConfigurationUserAndGroupQuotaOutput] {
	value := pulumix.Apply[OpenZfsFileSystemRootVolumeConfiguration](o, func(v OpenZfsFileSystemRootVolumeConfiguration) []OpenZfsFileSystemRootVolumeConfigurationUserAndGroupQuota {
		return v.UserAndGroupQuotas
	})
	return pulumix.GArrayOutput[OpenZfsFileSystemRootVolumeConfigurationUserAndGroupQuota, OpenZfsFileSystemRootVolumeConfigurationUserAndGroupQuotaOutput]{OutputState: value.OutputState}
}

type OpenZfsFileSystemRootVolumeConfigurationNfsExports struct {
	// A list of configuration objects that contain the client and options for mounting the OpenZFS file system. Maximum of 25 items. See Client Configurations Below.
	ClientConfigurations []OpenZfsFileSystemRootVolumeConfigurationNfsExportsClientConfiguration `pulumi:"clientConfigurations"`
}

type OpenZfsFileSystemRootVolumeConfigurationNfsExportsArgs struct {
	// A list of configuration objects that contain the client and options for mounting the OpenZFS file system. Maximum of 25 items. See Client Configurations Below.
	ClientConfigurations pulumix.Input[[]*OpenZfsFileSystemRootVolumeConfigurationNfsExportsClientConfigurationArgs] `pulumi:"clientConfigurations"`
}

func (OpenZfsFileSystemRootVolumeConfigurationNfsExportsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*OpenZfsFileSystemRootVolumeConfigurationNfsExports)(nil)).Elem()
}

func (i OpenZfsFileSystemRootVolumeConfigurationNfsExportsArgs) ToOpenZfsFileSystemRootVolumeConfigurationNfsExportsOutput() OpenZfsFileSystemRootVolumeConfigurationNfsExportsOutput {
	return i.ToOpenZfsFileSystemRootVolumeConfigurationNfsExportsOutputWithContext(context.Background())
}

func (i OpenZfsFileSystemRootVolumeConfigurationNfsExportsArgs) ToOpenZfsFileSystemRootVolumeConfigurationNfsExportsOutputWithContext(ctx context.Context) OpenZfsFileSystemRootVolumeConfigurationNfsExportsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OpenZfsFileSystemRootVolumeConfigurationNfsExportsOutput)
}

func (i *OpenZfsFileSystemRootVolumeConfigurationNfsExportsArgs) ToOutput(ctx context.Context) pulumix.Output[*OpenZfsFileSystemRootVolumeConfigurationNfsExportsArgs] {
	return pulumix.Val(i)
}

type OpenZfsFileSystemRootVolumeConfigurationNfsExportsOutput struct{ *pulumi.OutputState }

func (OpenZfsFileSystemRootVolumeConfigurationNfsExportsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*OpenZfsFileSystemRootVolumeConfigurationNfsExports)(nil)).Elem()
}

func (o OpenZfsFileSystemRootVolumeConfigurationNfsExportsOutput) ToOpenZfsFileSystemRootVolumeConfigurationNfsExportsOutput() OpenZfsFileSystemRootVolumeConfigurationNfsExportsOutput {
	return o
}

func (o OpenZfsFileSystemRootVolumeConfigurationNfsExportsOutput) ToOpenZfsFileSystemRootVolumeConfigurationNfsExportsOutputWithContext(ctx context.Context) OpenZfsFileSystemRootVolumeConfigurationNfsExportsOutput {
	return o
}

func (o OpenZfsFileSystemRootVolumeConfigurationNfsExportsOutput) ToOutput(ctx context.Context) pulumix.Output[OpenZfsFileSystemRootVolumeConfigurationNfsExports] {
	return pulumix.Output[OpenZfsFileSystemRootVolumeConfigurationNfsExports]{
		OutputState: o.OutputState,
	}
}

// A list of configuration objects that contain the client and options for mounting the OpenZFS file system. Maximum of 25 items. See Client Configurations Below.
func (o OpenZfsFileSystemRootVolumeConfigurationNfsExportsOutput) ClientConfigurations() pulumix.GArrayOutput[OpenZfsFileSystemRootVolumeConfigurationNfsExportsClientConfiguration, OpenZfsFileSystemRootVolumeConfigurationNfsExportsClientConfigurationOutput] {
	value := pulumix.Apply[OpenZfsFileSystemRootVolumeConfigurationNfsExports](o, func(v OpenZfsFileSystemRootVolumeConfigurationNfsExports) []OpenZfsFileSystemRootVolumeConfigurationNfsExportsClientConfiguration {
		return v.ClientConfigurations
	})
	return pulumix.GArrayOutput[OpenZfsFileSystemRootVolumeConfigurationNfsExportsClientConfiguration, OpenZfsFileSystemRootVolumeConfigurationNfsExportsClientConfigurationOutput]{OutputState: value.OutputState}
}

type OpenZfsFileSystemRootVolumeConfigurationNfsExportsClientConfiguration struct {
	// A value that specifies who can mount the file system. You can provide a wildcard character (*), an IP address (0.0.0.0), or a CIDR address (192.0.2.0/24. By default, Amazon FSx uses the wildcard character when specifying the client.
	Clients string `pulumi:"clients"`
	// The options to use when mounting the file system. Maximum of 20 items. See the [Linix NFS exports man page](https://linux.die.net/man/5/exports) for more information. `crossmount` and `sync` are used by default.
	Options []string `pulumi:"options"`
}

type OpenZfsFileSystemRootVolumeConfigurationNfsExportsClientConfigurationArgs struct {
	// A value that specifies who can mount the file system. You can provide a wildcard character (*), an IP address (0.0.0.0), or a CIDR address (192.0.2.0/24. By default, Amazon FSx uses the wildcard character when specifying the client.
	Clients pulumix.Input[string] `pulumi:"clients"`
	// The options to use when mounting the file system. Maximum of 20 items. See the [Linix NFS exports man page](https://linux.die.net/man/5/exports) for more information. `crossmount` and `sync` are used by default.
	Options pulumix.Input[[]string] `pulumi:"options"`
}

func (OpenZfsFileSystemRootVolumeConfigurationNfsExportsClientConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*OpenZfsFileSystemRootVolumeConfigurationNfsExportsClientConfiguration)(nil)).Elem()
}

func (i OpenZfsFileSystemRootVolumeConfigurationNfsExportsClientConfigurationArgs) ToOpenZfsFileSystemRootVolumeConfigurationNfsExportsClientConfigurationOutput() OpenZfsFileSystemRootVolumeConfigurationNfsExportsClientConfigurationOutput {
	return i.ToOpenZfsFileSystemRootVolumeConfigurationNfsExportsClientConfigurationOutputWithContext(context.Background())
}

func (i OpenZfsFileSystemRootVolumeConfigurationNfsExportsClientConfigurationArgs) ToOpenZfsFileSystemRootVolumeConfigurationNfsExportsClientConfigurationOutputWithContext(ctx context.Context) OpenZfsFileSystemRootVolumeConfigurationNfsExportsClientConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OpenZfsFileSystemRootVolumeConfigurationNfsExportsClientConfigurationOutput)
}

func (i *OpenZfsFileSystemRootVolumeConfigurationNfsExportsClientConfigurationArgs) ToOutput(ctx context.Context) pulumix.Output[*OpenZfsFileSystemRootVolumeConfigurationNfsExportsClientConfigurationArgs] {
	return pulumix.Val(i)
}

type OpenZfsFileSystemRootVolumeConfigurationNfsExportsClientConfigurationOutput struct{ *pulumi.OutputState }

func (OpenZfsFileSystemRootVolumeConfigurationNfsExportsClientConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*OpenZfsFileSystemRootVolumeConfigurationNfsExportsClientConfiguration)(nil)).Elem()
}

func (o OpenZfsFileSystemRootVolumeConfigurationNfsExportsClientConfigurationOutput) ToOpenZfsFileSystemRootVolumeConfigurationNfsExportsClientConfigurationOutput() OpenZfsFileSystemRootVolumeConfigurationNfsExportsClientConfigurationOutput {
	return o
}

func (o OpenZfsFileSystemRootVolumeConfigurationNfsExportsClientConfigurationOutput) ToOpenZfsFileSystemRootVolumeConfigurationNfsExportsClientConfigurationOutputWithContext(ctx context.Context) OpenZfsFileSystemRootVolumeConfigurationNfsExportsClientConfigurationOutput {
	return o
}

func (o OpenZfsFileSystemRootVolumeConfigurationNfsExportsClientConfigurationOutput) ToOutput(ctx context.Context) pulumix.Output[OpenZfsFileSystemRootVolumeConfigurationNfsExportsClientConfiguration] {
	return pulumix.Output[OpenZfsFileSystemRootVolumeConfigurationNfsExportsClientConfiguration]{
		OutputState: o.OutputState,
	}
}

// A value that specifies who can mount the file system. You can provide a wildcard character (*), an IP address (0.0.0.0), or a CIDR address (192.0.2.0/24. By default, Amazon FSx uses the wildcard character when specifying the client.
func (o OpenZfsFileSystemRootVolumeConfigurationNfsExportsClientConfigurationOutput) Clients() pulumix.Output[string] {
	return pulumix.Apply[OpenZfsFileSystemRootVolumeConfigurationNfsExportsClientConfiguration](o, func(v OpenZfsFileSystemRootVolumeConfigurationNfsExportsClientConfiguration) string { return v.Clients })
}

// The options to use when mounting the file system. Maximum of 20 items. See the [Linix NFS exports man page](https://linux.die.net/man/5/exports) for more information. `crossmount` and `sync` are used by default.
func (o OpenZfsFileSystemRootVolumeConfigurationNfsExportsClientConfigurationOutput) Options() pulumix.ArrayOutput[string] {
	value := pulumix.Apply[OpenZfsFileSystemRootVolumeConfigurationNfsExportsClientConfiguration](o, func(v OpenZfsFileSystemRootVolumeConfigurationNfsExportsClientConfiguration) []string {
		return v.Options
	})
	return pulumix.ArrayOutput[string]{OutputState: value.OutputState}
}

type OpenZfsFileSystemRootVolumeConfigurationUserAndGroupQuota struct {
	// The ID of the user or group. Valid values between `0` and `2147483647`
	Id int `pulumi:"id"`
	// The amount of storage that the user or group can use in gibibytes (GiB). Valid values between `0` and `2147483647`
	StorageCapacityQuotaGib int `pulumi:"storageCapacityQuotaGib"`
	// A value that specifies whether the quota applies to a user or group. Valid values are `USER` or `GROUP`.
	Type string `pulumi:"type"`
}

type OpenZfsFileSystemRootVolumeConfigurationUserAndGroupQuotaArgs struct {
	// The ID of the user or group. Valid values between `0` and `2147483647`
	Id pulumix.Input[int] `pulumi:"id"`
	// The amount of storage that the user or group can use in gibibytes (GiB). Valid values between `0` and `2147483647`
	StorageCapacityQuotaGib pulumix.Input[int] `pulumi:"storageCapacityQuotaGib"`
	// A value that specifies whether the quota applies to a user or group. Valid values are `USER` or `GROUP`.
	Type pulumix.Input[string] `pulumi:"type"`
}

func (OpenZfsFileSystemRootVolumeConfigurationUserAndGroupQuotaArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*OpenZfsFileSystemRootVolumeConfigurationUserAndGroupQuota)(nil)).Elem()
}

func (i OpenZfsFileSystemRootVolumeConfigurationUserAndGroupQuotaArgs) ToOpenZfsFileSystemRootVolumeConfigurationUserAndGroupQuotaOutput() OpenZfsFileSystemRootVolumeConfigurationUserAndGroupQuotaOutput {
	return i.ToOpenZfsFileSystemRootVolumeConfigurationUserAndGroupQuotaOutputWithContext(context.Background())
}

func (i OpenZfsFileSystemRootVolumeConfigurationUserAndGroupQuotaArgs) ToOpenZfsFileSystemRootVolumeConfigurationUserAndGroupQuotaOutputWithContext(ctx context.Context) OpenZfsFileSystemRootVolumeConfigurationUserAndGroupQuotaOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OpenZfsFileSystemRootVolumeConfigurationUserAndGroupQuotaOutput)
}

func (i *OpenZfsFileSystemRootVolumeConfigurationUserAndGroupQuotaArgs) ToOutput(ctx context.Context) pulumix.Output[*OpenZfsFileSystemRootVolumeConfigurationUserAndGroupQuotaArgs] {
	return pulumix.Val(i)
}

type OpenZfsFileSystemRootVolumeConfigurationUserAndGroupQuotaOutput struct{ *pulumi.OutputState }

func (OpenZfsFileSystemRootVolumeConfigurationUserAndGroupQuotaOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*OpenZfsFileSystemRootVolumeConfigurationUserAndGroupQuota)(nil)).Elem()
}

func (o OpenZfsFileSystemRootVolumeConfigurationUserAndGroupQuotaOutput) ToOpenZfsFileSystemRootVolumeConfigurationUserAndGroupQuotaOutput() OpenZfsFileSystemRootVolumeConfigurationUserAndGroupQuotaOutput {
	return o
}

func (o OpenZfsFileSystemRootVolumeConfigurationUserAndGroupQuotaOutput) ToOpenZfsFileSystemRootVolumeConfigurationUserAndGroupQuotaOutputWithContext(ctx context.Context) OpenZfsFileSystemRootVolumeConfigurationUserAndGroupQuotaOutput {
	return o
}

func (o OpenZfsFileSystemRootVolumeConfigurationUserAndGroupQuotaOutput) ToOutput(ctx context.Context) pulumix.Output[OpenZfsFileSystemRootVolumeConfigurationUserAndGroupQuota] {
	return pulumix.Output[OpenZfsFileSystemRootVolumeConfigurationUserAndGroupQuota]{
		OutputState: o.OutputState,
	}
}

// The ID of the user or group. Valid values between `0` and `2147483647`
func (o OpenZfsFileSystemRootVolumeConfigurationUserAndGroupQuotaOutput) Id() pulumix.Output[int] {
	return pulumix.Apply[OpenZfsFileSystemRootVolumeConfigurationUserAndGroupQuota](o, func(v OpenZfsFileSystemRootVolumeConfigurationUserAndGroupQuota) int { return v.Id })
}

// The amount of storage that the user or group can use in gibibytes (GiB). Valid values between `0` and `2147483647`
func (o OpenZfsFileSystemRootVolumeConfigurationUserAndGroupQuotaOutput) StorageCapacityQuotaGib() pulumix.Output[int] {
	return pulumix.Apply[OpenZfsFileSystemRootVolumeConfigurationUserAndGroupQuota](o, func(v OpenZfsFileSystemRootVolumeConfigurationUserAndGroupQuota) int {
		return v.StorageCapacityQuotaGib
	})
}

// A value that specifies whether the quota applies to a user or group. Valid values are `USER` or `GROUP`.
func (o OpenZfsFileSystemRootVolumeConfigurationUserAndGroupQuotaOutput) Type() pulumix.Output[string] {
	return pulumix.Apply[OpenZfsFileSystemRootVolumeConfigurationUserAndGroupQuota](o, func(v OpenZfsFileSystemRootVolumeConfigurationUserAndGroupQuota) string { return v.Type })
}

type OpenZfsVolumeNfsExports struct {
	// A list of configuration objects that contain the client and options for mounting the OpenZFS file system. Maximum of 25 items. See Client Configurations Below.
	ClientConfigurations []OpenZfsVolumeNfsExportsClientConfiguration `pulumi:"clientConfigurations"`
}

type OpenZfsVolumeNfsExportsArgs struct {
	// A list of configuration objects that contain the client and options for mounting the OpenZFS file system. Maximum of 25 items. See Client Configurations Below.
	ClientConfigurations pulumix.Input[[]*OpenZfsVolumeNfsExportsClientConfigurationArgs] `pulumi:"clientConfigurations"`
}

func (OpenZfsVolumeNfsExportsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*OpenZfsVolumeNfsExports)(nil)).Elem()
}

func (i OpenZfsVolumeNfsExportsArgs) ToOpenZfsVolumeNfsExportsOutput() OpenZfsVolumeNfsExportsOutput {
	return i.ToOpenZfsVolumeNfsExportsOutputWithContext(context.Background())
}

func (i OpenZfsVolumeNfsExportsArgs) ToOpenZfsVolumeNfsExportsOutputWithContext(ctx context.Context) OpenZfsVolumeNfsExportsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OpenZfsVolumeNfsExportsOutput)
}

func (i *OpenZfsVolumeNfsExportsArgs) ToOutput(ctx context.Context) pulumix.Output[*OpenZfsVolumeNfsExportsArgs] {
	return pulumix.Val(i)
}

type OpenZfsVolumeNfsExportsOutput struct{ *pulumi.OutputState }

func (OpenZfsVolumeNfsExportsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*OpenZfsVolumeNfsExports)(nil)).Elem()
}

func (o OpenZfsVolumeNfsExportsOutput) ToOpenZfsVolumeNfsExportsOutput() OpenZfsVolumeNfsExportsOutput {
	return o
}

func (o OpenZfsVolumeNfsExportsOutput) ToOpenZfsVolumeNfsExportsOutputWithContext(ctx context.Context) OpenZfsVolumeNfsExportsOutput {
	return o
}

func (o OpenZfsVolumeNfsExportsOutput) ToOutput(ctx context.Context) pulumix.Output[OpenZfsVolumeNfsExports] {
	return pulumix.Output[OpenZfsVolumeNfsExports]{
		OutputState: o.OutputState,
	}
}

// A list of configuration objects that contain the client and options for mounting the OpenZFS file system. Maximum of 25 items. See Client Configurations Below.
func (o OpenZfsVolumeNfsExportsOutput) ClientConfigurations() pulumix.GArrayOutput[OpenZfsVolumeNfsExportsClientConfiguration, OpenZfsVolumeNfsExportsClientConfigurationOutput] {
	value := pulumix.Apply[OpenZfsVolumeNfsExports](o, func(v OpenZfsVolumeNfsExports) []OpenZfsVolumeNfsExportsClientConfiguration {
		return v.ClientConfigurations
	})
	return pulumix.GArrayOutput[OpenZfsVolumeNfsExportsClientConfiguration, OpenZfsVolumeNfsExportsClientConfigurationOutput]{OutputState: value.OutputState}
}

type OpenZfsVolumeNfsExportsClientConfiguration struct {
	// A value that specifies who can mount the file system. You can provide a wildcard character (*), an IP address (0.0.0.0), or a CIDR address (192.0.2.0/24. By default, Amazon FSx uses the wildcard character when specifying the client.
	Clients string `pulumi:"clients"`
	// The options to use when mounting the file system. Maximum of 20 items. See the [Linix NFS exports man page](https://linux.die.net/man/5/exports) for more information. `crossmount` and `sync` are used by default.
	Options []string `pulumi:"options"`
}

type OpenZfsVolumeNfsExportsClientConfigurationArgs struct {
	// A value that specifies who can mount the file system. You can provide a wildcard character (*), an IP address (0.0.0.0), or a CIDR address (192.0.2.0/24. By default, Amazon FSx uses the wildcard character when specifying the client.
	Clients pulumix.Input[string] `pulumi:"clients"`
	// The options to use when mounting the file system. Maximum of 20 items. See the [Linix NFS exports man page](https://linux.die.net/man/5/exports) for more information. `crossmount` and `sync` are used by default.
	Options pulumix.Input[[]string] `pulumi:"options"`
}

func (OpenZfsVolumeNfsExportsClientConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*OpenZfsVolumeNfsExportsClientConfiguration)(nil)).Elem()
}

func (i OpenZfsVolumeNfsExportsClientConfigurationArgs) ToOpenZfsVolumeNfsExportsClientConfigurationOutput() OpenZfsVolumeNfsExportsClientConfigurationOutput {
	return i.ToOpenZfsVolumeNfsExportsClientConfigurationOutputWithContext(context.Background())
}

func (i OpenZfsVolumeNfsExportsClientConfigurationArgs) ToOpenZfsVolumeNfsExportsClientConfigurationOutputWithContext(ctx context.Context) OpenZfsVolumeNfsExportsClientConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OpenZfsVolumeNfsExportsClientConfigurationOutput)
}

func (i *OpenZfsVolumeNfsExportsClientConfigurationArgs) ToOutput(ctx context.Context) pulumix.Output[*OpenZfsVolumeNfsExportsClientConfigurationArgs] {
	return pulumix.Val(i)
}

type OpenZfsVolumeNfsExportsClientConfigurationOutput struct{ *pulumi.OutputState }

func (OpenZfsVolumeNfsExportsClientConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*OpenZfsVolumeNfsExportsClientConfiguration)(nil)).Elem()
}

func (o OpenZfsVolumeNfsExportsClientConfigurationOutput) ToOpenZfsVolumeNfsExportsClientConfigurationOutput() OpenZfsVolumeNfsExportsClientConfigurationOutput {
	return o
}

func (o OpenZfsVolumeNfsExportsClientConfigurationOutput) ToOpenZfsVolumeNfsExportsClientConfigurationOutputWithContext(ctx context.Context) OpenZfsVolumeNfsExportsClientConfigurationOutput {
	return o
}

func (o OpenZfsVolumeNfsExportsClientConfigurationOutput) ToOutput(ctx context.Context) pulumix.Output[OpenZfsVolumeNfsExportsClientConfiguration] {
	return pulumix.Output[OpenZfsVolumeNfsExportsClientConfiguration]{
		OutputState: o.OutputState,
	}
}

// A value that specifies who can mount the file system. You can provide a wildcard character (*), an IP address (0.0.0.0), or a CIDR address (192.0.2.0/24. By default, Amazon FSx uses the wildcard character when specifying the client.
func (o OpenZfsVolumeNfsExportsClientConfigurationOutput) Clients() pulumix.Output[string] {
	return pulumix.Apply[OpenZfsVolumeNfsExportsClientConfiguration](o, func(v OpenZfsVolumeNfsExportsClientConfiguration) string { return v.Clients })
}

// The options to use when mounting the file system. Maximum of 20 items. See the [Linix NFS exports man page](https://linux.die.net/man/5/exports) for more information. `crossmount` and `sync` are used by default.
func (o OpenZfsVolumeNfsExportsClientConfigurationOutput) Options() pulumix.ArrayOutput[string] {
	value := pulumix.Apply[OpenZfsVolumeNfsExportsClientConfiguration](o, func(v OpenZfsVolumeNfsExportsClientConfiguration) []string { return v.Options })
	return pulumix.ArrayOutput[string]{OutputState: value.OutputState}
}

type OpenZfsVolumeOriginSnapshot struct {
	CopyStrategy string `pulumi:"copyStrategy"`
	SnapshotArn  string `pulumi:"snapshotArn"`
}

type OpenZfsVolumeOriginSnapshotArgs struct {
	CopyStrategy pulumix.Input[string] `pulumi:"copyStrategy"`
	SnapshotArn  pulumix.Input[string] `pulumi:"snapshotArn"`
}

func (OpenZfsVolumeOriginSnapshotArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*OpenZfsVolumeOriginSnapshot)(nil)).Elem()
}

func (i OpenZfsVolumeOriginSnapshotArgs) ToOpenZfsVolumeOriginSnapshotOutput() OpenZfsVolumeOriginSnapshotOutput {
	return i.ToOpenZfsVolumeOriginSnapshotOutputWithContext(context.Background())
}

func (i OpenZfsVolumeOriginSnapshotArgs) ToOpenZfsVolumeOriginSnapshotOutputWithContext(ctx context.Context) OpenZfsVolumeOriginSnapshotOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OpenZfsVolumeOriginSnapshotOutput)
}

func (i *OpenZfsVolumeOriginSnapshotArgs) ToOutput(ctx context.Context) pulumix.Output[*OpenZfsVolumeOriginSnapshotArgs] {
	return pulumix.Val(i)
}

type OpenZfsVolumeOriginSnapshotOutput struct{ *pulumi.OutputState }

func (OpenZfsVolumeOriginSnapshotOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*OpenZfsVolumeOriginSnapshot)(nil)).Elem()
}

func (o OpenZfsVolumeOriginSnapshotOutput) ToOpenZfsVolumeOriginSnapshotOutput() OpenZfsVolumeOriginSnapshotOutput {
	return o
}

func (o OpenZfsVolumeOriginSnapshotOutput) ToOpenZfsVolumeOriginSnapshotOutputWithContext(ctx context.Context) OpenZfsVolumeOriginSnapshotOutput {
	return o
}

func (o OpenZfsVolumeOriginSnapshotOutput) ToOutput(ctx context.Context) pulumix.Output[OpenZfsVolumeOriginSnapshot] {
	return pulumix.Output[OpenZfsVolumeOriginSnapshot]{
		OutputState: o.OutputState,
	}
}

func (o OpenZfsVolumeOriginSnapshotOutput) CopyStrategy() pulumix.Output[string] {
	return pulumix.Apply[OpenZfsVolumeOriginSnapshot](o, func(v OpenZfsVolumeOriginSnapshot) string { return v.CopyStrategy })
}

func (o OpenZfsVolumeOriginSnapshotOutput) SnapshotArn() pulumix.Output[string] {
	return pulumix.Apply[OpenZfsVolumeOriginSnapshot](o, func(v OpenZfsVolumeOriginSnapshot) string { return v.SnapshotArn })
}

type OpenZfsVolumeUserAndGroupQuota struct {
	// The ID of the user or group. Valid values between `0` and `2147483647`
	Id int `pulumi:"id"`
	// The amount of storage that the user or group can use in gibibytes (GiB). Valid values between `0` and `2147483647`
	StorageCapacityQuotaGib int    `pulumi:"storageCapacityQuotaGib"`
	Type                    string `pulumi:"type"`
}

type OpenZfsVolumeUserAndGroupQuotaArgs struct {
	// The ID of the user or group. Valid values between `0` and `2147483647`
	Id pulumix.Input[int] `pulumi:"id"`
	// The amount of storage that the user or group can use in gibibytes (GiB). Valid values between `0` and `2147483647`
	StorageCapacityQuotaGib pulumix.Input[int]    `pulumi:"storageCapacityQuotaGib"`
	Type                    pulumix.Input[string] `pulumi:"type"`
}

func (OpenZfsVolumeUserAndGroupQuotaArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*OpenZfsVolumeUserAndGroupQuota)(nil)).Elem()
}

func (i OpenZfsVolumeUserAndGroupQuotaArgs) ToOpenZfsVolumeUserAndGroupQuotaOutput() OpenZfsVolumeUserAndGroupQuotaOutput {
	return i.ToOpenZfsVolumeUserAndGroupQuotaOutputWithContext(context.Background())
}

func (i OpenZfsVolumeUserAndGroupQuotaArgs) ToOpenZfsVolumeUserAndGroupQuotaOutputWithContext(ctx context.Context) OpenZfsVolumeUserAndGroupQuotaOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OpenZfsVolumeUserAndGroupQuotaOutput)
}

func (i *OpenZfsVolumeUserAndGroupQuotaArgs) ToOutput(ctx context.Context) pulumix.Output[*OpenZfsVolumeUserAndGroupQuotaArgs] {
	return pulumix.Val(i)
}

type OpenZfsVolumeUserAndGroupQuotaOutput struct{ *pulumi.OutputState }

func (OpenZfsVolumeUserAndGroupQuotaOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*OpenZfsVolumeUserAndGroupQuota)(nil)).Elem()
}

func (o OpenZfsVolumeUserAndGroupQuotaOutput) ToOpenZfsVolumeUserAndGroupQuotaOutput() OpenZfsVolumeUserAndGroupQuotaOutput {
	return o
}

func (o OpenZfsVolumeUserAndGroupQuotaOutput) ToOpenZfsVolumeUserAndGroupQuotaOutputWithContext(ctx context.Context) OpenZfsVolumeUserAndGroupQuotaOutput {
	return o
}

func (o OpenZfsVolumeUserAndGroupQuotaOutput) ToOutput(ctx context.Context) pulumix.Output[OpenZfsVolumeUserAndGroupQuota] {
	return pulumix.Output[OpenZfsVolumeUserAndGroupQuota]{
		OutputState: o.OutputState,
	}
}

// The ID of the user or group. Valid values between `0` and `2147483647`
func (o OpenZfsVolumeUserAndGroupQuotaOutput) Id() pulumix.Output[int] {
	return pulumix.Apply[OpenZfsVolumeUserAndGroupQuota](o, func(v OpenZfsVolumeUserAndGroupQuota) int { return v.Id })
}

// The amount of storage that the user or group can use in gibibytes (GiB). Valid values between `0` and `2147483647`
func (o OpenZfsVolumeUserAndGroupQuotaOutput) StorageCapacityQuotaGib() pulumix.Output[int] {
	return pulumix.Apply[OpenZfsVolumeUserAndGroupQuota](o, func(v OpenZfsVolumeUserAndGroupQuota) int { return v.StorageCapacityQuotaGib })
}

func (o OpenZfsVolumeUserAndGroupQuotaOutput) Type() pulumix.Output[string] {
	return pulumix.Apply[OpenZfsVolumeUserAndGroupQuota](o, func(v OpenZfsVolumeUserAndGroupQuota) string { return v.Type })
}

type WindowsFileSystemAuditLogConfiguration struct {
	// The Amazon Resource Name (ARN) for the destination of the audit logs. The destination can be any Amazon CloudWatch Logs log group ARN or Amazon Kinesis Data Firehose delivery stream ARN. Can be specified when `fileAccessAuditLogLevel` and `fileShareAccessAuditLogLevel` are not set to `DISABLED`. The name of the Amazon CloudWatch Logs log group must begin with the `/aws/fsx` prefix. The name of the Amazon Kinesis Data Firehouse delivery stream must begin with the `aws-fsx` prefix. If you do not provide a destination in `auditLogDestionation`, Amazon FSx will create and use a log stream in the CloudWatch Logs /aws/fsx/windows log group.
	AuditLogDestination *string `pulumi:"auditLogDestination"`
	// Sets which attempt type is logged by Amazon FSx for file and folder accesses. Valid values are `SUCCESS_ONLY`, `FAILURE_ONLY`, `SUCCESS_AND_FAILURE`, and `DISABLED`. Default value is `DISABLED`.
	FileAccessAuditLogLevel *string `pulumi:"fileAccessAuditLogLevel"`
	// Sets which attempt type is logged by Amazon FSx for file share accesses. Valid values are `SUCCESS_ONLY`, `FAILURE_ONLY`, `SUCCESS_AND_FAILURE`, and `DISABLED`. Default value is `DISABLED`.
	FileShareAccessAuditLogLevel *string `pulumi:"fileShareAccessAuditLogLevel"`
}

type WindowsFileSystemAuditLogConfigurationArgs struct {
	// The Amazon Resource Name (ARN) for the destination of the audit logs. The destination can be any Amazon CloudWatch Logs log group ARN or Amazon Kinesis Data Firehose delivery stream ARN. Can be specified when `fileAccessAuditLogLevel` and `fileShareAccessAuditLogLevel` are not set to `DISABLED`. The name of the Amazon CloudWatch Logs log group must begin with the `/aws/fsx` prefix. The name of the Amazon Kinesis Data Firehouse delivery stream must begin with the `aws-fsx` prefix. If you do not provide a destination in `auditLogDestionation`, Amazon FSx will create and use a log stream in the CloudWatch Logs /aws/fsx/windows log group.
	AuditLogDestination pulumix.Input[*string] `pulumi:"auditLogDestination"`
	// Sets which attempt type is logged by Amazon FSx for file and folder accesses. Valid values are `SUCCESS_ONLY`, `FAILURE_ONLY`, `SUCCESS_AND_FAILURE`, and `DISABLED`. Default value is `DISABLED`.
	FileAccessAuditLogLevel pulumix.Input[*string] `pulumi:"fileAccessAuditLogLevel"`
	// Sets which attempt type is logged by Amazon FSx for file share accesses. Valid values are `SUCCESS_ONLY`, `FAILURE_ONLY`, `SUCCESS_AND_FAILURE`, and `DISABLED`. Default value is `DISABLED`.
	FileShareAccessAuditLogLevel pulumix.Input[*string] `pulumi:"fileShareAccessAuditLogLevel"`
}

func (WindowsFileSystemAuditLogConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WindowsFileSystemAuditLogConfiguration)(nil)).Elem()
}

func (i WindowsFileSystemAuditLogConfigurationArgs) ToWindowsFileSystemAuditLogConfigurationOutput() WindowsFileSystemAuditLogConfigurationOutput {
	return i.ToWindowsFileSystemAuditLogConfigurationOutputWithContext(context.Background())
}

func (i WindowsFileSystemAuditLogConfigurationArgs) ToWindowsFileSystemAuditLogConfigurationOutputWithContext(ctx context.Context) WindowsFileSystemAuditLogConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WindowsFileSystemAuditLogConfigurationOutput)
}

func (i *WindowsFileSystemAuditLogConfigurationArgs) ToOutput(ctx context.Context) pulumix.Output[*WindowsFileSystemAuditLogConfigurationArgs] {
	return pulumix.Val(i)
}

type WindowsFileSystemAuditLogConfigurationOutput struct{ *pulumi.OutputState }

func (WindowsFileSystemAuditLogConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WindowsFileSystemAuditLogConfiguration)(nil)).Elem()
}

func (o WindowsFileSystemAuditLogConfigurationOutput) ToWindowsFileSystemAuditLogConfigurationOutput() WindowsFileSystemAuditLogConfigurationOutput {
	return o
}

func (o WindowsFileSystemAuditLogConfigurationOutput) ToWindowsFileSystemAuditLogConfigurationOutputWithContext(ctx context.Context) WindowsFileSystemAuditLogConfigurationOutput {
	return o
}

func (o WindowsFileSystemAuditLogConfigurationOutput) ToOutput(ctx context.Context) pulumix.Output[WindowsFileSystemAuditLogConfiguration] {
	return pulumix.Output[WindowsFileSystemAuditLogConfiguration]{
		OutputState: o.OutputState,
	}
}

// The Amazon Resource Name (ARN) for the destination of the audit logs. The destination can be any Amazon CloudWatch Logs log group ARN or Amazon Kinesis Data Firehose delivery stream ARN. Can be specified when `fileAccessAuditLogLevel` and `fileShareAccessAuditLogLevel` are not set to `DISABLED`. The name of the Amazon CloudWatch Logs log group must begin with the `/aws/fsx` prefix. The name of the Amazon Kinesis Data Firehouse delivery stream must begin with the `aws-fsx` prefix. If you do not provide a destination in `auditLogDestionation`, Amazon FSx will create and use a log stream in the CloudWatch Logs /aws/fsx/windows log group.
func (o WindowsFileSystemAuditLogConfigurationOutput) AuditLogDestination() pulumix.Output[*string] {
	return pulumix.Apply[WindowsFileSystemAuditLogConfiguration](o, func(v WindowsFileSystemAuditLogConfiguration) *string { return v.AuditLogDestination })
}

// Sets which attempt type is logged by Amazon FSx for file and folder accesses. Valid values are `SUCCESS_ONLY`, `FAILURE_ONLY`, `SUCCESS_AND_FAILURE`, and `DISABLED`. Default value is `DISABLED`.
func (o WindowsFileSystemAuditLogConfigurationOutput) FileAccessAuditLogLevel() pulumix.Output[*string] {
	return pulumix.Apply[WindowsFileSystemAuditLogConfiguration](o, func(v WindowsFileSystemAuditLogConfiguration) *string { return v.FileAccessAuditLogLevel })
}

// Sets which attempt type is logged by Amazon FSx for file share accesses. Valid values are `SUCCESS_ONLY`, `FAILURE_ONLY`, `SUCCESS_AND_FAILURE`, and `DISABLED`. Default value is `DISABLED`.
func (o WindowsFileSystemAuditLogConfigurationOutput) FileShareAccessAuditLogLevel() pulumix.Output[*string] {
	return pulumix.Apply[WindowsFileSystemAuditLogConfiguration](o, func(v WindowsFileSystemAuditLogConfiguration) *string { return v.FileShareAccessAuditLogLevel })
}

type WindowsFileSystemSelfManagedActiveDirectory struct {
	// A list of up to two IP addresses of DNS servers or domain controllers in the self-managed AD directory. The IP addresses need to be either in the same VPC CIDR range as the file system or in the private IP version 4 (IPv4) address ranges as specified in [RFC 1918](https://tools.ietf.org/html/rfc1918).
	DnsIps []string `pulumi:"dnsIps"`
	// The fully qualified domain name of the self-managed AD directory. For example, `corp.example.com`.
	DomainName string `pulumi:"domainName"`
	// The name of the domain group whose members are granted administrative privileges for the file system. Administrative privileges include taking ownership of files and folders, and setting audit controls (audit ACLs) on files and folders. The group that you specify must already exist in your domain. Defaults to `Domain Admins`.
	FileSystemAdministratorsGroup *string `pulumi:"fileSystemAdministratorsGroup"`
	// The fully qualified distinguished name of the organizational unit within your self-managed AD directory that the Windows File Server instance will join. For example, `OU=FSx,DC=yourdomain,DC=corp,DC=com`. Only accepts OU as the direct parent of the file system. If none is provided, the FSx file system is created in the default location of your self-managed AD directory. To learn more, see [RFC 2253](https://tools.ietf.org/html/rfc2253).
	OrganizationalUnitDistinguishedName *string `pulumi:"organizationalUnitDistinguishedName"`
	// The password for the service account on your self-managed AD domain that Amazon FSx will use to join to your AD domain.
	Password string `pulumi:"password"`
	// The user name for the service account on your self-managed AD domain that Amazon FSx will use to join to your AD domain.
	Username string `pulumi:"username"`
}

type WindowsFileSystemSelfManagedActiveDirectoryArgs struct {
	// A list of up to two IP addresses of DNS servers or domain controllers in the self-managed AD directory. The IP addresses need to be either in the same VPC CIDR range as the file system or in the private IP version 4 (IPv4) address ranges as specified in [RFC 1918](https://tools.ietf.org/html/rfc1918).
	DnsIps pulumix.Input[[]string] `pulumi:"dnsIps"`
	// The fully qualified domain name of the self-managed AD directory. For example, `corp.example.com`.
	DomainName pulumix.Input[string] `pulumi:"domainName"`
	// The name of the domain group whose members are granted administrative privileges for the file system. Administrative privileges include taking ownership of files and folders, and setting audit controls (audit ACLs) on files and folders. The group that you specify must already exist in your domain. Defaults to `Domain Admins`.
	FileSystemAdministratorsGroup pulumix.Input[*string] `pulumi:"fileSystemAdministratorsGroup"`
	// The fully qualified distinguished name of the organizational unit within your self-managed AD directory that the Windows File Server instance will join. For example, `OU=FSx,DC=yourdomain,DC=corp,DC=com`. Only accepts OU as the direct parent of the file system. If none is provided, the FSx file system is created in the default location of your self-managed AD directory. To learn more, see [RFC 2253](https://tools.ietf.org/html/rfc2253).
	OrganizationalUnitDistinguishedName pulumix.Input[*string] `pulumi:"organizationalUnitDistinguishedName"`
	// The password for the service account on your self-managed AD domain that Amazon FSx will use to join to your AD domain.
	Password pulumix.Input[string] `pulumi:"password"`
	// The user name for the service account on your self-managed AD domain that Amazon FSx will use to join to your AD domain.
	Username pulumix.Input[string] `pulumi:"username"`
}

func (WindowsFileSystemSelfManagedActiveDirectoryArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WindowsFileSystemSelfManagedActiveDirectory)(nil)).Elem()
}

func (i WindowsFileSystemSelfManagedActiveDirectoryArgs) ToWindowsFileSystemSelfManagedActiveDirectoryOutput() WindowsFileSystemSelfManagedActiveDirectoryOutput {
	return i.ToWindowsFileSystemSelfManagedActiveDirectoryOutputWithContext(context.Background())
}

func (i WindowsFileSystemSelfManagedActiveDirectoryArgs) ToWindowsFileSystemSelfManagedActiveDirectoryOutputWithContext(ctx context.Context) WindowsFileSystemSelfManagedActiveDirectoryOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WindowsFileSystemSelfManagedActiveDirectoryOutput)
}

func (i *WindowsFileSystemSelfManagedActiveDirectoryArgs) ToOutput(ctx context.Context) pulumix.Output[*WindowsFileSystemSelfManagedActiveDirectoryArgs] {
	return pulumix.Val(i)
}

type WindowsFileSystemSelfManagedActiveDirectoryOutput struct{ *pulumi.OutputState }

func (WindowsFileSystemSelfManagedActiveDirectoryOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WindowsFileSystemSelfManagedActiveDirectory)(nil)).Elem()
}

func (o WindowsFileSystemSelfManagedActiveDirectoryOutput) ToWindowsFileSystemSelfManagedActiveDirectoryOutput() WindowsFileSystemSelfManagedActiveDirectoryOutput {
	return o
}

func (o WindowsFileSystemSelfManagedActiveDirectoryOutput) ToWindowsFileSystemSelfManagedActiveDirectoryOutputWithContext(ctx context.Context) WindowsFileSystemSelfManagedActiveDirectoryOutput {
	return o
}

func (o WindowsFileSystemSelfManagedActiveDirectoryOutput) ToOutput(ctx context.Context) pulumix.Output[WindowsFileSystemSelfManagedActiveDirectory] {
	return pulumix.Output[WindowsFileSystemSelfManagedActiveDirectory]{
		OutputState: o.OutputState,
	}
}

// A list of up to two IP addresses of DNS servers or domain controllers in the self-managed AD directory. The IP addresses need to be either in the same VPC CIDR range as the file system or in the private IP version 4 (IPv4) address ranges as specified in [RFC 1918](https://tools.ietf.org/html/rfc1918).
func (o WindowsFileSystemSelfManagedActiveDirectoryOutput) DnsIps() pulumix.ArrayOutput[string] {
	value := pulumix.Apply[WindowsFileSystemSelfManagedActiveDirectory](o, func(v WindowsFileSystemSelfManagedActiveDirectory) []string { return v.DnsIps })
	return pulumix.ArrayOutput[string]{OutputState: value.OutputState}
}

// The fully qualified domain name of the self-managed AD directory. For example, `corp.example.com`.
func (o WindowsFileSystemSelfManagedActiveDirectoryOutput) DomainName() pulumix.Output[string] {
	return pulumix.Apply[WindowsFileSystemSelfManagedActiveDirectory](o, func(v WindowsFileSystemSelfManagedActiveDirectory) string { return v.DomainName })
}

// The name of the domain group whose members are granted administrative privileges for the file system. Administrative privileges include taking ownership of files and folders, and setting audit controls (audit ACLs) on files and folders. The group that you specify must already exist in your domain. Defaults to `Domain Admins`.
func (o WindowsFileSystemSelfManagedActiveDirectoryOutput) FileSystemAdministratorsGroup() pulumix.Output[*string] {
	return pulumix.Apply[WindowsFileSystemSelfManagedActiveDirectory](o, func(v WindowsFileSystemSelfManagedActiveDirectory) *string { return v.FileSystemAdministratorsGroup })
}

// The fully qualified distinguished name of the organizational unit within your self-managed AD directory that the Windows File Server instance will join. For example, `OU=FSx,DC=yourdomain,DC=corp,DC=com`. Only accepts OU as the direct parent of the file system. If none is provided, the FSx file system is created in the default location of your self-managed AD directory. To learn more, see [RFC 2253](https://tools.ietf.org/html/rfc2253).
func (o WindowsFileSystemSelfManagedActiveDirectoryOutput) OrganizationalUnitDistinguishedName() pulumix.Output[*string] {
	return pulumix.Apply[WindowsFileSystemSelfManagedActiveDirectory](o, func(v WindowsFileSystemSelfManagedActiveDirectory) *string {
		return v.OrganizationalUnitDistinguishedName
	})
}

// The password for the service account on your self-managed AD domain that Amazon FSx will use to join to your AD domain.
func (o WindowsFileSystemSelfManagedActiveDirectoryOutput) Password() pulumix.Output[string] {
	return pulumix.Apply[WindowsFileSystemSelfManagedActiveDirectory](o, func(v WindowsFileSystemSelfManagedActiveDirectory) string { return v.Password })
}

// The user name for the service account on your self-managed AD domain that Amazon FSx will use to join to your AD domain.
func (o WindowsFileSystemSelfManagedActiveDirectoryOutput) Username() pulumix.Output[string] {
	return pulumix.Apply[WindowsFileSystemSelfManagedActiveDirectory](o, func(v WindowsFileSystemSelfManagedActiveDirectory) string { return v.Username })
}

type GetOpenZfsSnapshotFilter struct {
	// Name of the snapshot.
	Name   string   `pulumi:"name"`
	Values []string `pulumi:"values"`
}

type GetOpenZfsSnapshotFilterArgs struct {
	// Name of the snapshot.
	Name   pulumix.Input[string]   `pulumi:"name"`
	Values pulumix.Input[[]string] `pulumi:"values"`
}

func (GetOpenZfsSnapshotFilterArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetOpenZfsSnapshotFilter)(nil)).Elem()
}

func (i GetOpenZfsSnapshotFilterArgs) ToGetOpenZfsSnapshotFilterOutput() GetOpenZfsSnapshotFilterOutput {
	return i.ToGetOpenZfsSnapshotFilterOutputWithContext(context.Background())
}

func (i GetOpenZfsSnapshotFilterArgs) ToGetOpenZfsSnapshotFilterOutputWithContext(ctx context.Context) GetOpenZfsSnapshotFilterOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetOpenZfsSnapshotFilterOutput)
}

func (i *GetOpenZfsSnapshotFilterArgs) ToOutput(ctx context.Context) pulumix.Output[*GetOpenZfsSnapshotFilterArgs] {
	return pulumix.Val(i)
}

type GetOpenZfsSnapshotFilterOutput struct{ *pulumi.OutputState }

func (GetOpenZfsSnapshotFilterOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetOpenZfsSnapshotFilter)(nil)).Elem()
}

func (o GetOpenZfsSnapshotFilterOutput) ToGetOpenZfsSnapshotFilterOutput() GetOpenZfsSnapshotFilterOutput {
	return o
}

func (o GetOpenZfsSnapshotFilterOutput) ToGetOpenZfsSnapshotFilterOutputWithContext(ctx context.Context) GetOpenZfsSnapshotFilterOutput {
	return o
}

func (o GetOpenZfsSnapshotFilterOutput) ToOutput(ctx context.Context) pulumix.Output[GetOpenZfsSnapshotFilter] {
	return pulumix.Output[GetOpenZfsSnapshotFilter]{
		OutputState: o.OutputState,
	}
}

// Name of the snapshot.
func (o GetOpenZfsSnapshotFilterOutput) Name() pulumix.Output[string] {
	return pulumix.Apply[GetOpenZfsSnapshotFilter](o, func(v GetOpenZfsSnapshotFilter) string { return v.Name })
}

func (o GetOpenZfsSnapshotFilterOutput) Values() pulumix.ArrayOutput[string] {
	value := pulumix.Apply[GetOpenZfsSnapshotFilter](o, func(v GetOpenZfsSnapshotFilter) []string { return v.Values })
	return pulumix.ArrayOutput[string]{OutputState: value.OutputState}
}

type GetWindowsFileSystemAuditLogConfiguration struct {
	AuditLogDestination          string `pulumi:"auditLogDestination"`
	FileAccessAuditLogLevel      string `pulumi:"fileAccessAuditLogLevel"`
	FileShareAccessAuditLogLevel string `pulumi:"fileShareAccessAuditLogLevel"`
}

type GetWindowsFileSystemAuditLogConfigurationArgs struct {
	AuditLogDestination          pulumix.Input[string] `pulumi:"auditLogDestination"`
	FileAccessAuditLogLevel      pulumix.Input[string] `pulumi:"fileAccessAuditLogLevel"`
	FileShareAccessAuditLogLevel pulumix.Input[string] `pulumi:"fileShareAccessAuditLogLevel"`
}

func (GetWindowsFileSystemAuditLogConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetWindowsFileSystemAuditLogConfiguration)(nil)).Elem()
}

func (i GetWindowsFileSystemAuditLogConfigurationArgs) ToGetWindowsFileSystemAuditLogConfigurationOutput() GetWindowsFileSystemAuditLogConfigurationOutput {
	return i.ToGetWindowsFileSystemAuditLogConfigurationOutputWithContext(context.Background())
}

func (i GetWindowsFileSystemAuditLogConfigurationArgs) ToGetWindowsFileSystemAuditLogConfigurationOutputWithContext(ctx context.Context) GetWindowsFileSystemAuditLogConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetWindowsFileSystemAuditLogConfigurationOutput)
}

func (i *GetWindowsFileSystemAuditLogConfigurationArgs) ToOutput(ctx context.Context) pulumix.Output[*GetWindowsFileSystemAuditLogConfigurationArgs] {
	return pulumix.Val(i)
}

type GetWindowsFileSystemAuditLogConfigurationOutput struct{ *pulumi.OutputState }

func (GetWindowsFileSystemAuditLogConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetWindowsFileSystemAuditLogConfiguration)(nil)).Elem()
}

func (o GetWindowsFileSystemAuditLogConfigurationOutput) ToGetWindowsFileSystemAuditLogConfigurationOutput() GetWindowsFileSystemAuditLogConfigurationOutput {
	return o
}

func (o GetWindowsFileSystemAuditLogConfigurationOutput) ToGetWindowsFileSystemAuditLogConfigurationOutputWithContext(ctx context.Context) GetWindowsFileSystemAuditLogConfigurationOutput {
	return o
}

func (o GetWindowsFileSystemAuditLogConfigurationOutput) ToOutput(ctx context.Context) pulumix.Output[GetWindowsFileSystemAuditLogConfiguration] {
	return pulumix.Output[GetWindowsFileSystemAuditLogConfiguration]{
		OutputState: o.OutputState,
	}
}

func (o GetWindowsFileSystemAuditLogConfigurationOutput) AuditLogDestination() pulumix.Output[string] {
	return pulumix.Apply[GetWindowsFileSystemAuditLogConfiguration](o, func(v GetWindowsFileSystemAuditLogConfiguration) string { return v.AuditLogDestination })
}

func (o GetWindowsFileSystemAuditLogConfigurationOutput) FileAccessAuditLogLevel() pulumix.Output[string] {
	return pulumix.Apply[GetWindowsFileSystemAuditLogConfiguration](o, func(v GetWindowsFileSystemAuditLogConfiguration) string { return v.FileAccessAuditLogLevel })
}

func (o GetWindowsFileSystemAuditLogConfigurationOutput) FileShareAccessAuditLogLevel() pulumix.Output[string] {
	return pulumix.Apply[GetWindowsFileSystemAuditLogConfiguration](o, func(v GetWindowsFileSystemAuditLogConfiguration) string { return v.FileShareAccessAuditLogLevel })
}

func init() {
	pulumi.RegisterOutputType(DataRepositoryAssociationS3Output{})
	pulumi.RegisterOutputType(DataRepositoryAssociationS3AutoExportPolicyOutput{})
	pulumi.RegisterOutputType(DataRepositoryAssociationS3AutoImportPolicyOutput{})
	pulumi.RegisterOutputType(FileCacheDataRepositoryAssociationOutput{})
	pulumi.RegisterOutputType(FileCacheDataRepositoryAssociationNfOutput{})
	pulumi.RegisterOutputType(FileCacheLustreConfigurationOutput{})
	pulumi.RegisterOutputType(FileCacheLustreConfigurationLogConfigurationOutput{})
	pulumi.RegisterOutputType(FileCacheLustreConfigurationMetadataConfigurationOutput{})
	pulumi.RegisterOutputType(LustreFileSystemLogConfigurationOutput{})
	pulumi.RegisterOutputType(LustreFileSystemRootSquashConfigurationOutput{})
	pulumi.RegisterOutputType(OntapFileSystemDiskIopsConfigurationOutput{})
	pulumi.RegisterOutputType(OntapFileSystemEndpointOutput{})
	pulumi.RegisterOutputType(OntapFileSystemEndpointInterclusterOutput{})
	pulumi.RegisterOutputType(OntapFileSystemEndpointManagementOutput{})
	pulumi.RegisterOutputType(OntapStorageVirtualMachineActiveDirectoryConfigurationOutput{})
	pulumi.RegisterOutputType(OntapStorageVirtualMachineActiveDirectoryConfigurationSelfManagedActiveDirectoryConfigurationOutput{})
	pulumi.RegisterOutputType(OntapStorageVirtualMachineEndpointOutput{})
	pulumi.RegisterOutputType(OntapStorageVirtualMachineEndpointIscsiOutput{})
	pulumi.RegisterOutputType(OntapStorageVirtualMachineEndpointManagementOutput{})
	pulumi.RegisterOutputType(OntapStorageVirtualMachineEndpointNfOutput{})
	pulumi.RegisterOutputType(OntapStorageVirtualMachineEndpointSmbOutput{})
	pulumi.RegisterOutputType(OntapVolumeTieringPolicyOutput{})
	pulumi.RegisterOutputType(OpenZfsFileSystemDiskIopsConfigurationOutput{})
	pulumi.RegisterOutputType(OpenZfsFileSystemRootVolumeConfigurationOutput{})
	pulumi.RegisterOutputType(OpenZfsFileSystemRootVolumeConfigurationNfsExportsOutput{})
	pulumi.RegisterOutputType(OpenZfsFileSystemRootVolumeConfigurationNfsExportsClientConfigurationOutput{})
	pulumi.RegisterOutputType(OpenZfsFileSystemRootVolumeConfigurationUserAndGroupQuotaOutput{})
	pulumi.RegisterOutputType(OpenZfsVolumeNfsExportsOutput{})
	pulumi.RegisterOutputType(OpenZfsVolumeNfsExportsClientConfigurationOutput{})
	pulumi.RegisterOutputType(OpenZfsVolumeOriginSnapshotOutput{})
	pulumi.RegisterOutputType(OpenZfsVolumeUserAndGroupQuotaOutput{})
	pulumi.RegisterOutputType(WindowsFileSystemAuditLogConfigurationOutput{})
	pulumi.RegisterOutputType(WindowsFileSystemSelfManagedActiveDirectoryOutput{})
	pulumi.RegisterOutputType(GetOpenZfsSnapshotFilterOutput{})
	pulumi.RegisterOutputType(GetWindowsFileSystemAuditLogConfigurationOutput{})
}
