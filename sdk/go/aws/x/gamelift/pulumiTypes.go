// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package gamelift

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi-aws/sdk/v6/go/aws/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumix"
)

var _ = internal.GetEnvOrDefault

type AliasRoutingStrategy struct {
	// ID of the GameLift Fleet to point the alias to.
	FleetId *string `pulumi:"fleetId"`
	// Message text to be used with the `TERMINAL` routing strategy.
	Message *string `pulumi:"message"`
	// Type of routing strategyE.g., `SIMPLE` or `TERMINAL`
	Type string `pulumi:"type"`
}

type AliasRoutingStrategyArgs struct {
	// ID of the GameLift Fleet to point the alias to.
	FleetId pulumix.Input[*string] `pulumi:"fleetId"`
	// Message text to be used with the `TERMINAL` routing strategy.
	Message pulumix.Input[*string] `pulumi:"message"`
	// Type of routing strategyE.g., `SIMPLE` or `TERMINAL`
	Type pulumix.Input[string] `pulumi:"type"`
}

func (AliasRoutingStrategyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AliasRoutingStrategy)(nil)).Elem()
}

func (i AliasRoutingStrategyArgs) ToAliasRoutingStrategyOutput() AliasRoutingStrategyOutput {
	return i.ToAliasRoutingStrategyOutputWithContext(context.Background())
}

func (i AliasRoutingStrategyArgs) ToAliasRoutingStrategyOutputWithContext(ctx context.Context) AliasRoutingStrategyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AliasRoutingStrategyOutput)
}

func (i *AliasRoutingStrategyArgs) ToOutput(ctx context.Context) pulumix.Output[*AliasRoutingStrategyArgs] {
	return pulumix.Val(i)
}

type AliasRoutingStrategyOutput struct{ *pulumi.OutputState }

func (AliasRoutingStrategyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AliasRoutingStrategy)(nil)).Elem()
}

func (o AliasRoutingStrategyOutput) ToAliasRoutingStrategyOutput() AliasRoutingStrategyOutput {
	return o
}

func (o AliasRoutingStrategyOutput) ToAliasRoutingStrategyOutputWithContext(ctx context.Context) AliasRoutingStrategyOutput {
	return o
}

func (o AliasRoutingStrategyOutput) ToOutput(ctx context.Context) pulumix.Output[AliasRoutingStrategy] {
	return pulumix.Output[AliasRoutingStrategy]{
		OutputState: o.OutputState,
	}
}

// ID of the GameLift Fleet to point the alias to.
func (o AliasRoutingStrategyOutput) FleetId() pulumix.Output[*string] {
	return pulumix.Apply[AliasRoutingStrategy](o, func(v AliasRoutingStrategy) *string { return v.FleetId })
}

// Message text to be used with the `TERMINAL` routing strategy.
func (o AliasRoutingStrategyOutput) Message() pulumix.Output[*string] {
	return pulumix.Apply[AliasRoutingStrategy](o, func(v AliasRoutingStrategy) *string { return v.Message })
}

// Type of routing strategyE.g., `SIMPLE` or `TERMINAL`
func (o AliasRoutingStrategyOutput) Type() pulumix.Output[string] {
	return pulumix.Apply[AliasRoutingStrategy](o, func(v AliasRoutingStrategy) string { return v.Type })
}

type BuildStorageLocation struct {
	// Name of your S3 bucket.
	Bucket string `pulumi:"bucket"`
	// Name of the zip file containing your build files.
	Key string `pulumi:"key"`
	// A specific version of the file. If not set, the latest version of the file is retrieved.
	ObjectVersion *string `pulumi:"objectVersion"`
	// ARN of the access role that allows Amazon GameLift to access your S3 bucket.
	RoleArn string `pulumi:"roleArn"`
}

type BuildStorageLocationArgs struct {
	// Name of your S3 bucket.
	Bucket pulumix.Input[string] `pulumi:"bucket"`
	// Name of the zip file containing your build files.
	Key pulumix.Input[string] `pulumi:"key"`
	// A specific version of the file. If not set, the latest version of the file is retrieved.
	ObjectVersion pulumix.Input[*string] `pulumi:"objectVersion"`
	// ARN of the access role that allows Amazon GameLift to access your S3 bucket.
	RoleArn pulumix.Input[string] `pulumi:"roleArn"`
}

func (BuildStorageLocationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*BuildStorageLocation)(nil)).Elem()
}

func (i BuildStorageLocationArgs) ToBuildStorageLocationOutput() BuildStorageLocationOutput {
	return i.ToBuildStorageLocationOutputWithContext(context.Background())
}

func (i BuildStorageLocationArgs) ToBuildStorageLocationOutputWithContext(ctx context.Context) BuildStorageLocationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BuildStorageLocationOutput)
}

func (i *BuildStorageLocationArgs) ToOutput(ctx context.Context) pulumix.Output[*BuildStorageLocationArgs] {
	return pulumix.Val(i)
}

type BuildStorageLocationOutput struct{ *pulumi.OutputState }

func (BuildStorageLocationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BuildStorageLocation)(nil)).Elem()
}

func (o BuildStorageLocationOutput) ToBuildStorageLocationOutput() BuildStorageLocationOutput {
	return o
}

func (o BuildStorageLocationOutput) ToBuildStorageLocationOutputWithContext(ctx context.Context) BuildStorageLocationOutput {
	return o
}

func (o BuildStorageLocationOutput) ToOutput(ctx context.Context) pulumix.Output[BuildStorageLocation] {
	return pulumix.Output[BuildStorageLocation]{
		OutputState: o.OutputState,
	}
}

// Name of your S3 bucket.
func (o BuildStorageLocationOutput) Bucket() pulumix.Output[string] {
	return pulumix.Apply[BuildStorageLocation](o, func(v BuildStorageLocation) string { return v.Bucket })
}

// Name of the zip file containing your build files.
func (o BuildStorageLocationOutput) Key() pulumix.Output[string] {
	return pulumix.Apply[BuildStorageLocation](o, func(v BuildStorageLocation) string { return v.Key })
}

// A specific version of the file. If not set, the latest version of the file is retrieved.
func (o BuildStorageLocationOutput) ObjectVersion() pulumix.Output[*string] {
	return pulumix.Apply[BuildStorageLocation](o, func(v BuildStorageLocation) *string { return v.ObjectVersion })
}

// ARN of the access role that allows Amazon GameLift to access your S3 bucket.
func (o BuildStorageLocationOutput) RoleArn() pulumix.Output[string] {
	return pulumix.Apply[BuildStorageLocation](o, func(v BuildStorageLocation) string { return v.RoleArn })
}

type FleetCertificateConfiguration struct {
	// Indicates whether a TLS/SSL certificate is generated for a fleet. Valid values are `DISABLED` and `GENERATED`. Default value is `DISABLED`.
	CertificateType *string `pulumi:"certificateType"`
}

type FleetCertificateConfigurationArgs struct {
	// Indicates whether a TLS/SSL certificate is generated for a fleet. Valid values are `DISABLED` and `GENERATED`. Default value is `DISABLED`.
	CertificateType pulumix.Input[*string] `pulumi:"certificateType"`
}

func (FleetCertificateConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetCertificateConfiguration)(nil)).Elem()
}

func (i FleetCertificateConfigurationArgs) ToFleetCertificateConfigurationOutput() FleetCertificateConfigurationOutput {
	return i.ToFleetCertificateConfigurationOutputWithContext(context.Background())
}

func (i FleetCertificateConfigurationArgs) ToFleetCertificateConfigurationOutputWithContext(ctx context.Context) FleetCertificateConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetCertificateConfigurationOutput)
}

func (i *FleetCertificateConfigurationArgs) ToOutput(ctx context.Context) pulumix.Output[*FleetCertificateConfigurationArgs] {
	return pulumix.Val(i)
}

type FleetCertificateConfigurationOutput struct{ *pulumi.OutputState }

func (FleetCertificateConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetCertificateConfiguration)(nil)).Elem()
}

func (o FleetCertificateConfigurationOutput) ToFleetCertificateConfigurationOutput() FleetCertificateConfigurationOutput {
	return o
}

func (o FleetCertificateConfigurationOutput) ToFleetCertificateConfigurationOutputWithContext(ctx context.Context) FleetCertificateConfigurationOutput {
	return o
}

func (o FleetCertificateConfigurationOutput) ToOutput(ctx context.Context) pulumix.Output[FleetCertificateConfiguration] {
	return pulumix.Output[FleetCertificateConfiguration]{
		OutputState: o.OutputState,
	}
}

// Indicates whether a TLS/SSL certificate is generated for a fleet. Valid values are `DISABLED` and `GENERATED`. Default value is `DISABLED`.
func (o FleetCertificateConfigurationOutput) CertificateType() pulumix.Output[*string] {
	return pulumix.Apply[FleetCertificateConfiguration](o, func(v FleetCertificateConfiguration) *string { return v.CertificateType })
}

type FleetEc2InboundPermission struct {
	// Starting value for a range of allowed port numbers.
	FromPort int `pulumi:"fromPort"`
	// Range of allowed IP addresses expressed in CIDR notationE.g., `000.000.000.000/[subnet mask]` or `0.0.0.0/[subnet mask]`.
	IpRange string `pulumi:"ipRange"`
	// Network communication protocol used by the fleetE.g., `TCP` or `UDP`
	Protocol string `pulumi:"protocol"`
	// Ending value for a range of allowed port numbers. Port numbers are end-inclusive. This value must be higher than `fromPort`.
	ToPort int `pulumi:"toPort"`
}

type FleetEc2InboundPermissionArgs struct {
	// Starting value for a range of allowed port numbers.
	FromPort pulumix.Input[int] `pulumi:"fromPort"`
	// Range of allowed IP addresses expressed in CIDR notationE.g., `000.000.000.000/[subnet mask]` or `0.0.0.0/[subnet mask]`.
	IpRange pulumix.Input[string] `pulumi:"ipRange"`
	// Network communication protocol used by the fleetE.g., `TCP` or `UDP`
	Protocol pulumix.Input[string] `pulumi:"protocol"`
	// Ending value for a range of allowed port numbers. Port numbers are end-inclusive. This value must be higher than `fromPort`.
	ToPort pulumix.Input[int] `pulumi:"toPort"`
}

func (FleetEc2InboundPermissionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetEc2InboundPermission)(nil)).Elem()
}

func (i FleetEc2InboundPermissionArgs) ToFleetEc2InboundPermissionOutput() FleetEc2InboundPermissionOutput {
	return i.ToFleetEc2InboundPermissionOutputWithContext(context.Background())
}

func (i FleetEc2InboundPermissionArgs) ToFleetEc2InboundPermissionOutputWithContext(ctx context.Context) FleetEc2InboundPermissionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetEc2InboundPermissionOutput)
}

func (i *FleetEc2InboundPermissionArgs) ToOutput(ctx context.Context) pulumix.Output[*FleetEc2InboundPermissionArgs] {
	return pulumix.Val(i)
}

type FleetEc2InboundPermissionOutput struct{ *pulumi.OutputState }

func (FleetEc2InboundPermissionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetEc2InboundPermission)(nil)).Elem()
}

func (o FleetEc2InboundPermissionOutput) ToFleetEc2InboundPermissionOutput() FleetEc2InboundPermissionOutput {
	return o
}

func (o FleetEc2InboundPermissionOutput) ToFleetEc2InboundPermissionOutputWithContext(ctx context.Context) FleetEc2InboundPermissionOutput {
	return o
}

func (o FleetEc2InboundPermissionOutput) ToOutput(ctx context.Context) pulumix.Output[FleetEc2InboundPermission] {
	return pulumix.Output[FleetEc2InboundPermission]{
		OutputState: o.OutputState,
	}
}

// Starting value for a range of allowed port numbers.
func (o FleetEc2InboundPermissionOutput) FromPort() pulumix.Output[int] {
	return pulumix.Apply[FleetEc2InboundPermission](o, func(v FleetEc2InboundPermission) int { return v.FromPort })
}

// Range of allowed IP addresses expressed in CIDR notationE.g., `000.000.000.000/[subnet mask]` or `0.0.0.0/[subnet mask]`.
func (o FleetEc2InboundPermissionOutput) IpRange() pulumix.Output[string] {
	return pulumix.Apply[FleetEc2InboundPermission](o, func(v FleetEc2InboundPermission) string { return v.IpRange })
}

// Network communication protocol used by the fleetE.g., `TCP` or `UDP`
func (o FleetEc2InboundPermissionOutput) Protocol() pulumix.Output[string] {
	return pulumix.Apply[FleetEc2InboundPermission](o, func(v FleetEc2InboundPermission) string { return v.Protocol })
}

// Ending value for a range of allowed port numbers. Port numbers are end-inclusive. This value must be higher than `fromPort`.
func (o FleetEc2InboundPermissionOutput) ToPort() pulumix.Output[int] {
	return pulumix.Apply[FleetEc2InboundPermission](o, func(v FleetEc2InboundPermission) int { return v.ToPort })
}

type FleetResourceCreationLimitPolicy struct {
	// Maximum number of game sessions that an individual can create during the policy period.
	NewGameSessionsPerCreator *int `pulumi:"newGameSessionsPerCreator"`
	// Time span used in evaluating the resource creation limit policy.
	PolicyPeriodInMinutes *int `pulumi:"policyPeriodInMinutes"`
}

type FleetResourceCreationLimitPolicyArgs struct {
	// Maximum number of game sessions that an individual can create during the policy period.
	NewGameSessionsPerCreator pulumix.Input[*int] `pulumi:"newGameSessionsPerCreator"`
	// Time span used in evaluating the resource creation limit policy.
	PolicyPeriodInMinutes pulumix.Input[*int] `pulumi:"policyPeriodInMinutes"`
}

func (FleetResourceCreationLimitPolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetResourceCreationLimitPolicy)(nil)).Elem()
}

func (i FleetResourceCreationLimitPolicyArgs) ToFleetResourceCreationLimitPolicyOutput() FleetResourceCreationLimitPolicyOutput {
	return i.ToFleetResourceCreationLimitPolicyOutputWithContext(context.Background())
}

func (i FleetResourceCreationLimitPolicyArgs) ToFleetResourceCreationLimitPolicyOutputWithContext(ctx context.Context) FleetResourceCreationLimitPolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetResourceCreationLimitPolicyOutput)
}

func (i *FleetResourceCreationLimitPolicyArgs) ToOutput(ctx context.Context) pulumix.Output[*FleetResourceCreationLimitPolicyArgs] {
	return pulumix.Val(i)
}

type FleetResourceCreationLimitPolicyOutput struct{ *pulumi.OutputState }

func (FleetResourceCreationLimitPolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetResourceCreationLimitPolicy)(nil)).Elem()
}

func (o FleetResourceCreationLimitPolicyOutput) ToFleetResourceCreationLimitPolicyOutput() FleetResourceCreationLimitPolicyOutput {
	return o
}

func (o FleetResourceCreationLimitPolicyOutput) ToFleetResourceCreationLimitPolicyOutputWithContext(ctx context.Context) FleetResourceCreationLimitPolicyOutput {
	return o
}

func (o FleetResourceCreationLimitPolicyOutput) ToOutput(ctx context.Context) pulumix.Output[FleetResourceCreationLimitPolicy] {
	return pulumix.Output[FleetResourceCreationLimitPolicy]{
		OutputState: o.OutputState,
	}
}

// Maximum number of game sessions that an individual can create during the policy period.
func (o FleetResourceCreationLimitPolicyOutput) NewGameSessionsPerCreator() pulumix.Output[*int] {
	return pulumix.Apply[FleetResourceCreationLimitPolicy](o, func(v FleetResourceCreationLimitPolicy) *int { return v.NewGameSessionsPerCreator })
}

// Time span used in evaluating the resource creation limit policy.
func (o FleetResourceCreationLimitPolicyOutput) PolicyPeriodInMinutes() pulumix.Output[*int] {
	return pulumix.Apply[FleetResourceCreationLimitPolicy](o, func(v FleetResourceCreationLimitPolicy) *int { return v.PolicyPeriodInMinutes })
}

type FleetRuntimeConfiguration struct {
	// Maximum amount of time (in seconds) that a game session can remain in status `ACTIVATING`.
	GameSessionActivationTimeoutSeconds *int `pulumi:"gameSessionActivationTimeoutSeconds"`
	// Maximum number of game sessions with status `ACTIVATING` to allow on an instance simultaneously.
	MaxConcurrentGameSessionActivations *int `pulumi:"maxConcurrentGameSessionActivations"`
	// Collection of server process configurations that describe which server processes to run on each instance in a fleet. See below.
	ServerProcesses []FleetRuntimeConfigurationServerProcess `pulumi:"serverProcesses"`
}

type FleetRuntimeConfigurationArgs struct {
	// Maximum amount of time (in seconds) that a game session can remain in status `ACTIVATING`.
	GameSessionActivationTimeoutSeconds pulumix.Input[*int] `pulumi:"gameSessionActivationTimeoutSeconds"`
	// Maximum number of game sessions with status `ACTIVATING` to allow on an instance simultaneously.
	MaxConcurrentGameSessionActivations pulumix.Input[*int] `pulumi:"maxConcurrentGameSessionActivations"`
	// Collection of server process configurations that describe which server processes to run on each instance in a fleet. See below.
	ServerProcesses pulumix.Input[[]*FleetRuntimeConfigurationServerProcessArgs] `pulumi:"serverProcesses"`
}

func (FleetRuntimeConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetRuntimeConfiguration)(nil)).Elem()
}

func (i FleetRuntimeConfigurationArgs) ToFleetRuntimeConfigurationOutput() FleetRuntimeConfigurationOutput {
	return i.ToFleetRuntimeConfigurationOutputWithContext(context.Background())
}

func (i FleetRuntimeConfigurationArgs) ToFleetRuntimeConfigurationOutputWithContext(ctx context.Context) FleetRuntimeConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetRuntimeConfigurationOutput)
}

func (i *FleetRuntimeConfigurationArgs) ToOutput(ctx context.Context) pulumix.Output[*FleetRuntimeConfigurationArgs] {
	return pulumix.Val(i)
}

type FleetRuntimeConfigurationOutput struct{ *pulumi.OutputState }

func (FleetRuntimeConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetRuntimeConfiguration)(nil)).Elem()
}

func (o FleetRuntimeConfigurationOutput) ToFleetRuntimeConfigurationOutput() FleetRuntimeConfigurationOutput {
	return o
}

func (o FleetRuntimeConfigurationOutput) ToFleetRuntimeConfigurationOutputWithContext(ctx context.Context) FleetRuntimeConfigurationOutput {
	return o
}

func (o FleetRuntimeConfigurationOutput) ToOutput(ctx context.Context) pulumix.Output[FleetRuntimeConfiguration] {
	return pulumix.Output[FleetRuntimeConfiguration]{
		OutputState: o.OutputState,
	}
}

// Maximum amount of time (in seconds) that a game session can remain in status `ACTIVATING`.
func (o FleetRuntimeConfigurationOutput) GameSessionActivationTimeoutSeconds() pulumix.Output[*int] {
	return pulumix.Apply[FleetRuntimeConfiguration](o, func(v FleetRuntimeConfiguration) *int { return v.GameSessionActivationTimeoutSeconds })
}

// Maximum number of game sessions with status `ACTIVATING` to allow on an instance simultaneously.
func (o FleetRuntimeConfigurationOutput) MaxConcurrentGameSessionActivations() pulumix.Output[*int] {
	return pulumix.Apply[FleetRuntimeConfiguration](o, func(v FleetRuntimeConfiguration) *int { return v.MaxConcurrentGameSessionActivations })
}

// Collection of server process configurations that describe which server processes to run on each instance in a fleet. See below.
func (o FleetRuntimeConfigurationOutput) ServerProcesses() pulumix.GArrayOutput[FleetRuntimeConfigurationServerProcess, FleetRuntimeConfigurationServerProcessOutput] {
	value := pulumix.Apply[FleetRuntimeConfiguration](o, func(v FleetRuntimeConfiguration) []FleetRuntimeConfigurationServerProcess { return v.ServerProcesses })
	return pulumix.GArrayOutput[FleetRuntimeConfigurationServerProcess, FleetRuntimeConfigurationServerProcessOutput]{OutputState: value.OutputState}
}

type FleetRuntimeConfigurationServerProcess struct {
	// Number of server processes using this configuration to run concurrently on an instance.
	ConcurrentExecutions int `pulumi:"concurrentExecutions"`
	// Location of the server executable in a game build. All game builds are installed on instances at the root : for Windows instances `C:\game`, and for Linux instances `/local/game`.
	LaunchPath string `pulumi:"launchPath"`
	// Optional list of parameters to pass to the server executable on launch.
	Parameters *string `pulumi:"parameters"`
}

type FleetRuntimeConfigurationServerProcessArgs struct {
	// Number of server processes using this configuration to run concurrently on an instance.
	ConcurrentExecutions pulumix.Input[int] `pulumi:"concurrentExecutions"`
	// Location of the server executable in a game build. All game builds are installed on instances at the root : for Windows instances `C:\game`, and for Linux instances `/local/game`.
	LaunchPath pulumix.Input[string] `pulumi:"launchPath"`
	// Optional list of parameters to pass to the server executable on launch.
	Parameters pulumix.Input[*string] `pulumi:"parameters"`
}

func (FleetRuntimeConfigurationServerProcessArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetRuntimeConfigurationServerProcess)(nil)).Elem()
}

func (i FleetRuntimeConfigurationServerProcessArgs) ToFleetRuntimeConfigurationServerProcessOutput() FleetRuntimeConfigurationServerProcessOutput {
	return i.ToFleetRuntimeConfigurationServerProcessOutputWithContext(context.Background())
}

func (i FleetRuntimeConfigurationServerProcessArgs) ToFleetRuntimeConfigurationServerProcessOutputWithContext(ctx context.Context) FleetRuntimeConfigurationServerProcessOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetRuntimeConfigurationServerProcessOutput)
}

func (i *FleetRuntimeConfigurationServerProcessArgs) ToOutput(ctx context.Context) pulumix.Output[*FleetRuntimeConfigurationServerProcessArgs] {
	return pulumix.Val(i)
}

type FleetRuntimeConfigurationServerProcessOutput struct{ *pulumi.OutputState }

func (FleetRuntimeConfigurationServerProcessOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetRuntimeConfigurationServerProcess)(nil)).Elem()
}

func (o FleetRuntimeConfigurationServerProcessOutput) ToFleetRuntimeConfigurationServerProcessOutput() FleetRuntimeConfigurationServerProcessOutput {
	return o
}

func (o FleetRuntimeConfigurationServerProcessOutput) ToFleetRuntimeConfigurationServerProcessOutputWithContext(ctx context.Context) FleetRuntimeConfigurationServerProcessOutput {
	return o
}

func (o FleetRuntimeConfigurationServerProcessOutput) ToOutput(ctx context.Context) pulumix.Output[FleetRuntimeConfigurationServerProcess] {
	return pulumix.Output[FleetRuntimeConfigurationServerProcess]{
		OutputState: o.OutputState,
	}
}

// Number of server processes using this configuration to run concurrently on an instance.
func (o FleetRuntimeConfigurationServerProcessOutput) ConcurrentExecutions() pulumix.Output[int] {
	return pulumix.Apply[FleetRuntimeConfigurationServerProcess](o, func(v FleetRuntimeConfigurationServerProcess) int { return v.ConcurrentExecutions })
}

// Location of the server executable in a game build. All game builds are installed on instances at the root : for Windows instances `C:\game`, and for Linux instances `/local/game`.
func (o FleetRuntimeConfigurationServerProcessOutput) LaunchPath() pulumix.Output[string] {
	return pulumix.Apply[FleetRuntimeConfigurationServerProcess](o, func(v FleetRuntimeConfigurationServerProcess) string { return v.LaunchPath })
}

// Optional list of parameters to pass to the server executable on launch.
func (o FleetRuntimeConfigurationServerProcessOutput) Parameters() pulumix.Output[*string] {
	return pulumix.Apply[FleetRuntimeConfigurationServerProcess](o, func(v FleetRuntimeConfigurationServerProcess) *string { return v.Parameters })
}

type GameServerGroupAutoScalingPolicy struct {
	// Length of time, in seconds, it takes for a new instance to start
	// new game server processes and register with GameLift FleetIQ.
	// Specifying a warm-up time can be useful, particularly with game servers that take a long time to start up,
	// because it avoids prematurely starting new instances. Defaults to `60`.
	EstimatedInstanceWarmup     *int                                                        `pulumi:"estimatedInstanceWarmup"`
	TargetTrackingConfiguration GameServerGroupAutoScalingPolicyTargetTrackingConfiguration `pulumi:"targetTrackingConfiguration"`
}

type GameServerGroupAutoScalingPolicyArgs struct {
	// Length of time, in seconds, it takes for a new instance to start
	// new game server processes and register with GameLift FleetIQ.
	// Specifying a warm-up time can be useful, particularly with game servers that take a long time to start up,
	// because it avoids prematurely starting new instances. Defaults to `60`.
	EstimatedInstanceWarmup     pulumix.Input[*int]                                                             `pulumi:"estimatedInstanceWarmup"`
	TargetTrackingConfiguration pulumix.Input[*GameServerGroupAutoScalingPolicyTargetTrackingConfigurationArgs] `pulumi:"targetTrackingConfiguration"`
}

func (GameServerGroupAutoScalingPolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GameServerGroupAutoScalingPolicy)(nil)).Elem()
}

func (i GameServerGroupAutoScalingPolicyArgs) ToGameServerGroupAutoScalingPolicyOutput() GameServerGroupAutoScalingPolicyOutput {
	return i.ToGameServerGroupAutoScalingPolicyOutputWithContext(context.Background())
}

func (i GameServerGroupAutoScalingPolicyArgs) ToGameServerGroupAutoScalingPolicyOutputWithContext(ctx context.Context) GameServerGroupAutoScalingPolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameServerGroupAutoScalingPolicyOutput)
}

func (i *GameServerGroupAutoScalingPolicyArgs) ToOutput(ctx context.Context) pulumix.Output[*GameServerGroupAutoScalingPolicyArgs] {
	return pulumix.Val(i)
}

type GameServerGroupAutoScalingPolicyOutput struct{ *pulumi.OutputState }

func (GameServerGroupAutoScalingPolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GameServerGroupAutoScalingPolicy)(nil)).Elem()
}

func (o GameServerGroupAutoScalingPolicyOutput) ToGameServerGroupAutoScalingPolicyOutput() GameServerGroupAutoScalingPolicyOutput {
	return o
}

func (o GameServerGroupAutoScalingPolicyOutput) ToGameServerGroupAutoScalingPolicyOutputWithContext(ctx context.Context) GameServerGroupAutoScalingPolicyOutput {
	return o
}

func (o GameServerGroupAutoScalingPolicyOutput) ToOutput(ctx context.Context) pulumix.Output[GameServerGroupAutoScalingPolicy] {
	return pulumix.Output[GameServerGroupAutoScalingPolicy]{
		OutputState: o.OutputState,
	}
}

// Length of time, in seconds, it takes for a new instance to start
// new game server processes and register with GameLift FleetIQ.
// Specifying a warm-up time can be useful, particularly with game servers that take a long time to start up,
// because it avoids prematurely starting new instances. Defaults to `60`.
func (o GameServerGroupAutoScalingPolicyOutput) EstimatedInstanceWarmup() pulumix.Output[*int] {
	return pulumix.Apply[GameServerGroupAutoScalingPolicy](o, func(v GameServerGroupAutoScalingPolicy) *int { return v.EstimatedInstanceWarmup })
}

func (o GameServerGroupAutoScalingPolicyOutput) TargetTrackingConfiguration() pulumix.GPtrOutput[GameServerGroupAutoScalingPolicyTargetTrackingConfiguration, GameServerGroupAutoScalingPolicyTargetTrackingConfigurationOutput] {
	value := pulumix.Apply[GameServerGroupAutoScalingPolicy](o, func(v GameServerGroupAutoScalingPolicy) GameServerGroupAutoScalingPolicyTargetTrackingConfiguration {
		return v.TargetTrackingConfiguration
	})
	return pulumix.GPtrOutput[GameServerGroupAutoScalingPolicyTargetTrackingConfiguration, GameServerGroupAutoScalingPolicyTargetTrackingConfigurationOutput]{OutputState: value.OutputState}
}

type GameServerGroupAutoScalingPolicyTargetTrackingConfiguration struct {
	// Desired value to use with a game server group target-based scaling policy.
	TargetValue float64 `pulumi:"targetValue"`
}

type GameServerGroupAutoScalingPolicyTargetTrackingConfigurationArgs struct {
	// Desired value to use with a game server group target-based scaling policy.
	TargetValue pulumix.Input[float64] `pulumi:"targetValue"`
}

func (GameServerGroupAutoScalingPolicyTargetTrackingConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GameServerGroupAutoScalingPolicyTargetTrackingConfiguration)(nil)).Elem()
}

func (i GameServerGroupAutoScalingPolicyTargetTrackingConfigurationArgs) ToGameServerGroupAutoScalingPolicyTargetTrackingConfigurationOutput() GameServerGroupAutoScalingPolicyTargetTrackingConfigurationOutput {
	return i.ToGameServerGroupAutoScalingPolicyTargetTrackingConfigurationOutputWithContext(context.Background())
}

func (i GameServerGroupAutoScalingPolicyTargetTrackingConfigurationArgs) ToGameServerGroupAutoScalingPolicyTargetTrackingConfigurationOutputWithContext(ctx context.Context) GameServerGroupAutoScalingPolicyTargetTrackingConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameServerGroupAutoScalingPolicyTargetTrackingConfigurationOutput)
}

func (i *GameServerGroupAutoScalingPolicyTargetTrackingConfigurationArgs) ToOutput(ctx context.Context) pulumix.Output[*GameServerGroupAutoScalingPolicyTargetTrackingConfigurationArgs] {
	return pulumix.Val(i)
}

type GameServerGroupAutoScalingPolicyTargetTrackingConfigurationOutput struct{ *pulumi.OutputState }

func (GameServerGroupAutoScalingPolicyTargetTrackingConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GameServerGroupAutoScalingPolicyTargetTrackingConfiguration)(nil)).Elem()
}

func (o GameServerGroupAutoScalingPolicyTargetTrackingConfigurationOutput) ToGameServerGroupAutoScalingPolicyTargetTrackingConfigurationOutput() GameServerGroupAutoScalingPolicyTargetTrackingConfigurationOutput {
	return o
}

func (o GameServerGroupAutoScalingPolicyTargetTrackingConfigurationOutput) ToGameServerGroupAutoScalingPolicyTargetTrackingConfigurationOutputWithContext(ctx context.Context) GameServerGroupAutoScalingPolicyTargetTrackingConfigurationOutput {
	return o
}

func (o GameServerGroupAutoScalingPolicyTargetTrackingConfigurationOutput) ToOutput(ctx context.Context) pulumix.Output[GameServerGroupAutoScalingPolicyTargetTrackingConfiguration] {
	return pulumix.Output[GameServerGroupAutoScalingPolicyTargetTrackingConfiguration]{
		OutputState: o.OutputState,
	}
}

// Desired value to use with a game server group target-based scaling policy.
func (o GameServerGroupAutoScalingPolicyTargetTrackingConfigurationOutput) TargetValue() pulumix.Output[float64] {
	return pulumix.Apply[GameServerGroupAutoScalingPolicyTargetTrackingConfiguration](o, func(v GameServerGroupAutoScalingPolicyTargetTrackingConfiguration) float64 { return v.TargetValue })
}

type GameServerGroupInstanceDefinition struct {
	// An EC2 instance type.
	InstanceType string `pulumi:"instanceType"`
	// Instance weighting that indicates how much this instance type contributes
	// to the total capacity of a game server group.
	// Instance weights are used by GameLift FleetIQ to calculate the instance type's cost per unit hour and better identify
	// the most cost-effective options.
	WeightedCapacity *string `pulumi:"weightedCapacity"`
}

type GameServerGroupInstanceDefinitionArgs struct {
	// An EC2 instance type.
	InstanceType pulumix.Input[string] `pulumi:"instanceType"`
	// Instance weighting that indicates how much this instance type contributes
	// to the total capacity of a game server group.
	// Instance weights are used by GameLift FleetIQ to calculate the instance type's cost per unit hour and better identify
	// the most cost-effective options.
	WeightedCapacity pulumix.Input[*string] `pulumi:"weightedCapacity"`
}

func (GameServerGroupInstanceDefinitionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GameServerGroupInstanceDefinition)(nil)).Elem()
}

func (i GameServerGroupInstanceDefinitionArgs) ToGameServerGroupInstanceDefinitionOutput() GameServerGroupInstanceDefinitionOutput {
	return i.ToGameServerGroupInstanceDefinitionOutputWithContext(context.Background())
}

func (i GameServerGroupInstanceDefinitionArgs) ToGameServerGroupInstanceDefinitionOutputWithContext(ctx context.Context) GameServerGroupInstanceDefinitionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameServerGroupInstanceDefinitionOutput)
}

func (i *GameServerGroupInstanceDefinitionArgs) ToOutput(ctx context.Context) pulumix.Output[*GameServerGroupInstanceDefinitionArgs] {
	return pulumix.Val(i)
}

type GameServerGroupInstanceDefinitionOutput struct{ *pulumi.OutputState }

func (GameServerGroupInstanceDefinitionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GameServerGroupInstanceDefinition)(nil)).Elem()
}

func (o GameServerGroupInstanceDefinitionOutput) ToGameServerGroupInstanceDefinitionOutput() GameServerGroupInstanceDefinitionOutput {
	return o
}

func (o GameServerGroupInstanceDefinitionOutput) ToGameServerGroupInstanceDefinitionOutputWithContext(ctx context.Context) GameServerGroupInstanceDefinitionOutput {
	return o
}

func (o GameServerGroupInstanceDefinitionOutput) ToOutput(ctx context.Context) pulumix.Output[GameServerGroupInstanceDefinition] {
	return pulumix.Output[GameServerGroupInstanceDefinition]{
		OutputState: o.OutputState,
	}
}

// An EC2 instance type.
func (o GameServerGroupInstanceDefinitionOutput) InstanceType() pulumix.Output[string] {
	return pulumix.Apply[GameServerGroupInstanceDefinition](o, func(v GameServerGroupInstanceDefinition) string { return v.InstanceType })
}

// Instance weighting that indicates how much this instance type contributes
// to the total capacity of a game server group.
// Instance weights are used by GameLift FleetIQ to calculate the instance type's cost per unit hour and better identify
// the most cost-effective options.
func (o GameServerGroupInstanceDefinitionOutput) WeightedCapacity() pulumix.Output[*string] {
	return pulumix.Apply[GameServerGroupInstanceDefinition](o, func(v GameServerGroupInstanceDefinition) *string { return v.WeightedCapacity })
}

type GameServerGroupLaunchTemplate struct {
	// A unique identifier for an existing EC2 launch template.
	Id *string `pulumi:"id"`
	// A readable identifier for an existing EC2 launch template.
	Name *string `pulumi:"name"`
	// The version of the EC2 launch template to use. If none is set, the default is the first version created.
	Version *string `pulumi:"version"`
}

type GameServerGroupLaunchTemplateArgs struct {
	// A unique identifier for an existing EC2 launch template.
	Id pulumix.Input[*string] `pulumi:"id"`
	// A readable identifier for an existing EC2 launch template.
	Name pulumix.Input[*string] `pulumi:"name"`
	// The version of the EC2 launch template to use. If none is set, the default is the first version created.
	Version pulumix.Input[*string] `pulumi:"version"`
}

func (GameServerGroupLaunchTemplateArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GameServerGroupLaunchTemplate)(nil)).Elem()
}

func (i GameServerGroupLaunchTemplateArgs) ToGameServerGroupLaunchTemplateOutput() GameServerGroupLaunchTemplateOutput {
	return i.ToGameServerGroupLaunchTemplateOutputWithContext(context.Background())
}

func (i GameServerGroupLaunchTemplateArgs) ToGameServerGroupLaunchTemplateOutputWithContext(ctx context.Context) GameServerGroupLaunchTemplateOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameServerGroupLaunchTemplateOutput)
}

func (i *GameServerGroupLaunchTemplateArgs) ToOutput(ctx context.Context) pulumix.Output[*GameServerGroupLaunchTemplateArgs] {
	return pulumix.Val(i)
}

type GameServerGroupLaunchTemplateOutput struct{ *pulumi.OutputState }

func (GameServerGroupLaunchTemplateOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GameServerGroupLaunchTemplate)(nil)).Elem()
}

func (o GameServerGroupLaunchTemplateOutput) ToGameServerGroupLaunchTemplateOutput() GameServerGroupLaunchTemplateOutput {
	return o
}

func (o GameServerGroupLaunchTemplateOutput) ToGameServerGroupLaunchTemplateOutputWithContext(ctx context.Context) GameServerGroupLaunchTemplateOutput {
	return o
}

func (o GameServerGroupLaunchTemplateOutput) ToOutput(ctx context.Context) pulumix.Output[GameServerGroupLaunchTemplate] {
	return pulumix.Output[GameServerGroupLaunchTemplate]{
		OutputState: o.OutputState,
	}
}

// A unique identifier for an existing EC2 launch template.
func (o GameServerGroupLaunchTemplateOutput) Id() pulumix.Output[*string] {
	return pulumix.Apply[GameServerGroupLaunchTemplate](o, func(v GameServerGroupLaunchTemplate) *string { return v.Id })
}

// A readable identifier for an existing EC2 launch template.
func (o GameServerGroupLaunchTemplateOutput) Name() pulumix.Output[*string] {
	return pulumix.Apply[GameServerGroupLaunchTemplate](o, func(v GameServerGroupLaunchTemplate) *string { return v.Name })
}

// The version of the EC2 launch template to use. If none is set, the default is the first version created.
func (o GameServerGroupLaunchTemplateOutput) Version() pulumix.Output[*string] {
	return pulumix.Apply[GameServerGroupLaunchTemplate](o, func(v GameServerGroupLaunchTemplate) *string { return v.Version })
}

type GameSessionQueuePlayerLatencyPolicy struct {
	// Maximum latency value that is allowed for any player.
	MaximumIndividualPlayerLatencyMilliseconds int `pulumi:"maximumIndividualPlayerLatencyMilliseconds"`
	// Length of time that the policy is enforced while placing a new game session. Absence of value for this attribute means that the policy is enforced until the queue times out.
	PolicyDurationSeconds *int `pulumi:"policyDurationSeconds"`
}

type GameSessionQueuePlayerLatencyPolicyArgs struct {
	// Maximum latency value that is allowed for any player.
	MaximumIndividualPlayerLatencyMilliseconds pulumix.Input[int] `pulumi:"maximumIndividualPlayerLatencyMilliseconds"`
	// Length of time that the policy is enforced while placing a new game session. Absence of value for this attribute means that the policy is enforced until the queue times out.
	PolicyDurationSeconds pulumix.Input[*int] `pulumi:"policyDurationSeconds"`
}

func (GameSessionQueuePlayerLatencyPolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GameSessionQueuePlayerLatencyPolicy)(nil)).Elem()
}

func (i GameSessionQueuePlayerLatencyPolicyArgs) ToGameSessionQueuePlayerLatencyPolicyOutput() GameSessionQueuePlayerLatencyPolicyOutput {
	return i.ToGameSessionQueuePlayerLatencyPolicyOutputWithContext(context.Background())
}

func (i GameSessionQueuePlayerLatencyPolicyArgs) ToGameSessionQueuePlayerLatencyPolicyOutputWithContext(ctx context.Context) GameSessionQueuePlayerLatencyPolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameSessionQueuePlayerLatencyPolicyOutput)
}

func (i *GameSessionQueuePlayerLatencyPolicyArgs) ToOutput(ctx context.Context) pulumix.Output[*GameSessionQueuePlayerLatencyPolicyArgs] {
	return pulumix.Val(i)
}

type GameSessionQueuePlayerLatencyPolicyOutput struct{ *pulumi.OutputState }

func (GameSessionQueuePlayerLatencyPolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GameSessionQueuePlayerLatencyPolicy)(nil)).Elem()
}

func (o GameSessionQueuePlayerLatencyPolicyOutput) ToGameSessionQueuePlayerLatencyPolicyOutput() GameSessionQueuePlayerLatencyPolicyOutput {
	return o
}

func (o GameSessionQueuePlayerLatencyPolicyOutput) ToGameSessionQueuePlayerLatencyPolicyOutputWithContext(ctx context.Context) GameSessionQueuePlayerLatencyPolicyOutput {
	return o
}

func (o GameSessionQueuePlayerLatencyPolicyOutput) ToOutput(ctx context.Context) pulumix.Output[GameSessionQueuePlayerLatencyPolicy] {
	return pulumix.Output[GameSessionQueuePlayerLatencyPolicy]{
		OutputState: o.OutputState,
	}
}

// Maximum latency value that is allowed for any player.
func (o GameSessionQueuePlayerLatencyPolicyOutput) MaximumIndividualPlayerLatencyMilliseconds() pulumix.Output[int] {
	return pulumix.Apply[GameSessionQueuePlayerLatencyPolicy](o, func(v GameSessionQueuePlayerLatencyPolicy) int { return v.MaximumIndividualPlayerLatencyMilliseconds })
}

// Length of time that the policy is enforced while placing a new game session. Absence of value for this attribute means that the policy is enforced until the queue times out.
func (o GameSessionQueuePlayerLatencyPolicyOutput) PolicyDurationSeconds() pulumix.Output[*int] {
	return pulumix.Apply[GameSessionQueuePlayerLatencyPolicy](o, func(v GameSessionQueuePlayerLatencyPolicy) *int { return v.PolicyDurationSeconds })
}

type MatchmakingConfigurationGameProperty struct {
	// A game property key
	Key string `pulumi:"key"`
	// A game property value.
	Value string `pulumi:"value"`
}

type MatchmakingConfigurationGamePropertyArgs struct {
	// A game property key
	Key pulumix.Input[string] `pulumi:"key"`
	// A game property value.
	Value pulumix.Input[string] `pulumi:"value"`
}

func (MatchmakingConfigurationGamePropertyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*MatchmakingConfigurationGameProperty)(nil)).Elem()
}

func (i MatchmakingConfigurationGamePropertyArgs) ToMatchmakingConfigurationGamePropertyOutput() MatchmakingConfigurationGamePropertyOutput {
	return i.ToMatchmakingConfigurationGamePropertyOutputWithContext(context.Background())
}

func (i MatchmakingConfigurationGamePropertyArgs) ToMatchmakingConfigurationGamePropertyOutputWithContext(ctx context.Context) MatchmakingConfigurationGamePropertyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MatchmakingConfigurationGamePropertyOutput)
}

func (i *MatchmakingConfigurationGamePropertyArgs) ToOutput(ctx context.Context) pulumix.Output[*MatchmakingConfigurationGamePropertyArgs] {
	return pulumix.Val(i)
}

type MatchmakingConfigurationGamePropertyOutput struct{ *pulumi.OutputState }

func (MatchmakingConfigurationGamePropertyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MatchmakingConfigurationGameProperty)(nil)).Elem()
}

func (o MatchmakingConfigurationGamePropertyOutput) ToMatchmakingConfigurationGamePropertyOutput() MatchmakingConfigurationGamePropertyOutput {
	return o
}

func (o MatchmakingConfigurationGamePropertyOutput) ToMatchmakingConfigurationGamePropertyOutputWithContext(ctx context.Context) MatchmakingConfigurationGamePropertyOutput {
	return o
}

func (o MatchmakingConfigurationGamePropertyOutput) ToOutput(ctx context.Context) pulumix.Output[MatchmakingConfigurationGameProperty] {
	return pulumix.Output[MatchmakingConfigurationGameProperty]{
		OutputState: o.OutputState,
	}
}

// A game property key
func (o MatchmakingConfigurationGamePropertyOutput) Key() pulumix.Output[string] {
	return pulumix.Apply[MatchmakingConfigurationGameProperty](o, func(v MatchmakingConfigurationGameProperty) string { return v.Key })
}

// A game property value.
func (o MatchmakingConfigurationGamePropertyOutput) Value() pulumix.Output[string] {
	return pulumix.Apply[MatchmakingConfigurationGameProperty](o, func(v MatchmakingConfigurationGameProperty) string { return v.Value })
}

type ScriptStorageLocation struct {
	// Name of your S3 bucket.
	Bucket string `pulumi:"bucket"`
	// Name of the zip file containing your script files.
	Key string `pulumi:"key"`
	// A specific version of the file. If not set, the latest version of the file is retrieved.
	ObjectVersion *string `pulumi:"objectVersion"`
	// ARN of the access role that allows Amazon GameLift to access your S3 bucket.
	RoleArn string `pulumi:"roleArn"`
}

type ScriptStorageLocationArgs struct {
	// Name of your S3 bucket.
	Bucket pulumix.Input[string] `pulumi:"bucket"`
	// Name of the zip file containing your script files.
	Key pulumix.Input[string] `pulumi:"key"`
	// A specific version of the file. If not set, the latest version of the file is retrieved.
	ObjectVersion pulumix.Input[*string] `pulumi:"objectVersion"`
	// ARN of the access role that allows Amazon GameLift to access your S3 bucket.
	RoleArn pulumix.Input[string] `pulumi:"roleArn"`
}

func (ScriptStorageLocationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ScriptStorageLocation)(nil)).Elem()
}

func (i ScriptStorageLocationArgs) ToScriptStorageLocationOutput() ScriptStorageLocationOutput {
	return i.ToScriptStorageLocationOutputWithContext(context.Background())
}

func (i ScriptStorageLocationArgs) ToScriptStorageLocationOutputWithContext(ctx context.Context) ScriptStorageLocationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ScriptStorageLocationOutput)
}

func (i *ScriptStorageLocationArgs) ToOutput(ctx context.Context) pulumix.Output[*ScriptStorageLocationArgs] {
	return pulumix.Val(i)
}

type ScriptStorageLocationOutput struct{ *pulumi.OutputState }

func (ScriptStorageLocationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ScriptStorageLocation)(nil)).Elem()
}

func (o ScriptStorageLocationOutput) ToScriptStorageLocationOutput() ScriptStorageLocationOutput {
	return o
}

func (o ScriptStorageLocationOutput) ToScriptStorageLocationOutputWithContext(ctx context.Context) ScriptStorageLocationOutput {
	return o
}

func (o ScriptStorageLocationOutput) ToOutput(ctx context.Context) pulumix.Output[ScriptStorageLocation] {
	return pulumix.Output[ScriptStorageLocation]{
		OutputState: o.OutputState,
	}
}

// Name of your S3 bucket.
func (o ScriptStorageLocationOutput) Bucket() pulumix.Output[string] {
	return pulumix.Apply[ScriptStorageLocation](o, func(v ScriptStorageLocation) string { return v.Bucket })
}

// Name of the zip file containing your script files.
func (o ScriptStorageLocationOutput) Key() pulumix.Output[string] {
	return pulumix.Apply[ScriptStorageLocation](o, func(v ScriptStorageLocation) string { return v.Key })
}

// A specific version of the file. If not set, the latest version of the file is retrieved.
func (o ScriptStorageLocationOutput) ObjectVersion() pulumix.Output[*string] {
	return pulumix.Apply[ScriptStorageLocation](o, func(v ScriptStorageLocation) *string { return v.ObjectVersion })
}

// ARN of the access role that allows Amazon GameLift to access your S3 bucket.
func (o ScriptStorageLocationOutput) RoleArn() pulumix.Output[string] {
	return pulumix.Apply[ScriptStorageLocation](o, func(v ScriptStorageLocation) string { return v.RoleArn })
}

func init() {
	pulumi.RegisterOutputType(AliasRoutingStrategyOutput{})
	pulumi.RegisterOutputType(BuildStorageLocationOutput{})
	pulumi.RegisterOutputType(FleetCertificateConfigurationOutput{})
	pulumi.RegisterOutputType(FleetEc2InboundPermissionOutput{})
	pulumi.RegisterOutputType(FleetResourceCreationLimitPolicyOutput{})
	pulumi.RegisterOutputType(FleetRuntimeConfigurationOutput{})
	pulumi.RegisterOutputType(FleetRuntimeConfigurationServerProcessOutput{})
	pulumi.RegisterOutputType(GameServerGroupAutoScalingPolicyOutput{})
	pulumi.RegisterOutputType(GameServerGroupAutoScalingPolicyTargetTrackingConfigurationOutput{})
	pulumi.RegisterOutputType(GameServerGroupInstanceDefinitionOutput{})
	pulumi.RegisterOutputType(GameServerGroupLaunchTemplateOutput{})
	pulumi.RegisterOutputType(GameSessionQueuePlayerLatencyPolicyOutput{})
	pulumi.RegisterOutputType(MatchmakingConfigurationGamePropertyOutput{})
	pulumi.RegisterOutputType(ScriptStorageLocationOutput{})
}
