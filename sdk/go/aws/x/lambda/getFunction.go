// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package lambda

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi-aws/sdk/v6/go/aws/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumix"
)

// Provides information about a Lambda Function.
func LookupFunction(ctx *pulumi.Context, args *LookupFunctionArgs, opts ...pulumi.InvokeOption) (*LookupFunctionResult, error) {
	opts = internal.PkgInvokeDefaultOpts(opts)
	var rv LookupFunctionResult
	err := ctx.Invoke("aws:lambda/getFunction:getFunction", args, &rv, opts...)
	if err != nil {
		return nil, err
	}
	return &rv, nil
}

// A collection of arguments for invoking getFunction.
type LookupFunctionArgs struct {
	// Name of the lambda function.
	FunctionName string `pulumi:"functionName"`
	// Alias name or version number of the lambda functionE.g., `$LATEST`, `my-alias`, or `1`. When not included: the data source resolves to the most recent published version; if no published version exists: it resolves to the most recent unpublished version.
	Qualifier *string           `pulumi:"qualifier"`
	Tags      map[string]string `pulumi:"tags"`
}

// A collection of values returned by getFunction.
type LookupFunctionResult struct {
	// Instruction set architecture for the Lambda function.
	Architectures []string `pulumi:"architectures"`
	// Unqualified (no `:QUALIFIER` or `:VERSION` suffix) ARN identifying your Lambda Function. See also `qualifiedArn`.
	Arn string `pulumi:"arn"`
	// ARN for a Code Signing Configuration.
	CodeSigningConfigArn string `pulumi:"codeSigningConfigArn"`
	// Configure the function's *dead letter queue*.
	DeadLetterConfig GetFunctionDeadLetterConfig `pulumi:"deadLetterConfig"`
	// Description of what your Lambda Function does.
	Description string `pulumi:"description"`
	// Lambda environment's configuration settings.
	Environment GetFunctionEnvironment `pulumi:"environment"`
	// Amount of Ephemeral storage(`/tmp`) allocated for the Lambda Function.
	EphemeralStorages []GetFunctionEphemeralStorage `pulumi:"ephemeralStorages"`
	// Connection settings for an Amazon EFS file system.
	FileSystemConfigs []GetFunctionFileSystemConfig `pulumi:"fileSystemConfigs"`
	FunctionName      string                        `pulumi:"functionName"`
	// Function entrypoint in your code.
	Handler string `pulumi:"handler"`
	// The provider-assigned unique ID for this managed resource.
	Id string `pulumi:"id"`
	// URI of the container image.
	ImageUri string `pulumi:"imageUri"`
	// ARN to be used for invoking Lambda Function from API Gateway. **NOTE:** Starting with `v4.51.0` of the provider, this will *not* include the qualifier.
	InvokeArn string `pulumi:"invokeArn"`
	// ARN for the KMS encryption key.
	KmsKeyArn string `pulumi:"kmsKeyArn"`
	// Date this resource was last modified.
	LastModified string `pulumi:"lastModified"`
	// List of Lambda Layer ARNs attached to your Lambda Function.
	Layers []string `pulumi:"layers"`
	// Amount of memory in MB your Lambda Function can use at runtime.
	MemorySize int `pulumi:"memorySize"`
	// Qualified (`:QUALIFIER` or `:VERSION` suffix) ARN identifying your Lambda Function. See also `arn`.
	QualifiedArn string `pulumi:"qualifiedArn"`
	// Qualified (`:QUALIFIER` or `:VERSION` suffix) ARN to be used for invoking Lambda Function from API Gateway. See also `invokeArn`.
	QualifiedInvokeArn string  `pulumi:"qualifiedInvokeArn"`
	Qualifier          *string `pulumi:"qualifier"`
	// The amount of reserved concurrent executions for this lambda function or `-1` if unreserved.
	ReservedConcurrentExecutions int `pulumi:"reservedConcurrentExecutions"`
	// IAM role attached to the Lambda Function.
	Role string `pulumi:"role"`
	// Runtime environment for the Lambda function.
	Runtime string `pulumi:"runtime"`
	// ARN of a signing job.
	SigningJobArn string `pulumi:"signingJobArn"`
	// The ARN for a signing profile version.
	SigningProfileVersionArn string `pulumi:"signingProfileVersionArn"`
	// Base64-encoded representation of raw SHA-256 sum of the zip file.
	SourceCodeHash string `pulumi:"sourceCodeHash"`
	// Size in bytes of the function .zip file.
	SourceCodeSize int               `pulumi:"sourceCodeSize"`
	Tags           map[string]string `pulumi:"tags"`
	// Function execution time at which Lambda should terminate the function.
	Timeout int `pulumi:"timeout"`
	// Tracing settings of the function.
	TracingConfig GetFunctionTracingConfig `pulumi:"tracingConfig"`
	// The version of the Lambda function returned. If `qualifier` is not set, this will resolve to the most recent published version. If no published version of the function exists, `version` will resolve to `$LATEST`.
	Version string `pulumi:"version"`
	// VPC configuration associated with your Lambda function.
	VpcConfig GetFunctionVpcConfig `pulumi:"vpcConfig"`
}

func LookupFunctionOutput(ctx *pulumi.Context, args LookupFunctionOutputArgs, opts ...pulumi.InvokeOption) LookupFunctionResultOutput {
	outputResult := pulumix.ApplyErr[*LookupFunctionArgs](args.ToOutput(), func(plainArgs *LookupFunctionArgs) (*LookupFunctionResult, error) {
		return LookupFunction(ctx, plainArgs, opts...)
	})

	return pulumix.Cast[LookupFunctionResultOutput, *LookupFunctionResult](outputResult)
}

// A collection of arguments for invoking getFunction.
type LookupFunctionOutputArgs struct {
	// Name of the lambda function.
	FunctionName pulumix.Input[string] `pulumi:"functionName"`
	// Alias name or version number of the lambda functionE.g., `$LATEST`, `my-alias`, or `1`. When not included: the data source resolves to the most recent published version; if no published version exists: it resolves to the most recent unpublished version.
	Qualifier pulumix.Input[*string]           `pulumi:"qualifier"`
	Tags      pulumix.Input[map[string]string] `pulumi:"tags"`
}

func (args LookupFunctionOutputArgs) ToOutput() pulumix.Output[*LookupFunctionArgs] {
	allArgs := pulumix.All(
		args.FunctionName.ToOutput(context.Background()).AsAny(),
		args.Qualifier.ToOutput(context.Background()).AsAny(),
		args.Tags.ToOutput(context.Background()).AsAny())
	return pulumix.Apply[[]any](allArgs, func(resolvedArgs []interface{}) *LookupFunctionArgs {
		return &LookupFunctionArgs{
			FunctionName: resolvedArgs[0].(string),
			Qualifier:    resolvedArgs[1].(*string),
			Tags:         resolvedArgs[2].(map[string]string),
		}
	})
}

type LookupFunctionResultOutput struct{ *pulumi.OutputState }

func (LookupFunctionResultOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LookupFunctionResult)(nil)).Elem()
}

func (o LookupFunctionResultOutput) ToOutput(context.Context) pulumix.Output[*LookupFunctionResult] {
	return pulumix.Output[*LookupFunctionResult]{
		OutputState: o.OutputState,
	}
}

func (o LookupFunctionResultOutput) Architectures() pulumix.ArrayOutput[string] {
	value := pulumix.Apply[*LookupFunctionResult](o, func(v *LookupFunctionResult) []string { return v.Architectures })
	return pulumix.ArrayOutput[string]{
		OutputState: value.OutputState,
	}
}

func (o LookupFunctionResultOutput) Arn() pulumix.Output[string] {
	return pulumix.Apply[*LookupFunctionResult](o, func(v *LookupFunctionResult) string { return v.Arn })
}

func (o LookupFunctionResultOutput) CodeSigningConfigArn() pulumix.Output[string] {
	return pulumix.Apply[*LookupFunctionResult](o, func(v *LookupFunctionResult) string { return v.CodeSigningConfigArn })
}

func (o LookupFunctionResultOutput) DeadLetterConfig() pulumix.GPtrOutput[GetFunctionDeadLetterConfig, GetFunctionDeadLetterConfigOutput] {
	value := pulumix.Apply[*LookupFunctionResult](o, func(v *LookupFunctionResult) GetFunctionDeadLetterConfig { return v.DeadLetterConfig })
	return pulumix.GPtrOutput[GetFunctionDeadLetterConfig, GetFunctionDeadLetterConfigOutput]{
		OutputState: value.OutputState,
	}
}

func (o LookupFunctionResultOutput) Description() pulumix.Output[string] {
	return pulumix.Apply[*LookupFunctionResult](o, func(v *LookupFunctionResult) string { return v.Description })
}

func (o LookupFunctionResultOutput) Environment() pulumix.GPtrOutput[GetFunctionEnvironment, GetFunctionEnvironmentOutput] {
	value := pulumix.Apply[*LookupFunctionResult](o, func(v *LookupFunctionResult) GetFunctionEnvironment { return v.Environment })
	return pulumix.GPtrOutput[GetFunctionEnvironment, GetFunctionEnvironmentOutput]{
		OutputState: value.OutputState,
	}
}

func (o LookupFunctionResultOutput) EphemeralStorages() pulumix.GArrayOutput[GetFunctionEphemeralStorage, GetFunctionEphemeralStorageOutput] {
	value := pulumix.Apply[*LookupFunctionResult](o, func(v *LookupFunctionResult) []GetFunctionEphemeralStorage { return v.EphemeralStorages })
	return pulumix.GArrayOutput[GetFunctionEphemeralStorage, GetFunctionEphemeralStorageOutput]{
		OutputState: value.OutputState,
	}
}

func (o LookupFunctionResultOutput) FileSystemConfigs() pulumix.GArrayOutput[GetFunctionFileSystemConfig, GetFunctionFileSystemConfigOutput] {
	value := pulumix.Apply[*LookupFunctionResult](o, func(v *LookupFunctionResult) []GetFunctionFileSystemConfig { return v.FileSystemConfigs })
	return pulumix.GArrayOutput[GetFunctionFileSystemConfig, GetFunctionFileSystemConfigOutput]{
		OutputState: value.OutputState,
	}
}

func (o LookupFunctionResultOutput) FunctionName() pulumix.Output[string] {
	return pulumix.Apply[*LookupFunctionResult](o, func(v *LookupFunctionResult) string { return v.FunctionName })
}

func (o LookupFunctionResultOutput) Handler() pulumix.Output[string] {
	return pulumix.Apply[*LookupFunctionResult](o, func(v *LookupFunctionResult) string { return v.Handler })
}

func (o LookupFunctionResultOutput) Id() pulumix.Output[string] {
	return pulumix.Apply[*LookupFunctionResult](o, func(v *LookupFunctionResult) string { return v.Id })
}

func (o LookupFunctionResultOutput) ImageUri() pulumix.Output[string] {
	return pulumix.Apply[*LookupFunctionResult](o, func(v *LookupFunctionResult) string { return v.ImageUri })
}

func (o LookupFunctionResultOutput) InvokeArn() pulumix.Output[string] {
	return pulumix.Apply[*LookupFunctionResult](o, func(v *LookupFunctionResult) string { return v.InvokeArn })
}

func (o LookupFunctionResultOutput) KmsKeyArn() pulumix.Output[string] {
	return pulumix.Apply[*LookupFunctionResult](o, func(v *LookupFunctionResult) string { return v.KmsKeyArn })
}

func (o LookupFunctionResultOutput) LastModified() pulumix.Output[string] {
	return pulumix.Apply[*LookupFunctionResult](o, func(v *LookupFunctionResult) string { return v.LastModified })
}

func (o LookupFunctionResultOutput) Layers() pulumix.ArrayOutput[string] {
	value := pulumix.Apply[*LookupFunctionResult](o, func(v *LookupFunctionResult) []string { return v.Layers })
	return pulumix.ArrayOutput[string]{
		OutputState: value.OutputState,
	}
}

func (o LookupFunctionResultOutput) MemorySize() pulumix.Output[int] {
	return pulumix.Apply[*LookupFunctionResult](o, func(v *LookupFunctionResult) int { return v.MemorySize })
}

func (o LookupFunctionResultOutput) QualifiedArn() pulumix.Output[string] {
	return pulumix.Apply[*LookupFunctionResult](o, func(v *LookupFunctionResult) string { return v.QualifiedArn })
}

func (o LookupFunctionResultOutput) QualifiedInvokeArn() pulumix.Output[string] {
	return pulumix.Apply[*LookupFunctionResult](o, func(v *LookupFunctionResult) string { return v.QualifiedInvokeArn })
}

func (o LookupFunctionResultOutput) Qualifier() pulumix.Output[*string] {
	return pulumix.Apply[*LookupFunctionResult](o, func(v *LookupFunctionResult) *string { return v.Qualifier })
}

func (o LookupFunctionResultOutput) ReservedConcurrentExecutions() pulumix.Output[int] {
	return pulumix.Apply[*LookupFunctionResult](o, func(v *LookupFunctionResult) int { return v.ReservedConcurrentExecutions })
}

func (o LookupFunctionResultOutput) Role() pulumix.Output[string] {
	return pulumix.Apply[*LookupFunctionResult](o, func(v *LookupFunctionResult) string { return v.Role })
}

func (o LookupFunctionResultOutput) Runtime() pulumix.Output[string] {
	return pulumix.Apply[*LookupFunctionResult](o, func(v *LookupFunctionResult) string { return v.Runtime })
}

func (o LookupFunctionResultOutput) SigningJobArn() pulumix.Output[string] {
	return pulumix.Apply[*LookupFunctionResult](o, func(v *LookupFunctionResult) string { return v.SigningJobArn })
}

func (o LookupFunctionResultOutput) SigningProfileVersionArn() pulumix.Output[string] {
	return pulumix.Apply[*LookupFunctionResult](o, func(v *LookupFunctionResult) string { return v.SigningProfileVersionArn })
}

func (o LookupFunctionResultOutput) SourceCodeHash() pulumix.Output[string] {
	return pulumix.Apply[*LookupFunctionResult](o, func(v *LookupFunctionResult) string { return v.SourceCodeHash })
}

func (o LookupFunctionResultOutput) SourceCodeSize() pulumix.Output[int] {
	return pulumix.Apply[*LookupFunctionResult](o, func(v *LookupFunctionResult) int { return v.SourceCodeSize })
}

func (o LookupFunctionResultOutput) Tags() pulumix.MapOutput[string] {
	value := pulumix.Apply[*LookupFunctionResult](o, func(v *LookupFunctionResult) map[string]string { return v.Tags })
	return pulumix.MapOutput[string]{
		OutputState: value.OutputState,
	}
}

func (o LookupFunctionResultOutput) Timeout() pulumix.Output[int] {
	return pulumix.Apply[*LookupFunctionResult](o, func(v *LookupFunctionResult) int { return v.Timeout })
}

func (o LookupFunctionResultOutput) TracingConfig() pulumix.GPtrOutput[GetFunctionTracingConfig, GetFunctionTracingConfigOutput] {
	value := pulumix.Apply[*LookupFunctionResult](o, func(v *LookupFunctionResult) GetFunctionTracingConfig { return v.TracingConfig })
	return pulumix.GPtrOutput[GetFunctionTracingConfig, GetFunctionTracingConfigOutput]{
		OutputState: value.OutputState,
	}
}

func (o LookupFunctionResultOutput) Version() pulumix.Output[string] {
	return pulumix.Apply[*LookupFunctionResult](o, func(v *LookupFunctionResult) string { return v.Version })
}

func (o LookupFunctionResultOutput) VpcConfig() pulumix.GPtrOutput[GetFunctionVpcConfig, GetFunctionVpcConfigOutput] {
	value := pulumix.Apply[*LookupFunctionResult](o, func(v *LookupFunctionResult) GetFunctionVpcConfig { return v.VpcConfig })
	return pulumix.GPtrOutput[GetFunctionVpcConfig, GetFunctionVpcConfigOutput]{
		OutputState: value.OutputState,
	}
}
