// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package gamelift

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-aws/sdk/v6/go/aws/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumix"
)

// Provides a GameLift Alias resource.
type MatchmakingConfiguration struct {
	pulumi.CustomResourceState

	// Specifies if the match that was created with this configuration must be accepted by matched players.
	AcceptanceRequired pulumix.Output[*bool] `pulumi:"acceptanceRequired"`
	// The length of time (in seconds) to wait for players to accept a proposed match, if acceptance is required.
	AcceptanceTimeoutSeconds pulumix.Output[*int] `pulumi:"acceptanceTimeoutSeconds"`
	// The number of player slots in a match to keep open for future players.
	AdditionalPlayerCount pulumix.Output[*int] `pulumi:"additionalPlayerCount"`
	// Matchmaking Configuration ARN.
	Arn pulumix.Output[string] `pulumi:"arn"`
	// The method used to backfill game sessions that are created with this matchmaking configuration.
	BackfillMode pulumix.Output[*string] `pulumi:"backfillMode"`
	// The time when the Matchmaking Configuration was created.
	CreationTime pulumix.Output[string] `pulumi:"creationTime"`
	// Information to be added to all events related to this matchmaking configuration.
	CustomEventData pulumix.Output[*string] `pulumi:"customEventData"`
	// A human-readable description of the matchmaking configuration.
	Description pulumix.Output[*string] `pulumi:"description"`
	// Indicates whether this matchmaking configuration is being used with GameLift hosting or as a standalone matchmaking solution.
	FlexMatchMode pulumix.Output[string] `pulumi:"flexMatchMode"`
	// One or more custom game properties. See below.
	GameProperties pulumix.GArrayOutput[MatchmakingConfigurationGameProperty, MatchmakingConfigurationGamePropertyOutput] `pulumi:"gameProperties"`
	// A set of custom game session properties.
	GameSessionData pulumix.Output[*string] `pulumi:"gameSessionData"`
	// The ARNs of the GameLift game session queue resources.
	GameSessionQueueArns pulumix.ArrayOutput[string] `pulumi:"gameSessionQueueArns"`
	// Name of the matchmaking configuration
	Name pulumix.Output[string] `pulumi:"name"`
	// An SNS topic ARN that is set up to receive matchmaking notifications.
	NotificationTarget pulumix.Output[*string] `pulumi:"notificationTarget"`
	// The maximum duration, in seconds, that a matchmaking ticket can remain in process before timing out.
	RequestTimeoutSeconds pulumix.Output[int]    `pulumi:"requestTimeoutSeconds"`
	RuleSetArn            pulumix.Output[string] `pulumi:"ruleSetArn"`
	// A rule set names for the matchmaking rule set to use with this configuration.
	RuleSetName pulumix.Output[string] `pulumi:"ruleSetName"`
	// Key-value map of resource tags. .If configured with a provider `defaultTags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
	Tags pulumix.MapOutput[string] `pulumi:"tags"`
	// A map of tags assigned to the resource, including those inherited from the provider `defaultTags` configuration block.
	TagsAll pulumix.MapOutput[string] `pulumi:"tagsAll"`
}

// NewMatchmakingConfiguration registers a new resource with the given unique name, arguments, and options.
func NewMatchmakingConfiguration(ctx *pulumi.Context,
	name string, args *MatchmakingConfigurationArgs, opts ...pulumi.ResourceOption) (*MatchmakingConfiguration, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.RequestTimeoutSeconds == nil {
		return nil, errors.New("invalid value for required argument 'RequestTimeoutSeconds'")
	}
	if args.RuleSetName == nil {
		return nil, errors.New("invalid value for required argument 'RuleSetName'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource MatchmakingConfiguration
	err := ctx.RegisterResource("aws:gamelift/matchmakingConfiguration:MatchmakingConfiguration", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetMatchmakingConfiguration gets an existing MatchmakingConfiguration resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetMatchmakingConfiguration(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *MatchmakingConfigurationState, opts ...pulumi.ResourceOption) (*MatchmakingConfiguration, error) {
	var resource MatchmakingConfiguration
	err := ctx.ReadResource("aws:gamelift/matchmakingConfiguration:MatchmakingConfiguration", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering MatchmakingConfiguration resources.
type matchmakingConfigurationState struct {
	// Specifies if the match that was created with this configuration must be accepted by matched players.
	AcceptanceRequired *bool `pulumi:"acceptanceRequired"`
	// The length of time (in seconds) to wait for players to accept a proposed match, if acceptance is required.
	AcceptanceTimeoutSeconds *int `pulumi:"acceptanceTimeoutSeconds"`
	// The number of player slots in a match to keep open for future players.
	AdditionalPlayerCount *int `pulumi:"additionalPlayerCount"`
	// Matchmaking Configuration ARN.
	Arn *string `pulumi:"arn"`
	// The method used to backfill game sessions that are created with this matchmaking configuration.
	BackfillMode *string `pulumi:"backfillMode"`
	// The time when the Matchmaking Configuration was created.
	CreationTime *string `pulumi:"creationTime"`
	// Information to be added to all events related to this matchmaking configuration.
	CustomEventData *string `pulumi:"customEventData"`
	// A human-readable description of the matchmaking configuration.
	Description *string `pulumi:"description"`
	// Indicates whether this matchmaking configuration is being used with GameLift hosting or as a standalone matchmaking solution.
	FlexMatchMode *string `pulumi:"flexMatchMode"`
	// One or more custom game properties. See below.
	GameProperties []MatchmakingConfigurationGameProperty `pulumi:"gameProperties"`
	// A set of custom game session properties.
	GameSessionData *string `pulumi:"gameSessionData"`
	// The ARNs of the GameLift game session queue resources.
	GameSessionQueueArns []string `pulumi:"gameSessionQueueArns"`
	// Name of the matchmaking configuration
	Name *string `pulumi:"name"`
	// An SNS topic ARN that is set up to receive matchmaking notifications.
	NotificationTarget *string `pulumi:"notificationTarget"`
	// The maximum duration, in seconds, that a matchmaking ticket can remain in process before timing out.
	RequestTimeoutSeconds *int    `pulumi:"requestTimeoutSeconds"`
	RuleSetArn            *string `pulumi:"ruleSetArn"`
	// A rule set names for the matchmaking rule set to use with this configuration.
	RuleSetName *string `pulumi:"ruleSetName"`
	// Key-value map of resource tags. .If configured with a provider `defaultTags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
	Tags map[string]string `pulumi:"tags"`
	// A map of tags assigned to the resource, including those inherited from the provider `defaultTags` configuration block.
	TagsAll map[string]string `pulumi:"tagsAll"`
}

type MatchmakingConfigurationState struct {
	// Specifies if the match that was created with this configuration must be accepted by matched players.
	AcceptanceRequired pulumix.Input[*bool]
	// The length of time (in seconds) to wait for players to accept a proposed match, if acceptance is required.
	AcceptanceTimeoutSeconds pulumix.Input[*int]
	// The number of player slots in a match to keep open for future players.
	AdditionalPlayerCount pulumix.Input[*int]
	// Matchmaking Configuration ARN.
	Arn pulumix.Input[*string]
	// The method used to backfill game sessions that are created with this matchmaking configuration.
	BackfillMode pulumix.Input[*string]
	// The time when the Matchmaking Configuration was created.
	CreationTime pulumix.Input[*string]
	// Information to be added to all events related to this matchmaking configuration.
	CustomEventData pulumix.Input[*string]
	// A human-readable description of the matchmaking configuration.
	Description pulumix.Input[*string]
	// Indicates whether this matchmaking configuration is being used with GameLift hosting or as a standalone matchmaking solution.
	FlexMatchMode pulumix.Input[*string]
	// One or more custom game properties. See below.
	GameProperties pulumix.Input[[]*MatchmakingConfigurationGamePropertyArgs]
	// A set of custom game session properties.
	GameSessionData pulumix.Input[*string]
	// The ARNs of the GameLift game session queue resources.
	GameSessionQueueArns pulumix.Input[[]string]
	// Name of the matchmaking configuration
	Name pulumix.Input[*string]
	// An SNS topic ARN that is set up to receive matchmaking notifications.
	NotificationTarget pulumix.Input[*string]
	// The maximum duration, in seconds, that a matchmaking ticket can remain in process before timing out.
	RequestTimeoutSeconds pulumix.Input[*int]
	RuleSetArn            pulumix.Input[*string]
	// A rule set names for the matchmaking rule set to use with this configuration.
	RuleSetName pulumix.Input[*string]
	// Key-value map of resource tags. .If configured with a provider `defaultTags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
	Tags pulumix.Input[map[string]string]
	// A map of tags assigned to the resource, including those inherited from the provider `defaultTags` configuration block.
	TagsAll pulumix.Input[map[string]string]
}

func (MatchmakingConfigurationState) ElementType() reflect.Type {
	return reflect.TypeOf((*matchmakingConfigurationState)(nil)).Elem()
}

type matchmakingConfigurationArgs struct {
	// Specifies if the match that was created with this configuration must be accepted by matched players.
	AcceptanceRequired *bool `pulumi:"acceptanceRequired"`
	// The length of time (in seconds) to wait for players to accept a proposed match, if acceptance is required.
	AcceptanceTimeoutSeconds *int `pulumi:"acceptanceTimeoutSeconds"`
	// The number of player slots in a match to keep open for future players.
	AdditionalPlayerCount *int `pulumi:"additionalPlayerCount"`
	// The method used to backfill game sessions that are created with this matchmaking configuration.
	BackfillMode *string `pulumi:"backfillMode"`
	// Information to be added to all events related to this matchmaking configuration.
	CustomEventData *string `pulumi:"customEventData"`
	// A human-readable description of the matchmaking configuration.
	Description *string `pulumi:"description"`
	// Indicates whether this matchmaking configuration is being used with GameLift hosting or as a standalone matchmaking solution.
	FlexMatchMode *string `pulumi:"flexMatchMode"`
	// One or more custom game properties. See below.
	GameProperties []MatchmakingConfigurationGameProperty `pulumi:"gameProperties"`
	// A set of custom game session properties.
	GameSessionData *string `pulumi:"gameSessionData"`
	// The ARNs of the GameLift game session queue resources.
	GameSessionQueueArns []string `pulumi:"gameSessionQueueArns"`
	// Name of the matchmaking configuration
	Name *string `pulumi:"name"`
	// An SNS topic ARN that is set up to receive matchmaking notifications.
	NotificationTarget *string `pulumi:"notificationTarget"`
	// The maximum duration, in seconds, that a matchmaking ticket can remain in process before timing out.
	RequestTimeoutSeconds int `pulumi:"requestTimeoutSeconds"`
	// A rule set names for the matchmaking rule set to use with this configuration.
	RuleSetName string `pulumi:"ruleSetName"`
	// Key-value map of resource tags. .If configured with a provider `defaultTags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
	Tags map[string]string `pulumi:"tags"`
}

// The set of arguments for constructing a MatchmakingConfiguration resource.
type MatchmakingConfigurationArgs struct {
	// Specifies if the match that was created with this configuration must be accepted by matched players.
	AcceptanceRequired pulumix.Input[*bool]
	// The length of time (in seconds) to wait for players to accept a proposed match, if acceptance is required.
	AcceptanceTimeoutSeconds pulumix.Input[*int]
	// The number of player slots in a match to keep open for future players.
	AdditionalPlayerCount pulumix.Input[*int]
	// The method used to backfill game sessions that are created with this matchmaking configuration.
	BackfillMode pulumix.Input[*string]
	// Information to be added to all events related to this matchmaking configuration.
	CustomEventData pulumix.Input[*string]
	// A human-readable description of the matchmaking configuration.
	Description pulumix.Input[*string]
	// Indicates whether this matchmaking configuration is being used with GameLift hosting or as a standalone matchmaking solution.
	FlexMatchMode pulumix.Input[*string]
	// One or more custom game properties. See below.
	GameProperties pulumix.Input[[]*MatchmakingConfigurationGamePropertyArgs]
	// A set of custom game session properties.
	GameSessionData pulumix.Input[*string]
	// The ARNs of the GameLift game session queue resources.
	GameSessionQueueArns pulumix.Input[[]string]
	// Name of the matchmaking configuration
	Name pulumix.Input[*string]
	// An SNS topic ARN that is set up to receive matchmaking notifications.
	NotificationTarget pulumix.Input[*string]
	// The maximum duration, in seconds, that a matchmaking ticket can remain in process before timing out.
	RequestTimeoutSeconds pulumix.Input[int]
	// A rule set names for the matchmaking rule set to use with this configuration.
	RuleSetName pulumix.Input[string]
	// Key-value map of resource tags. .If configured with a provider `defaultTags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
	Tags pulumix.Input[map[string]string]
}

func (MatchmakingConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*matchmakingConfigurationArgs)(nil)).Elem()
}

type MatchmakingConfigurationOutput struct{ *pulumi.OutputState }

func (MatchmakingConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MatchmakingConfiguration)(nil)).Elem()
}

func (o MatchmakingConfigurationOutput) ToMatchmakingConfigurationOutput() MatchmakingConfigurationOutput {
	return o
}

func (o MatchmakingConfigurationOutput) ToMatchmakingConfigurationOutputWithContext(ctx context.Context) MatchmakingConfigurationOutput {
	return o
}

func (o MatchmakingConfigurationOutput) ToOutput(ctx context.Context) pulumix.Output[MatchmakingConfiguration] {
	return pulumix.Output[MatchmakingConfiguration]{
		OutputState: o.OutputState,
	}
}

// Specifies if the match that was created with this configuration must be accepted by matched players.
func (o MatchmakingConfigurationOutput) AcceptanceRequired() pulumix.Output[*bool] {
	value := pulumix.Apply[MatchmakingConfiguration](o, func(v MatchmakingConfiguration) pulumix.Output[*bool] { return v.AcceptanceRequired })
	return pulumix.Flatten[*bool, pulumix.Output[*bool]](value)
}

// The length of time (in seconds) to wait for players to accept a proposed match, if acceptance is required.
func (o MatchmakingConfigurationOutput) AcceptanceTimeoutSeconds() pulumix.Output[*int] {
	value := pulumix.Apply[MatchmakingConfiguration](o, func(v MatchmakingConfiguration) pulumix.Output[*int] { return v.AcceptanceTimeoutSeconds })
	return pulumix.Flatten[*int, pulumix.Output[*int]](value)
}

// The number of player slots in a match to keep open for future players.
func (o MatchmakingConfigurationOutput) AdditionalPlayerCount() pulumix.Output[*int] {
	value := pulumix.Apply[MatchmakingConfiguration](o, func(v MatchmakingConfiguration) pulumix.Output[*int] { return v.AdditionalPlayerCount })
	return pulumix.Flatten[*int, pulumix.Output[*int]](value)
}

// Matchmaking Configuration ARN.
func (o MatchmakingConfigurationOutput) Arn() pulumix.Output[string] {
	value := pulumix.Apply[MatchmakingConfiguration](o, func(v MatchmakingConfiguration) pulumix.Output[string] { return v.Arn })
	return pulumix.Flatten[string, pulumix.Output[string]](value)
}

// The method used to backfill game sessions that are created with this matchmaking configuration.
func (o MatchmakingConfigurationOutput) BackfillMode() pulumix.Output[*string] {
	value := pulumix.Apply[MatchmakingConfiguration](o, func(v MatchmakingConfiguration) pulumix.Output[*string] { return v.BackfillMode })
	return pulumix.Flatten[*string, pulumix.Output[*string]](value)
}

// The time when the Matchmaking Configuration was created.
func (o MatchmakingConfigurationOutput) CreationTime() pulumix.Output[string] {
	value := pulumix.Apply[MatchmakingConfiguration](o, func(v MatchmakingConfiguration) pulumix.Output[string] { return v.CreationTime })
	return pulumix.Flatten[string, pulumix.Output[string]](value)
}

// Information to be added to all events related to this matchmaking configuration.
func (o MatchmakingConfigurationOutput) CustomEventData() pulumix.Output[*string] {
	value := pulumix.Apply[MatchmakingConfiguration](o, func(v MatchmakingConfiguration) pulumix.Output[*string] { return v.CustomEventData })
	return pulumix.Flatten[*string, pulumix.Output[*string]](value)
}

// A human-readable description of the matchmaking configuration.
func (o MatchmakingConfigurationOutput) Description() pulumix.Output[*string] {
	value := pulumix.Apply[MatchmakingConfiguration](o, func(v MatchmakingConfiguration) pulumix.Output[*string] { return v.Description })
	return pulumix.Flatten[*string, pulumix.Output[*string]](value)
}

// Indicates whether this matchmaking configuration is being used with GameLift hosting or as a standalone matchmaking solution.
func (o MatchmakingConfigurationOutput) FlexMatchMode() pulumix.Output[string] {
	value := pulumix.Apply[MatchmakingConfiguration](o, func(v MatchmakingConfiguration) pulumix.Output[string] { return v.FlexMatchMode })
	return pulumix.Flatten[string, pulumix.Output[string]](value)
}

// One or more custom game properties. See below.
func (o MatchmakingConfigurationOutput) GameProperties() pulumix.GArrayOutput[MatchmakingConfigurationGameProperty, MatchmakingConfigurationGamePropertyOutput] {
	value := pulumix.Apply[MatchmakingConfiguration](o, func(v MatchmakingConfiguration) pulumix.GArrayOutput[MatchmakingConfigurationGameProperty, MatchmakingConfigurationGamePropertyOutput] {
		return v.GameProperties
	})
	unwrapped := pulumix.Flatten[[]MatchmakingConfigurationGameProperty, pulumix.GArrayOutput[MatchmakingConfigurationGameProperty, MatchmakingConfigurationGamePropertyOutput]](value)
	return pulumix.GArrayOutput[MatchmakingConfigurationGameProperty, MatchmakingConfigurationGamePropertyOutput]{OutputState: unwrapped.OutputState}
}

// A set of custom game session properties.
func (o MatchmakingConfigurationOutput) GameSessionData() pulumix.Output[*string] {
	value := pulumix.Apply[MatchmakingConfiguration](o, func(v MatchmakingConfiguration) pulumix.Output[*string] { return v.GameSessionData })
	return pulumix.Flatten[*string, pulumix.Output[*string]](value)
}

// The ARNs of the GameLift game session queue resources.
func (o MatchmakingConfigurationOutput) GameSessionQueueArns() pulumix.ArrayOutput[string] {
	value := pulumix.Apply[MatchmakingConfiguration](o, func(v MatchmakingConfiguration) pulumix.ArrayOutput[string] { return v.GameSessionQueueArns })
	unwrapped := pulumix.Flatten[[]string, pulumix.ArrayOutput[string]](value)
	return pulumix.ArrayOutput[string]{OutputState: unwrapped.OutputState}
}

// Name of the matchmaking configuration
func (o MatchmakingConfigurationOutput) Name() pulumix.Output[string] {
	value := pulumix.Apply[MatchmakingConfiguration](o, func(v MatchmakingConfiguration) pulumix.Output[string] { return v.Name })
	return pulumix.Flatten[string, pulumix.Output[string]](value)
}

// An SNS topic ARN that is set up to receive matchmaking notifications.
func (o MatchmakingConfigurationOutput) NotificationTarget() pulumix.Output[*string] {
	value := pulumix.Apply[MatchmakingConfiguration](o, func(v MatchmakingConfiguration) pulumix.Output[*string] { return v.NotificationTarget })
	return pulumix.Flatten[*string, pulumix.Output[*string]](value)
}

// The maximum duration, in seconds, that a matchmaking ticket can remain in process before timing out.
func (o MatchmakingConfigurationOutput) RequestTimeoutSeconds() pulumix.Output[int] {
	value := pulumix.Apply[MatchmakingConfiguration](o, func(v MatchmakingConfiguration) pulumix.Output[int] { return v.RequestTimeoutSeconds })
	return pulumix.Flatten[int, pulumix.Output[int]](value)
}

func (o MatchmakingConfigurationOutput) RuleSetArn() pulumix.Output[string] {
	value := pulumix.Apply[MatchmakingConfiguration](o, func(v MatchmakingConfiguration) pulumix.Output[string] { return v.RuleSetArn })
	return pulumix.Flatten[string, pulumix.Output[string]](value)
}

// A rule set names for the matchmaking rule set to use with this configuration.
func (o MatchmakingConfigurationOutput) RuleSetName() pulumix.Output[string] {
	value := pulumix.Apply[MatchmakingConfiguration](o, func(v MatchmakingConfiguration) pulumix.Output[string] { return v.RuleSetName })
	return pulumix.Flatten[string, pulumix.Output[string]](value)
}

// Key-value map of resource tags. .If configured with a provider `defaultTags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
func (o MatchmakingConfigurationOutput) Tags() pulumix.MapOutput[string] {
	value := pulumix.Apply[MatchmakingConfiguration](o, func(v MatchmakingConfiguration) pulumix.MapOutput[string] { return v.Tags })
	unwrapped := pulumix.Flatten[map[string]string, pulumix.MapOutput[string]](value)
	return pulumix.MapOutput[string]{OutputState: unwrapped.OutputState}
}

// A map of tags assigned to the resource, including those inherited from the provider `defaultTags` configuration block.
func (o MatchmakingConfigurationOutput) TagsAll() pulumix.MapOutput[string] {
	value := pulumix.Apply[MatchmakingConfiguration](o, func(v MatchmakingConfiguration) pulumix.MapOutput[string] { return v.TagsAll })
	unwrapped := pulumix.Flatten[map[string]string, pulumix.MapOutput[string]](value)
	return pulumix.MapOutput[string]{OutputState: unwrapped.OutputState}
}

func init() {
	pulumi.RegisterOutputType(MatchmakingConfigurationOutput{})
}
