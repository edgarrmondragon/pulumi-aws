// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package networkmanager

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi-aws/sdk/v6/go/aws/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumix"
)

var _ = internal.GetEnvOrDefault

type ConnectAttachmentOptions struct {
	Protocol *string `pulumi:"protocol"`
}

type ConnectAttachmentOptionsArgs struct {
	Protocol pulumix.Input[*string] `pulumi:"protocol"`
}

func (ConnectAttachmentOptionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ConnectAttachmentOptions)(nil)).Elem()
}

func (i ConnectAttachmentOptionsArgs) ToConnectAttachmentOptionsOutput() ConnectAttachmentOptionsOutput {
	return i.ToConnectAttachmentOptionsOutputWithContext(context.Background())
}

func (i ConnectAttachmentOptionsArgs) ToConnectAttachmentOptionsOutputWithContext(ctx context.Context) ConnectAttachmentOptionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConnectAttachmentOptionsOutput)
}

func (i *ConnectAttachmentOptionsArgs) ToOutput(ctx context.Context) pulumix.Output[*ConnectAttachmentOptionsArgs] {
	return pulumix.Val(i)
}

type ConnectAttachmentOptionsOutput struct{ *pulumi.OutputState }

func (ConnectAttachmentOptionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ConnectAttachmentOptions)(nil)).Elem()
}

func (o ConnectAttachmentOptionsOutput) ToConnectAttachmentOptionsOutput() ConnectAttachmentOptionsOutput {
	return o
}

func (o ConnectAttachmentOptionsOutput) ToConnectAttachmentOptionsOutputWithContext(ctx context.Context) ConnectAttachmentOptionsOutput {
	return o
}

func (o ConnectAttachmentOptionsOutput) ToOutput(ctx context.Context) pulumix.Output[ConnectAttachmentOptions] {
	return pulumix.Output[ConnectAttachmentOptions]{
		OutputState: o.OutputState,
	}
}

func (o ConnectAttachmentOptionsOutput) Protocol() pulumix.Output[*string] {
	return pulumix.Apply[ConnectAttachmentOptions](o, func(v ConnectAttachmentOptions) *string { return v.Protocol })
}

type ConnectPeerBgpOptions struct {
	PeerAsn *int `pulumi:"peerAsn"`
}

type ConnectPeerBgpOptionsArgs struct {
	PeerAsn pulumix.Input[*int] `pulumi:"peerAsn"`
}

func (ConnectPeerBgpOptionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ConnectPeerBgpOptions)(nil)).Elem()
}

func (i ConnectPeerBgpOptionsArgs) ToConnectPeerBgpOptionsOutput() ConnectPeerBgpOptionsOutput {
	return i.ToConnectPeerBgpOptionsOutputWithContext(context.Background())
}

func (i ConnectPeerBgpOptionsArgs) ToConnectPeerBgpOptionsOutputWithContext(ctx context.Context) ConnectPeerBgpOptionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConnectPeerBgpOptionsOutput)
}

func (i *ConnectPeerBgpOptionsArgs) ToOutput(ctx context.Context) pulumix.Output[*ConnectPeerBgpOptionsArgs] {
	return pulumix.Val(i)
}

type ConnectPeerBgpOptionsOutput struct{ *pulumi.OutputState }

func (ConnectPeerBgpOptionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ConnectPeerBgpOptions)(nil)).Elem()
}

func (o ConnectPeerBgpOptionsOutput) ToConnectPeerBgpOptionsOutput() ConnectPeerBgpOptionsOutput {
	return o
}

func (o ConnectPeerBgpOptionsOutput) ToConnectPeerBgpOptionsOutputWithContext(ctx context.Context) ConnectPeerBgpOptionsOutput {
	return o
}

func (o ConnectPeerBgpOptionsOutput) ToOutput(ctx context.Context) pulumix.Output[ConnectPeerBgpOptions] {
	return pulumix.Output[ConnectPeerBgpOptions]{
		OutputState: o.OutputState,
	}
}

func (o ConnectPeerBgpOptionsOutput) PeerAsn() pulumix.Output[*int] {
	return pulumix.Apply[ConnectPeerBgpOptions](o, func(v ConnectPeerBgpOptions) *int { return v.PeerAsn })
}

type ConnectPeerConfiguration struct {
	BgpConfigurations []ConnectPeerConfigurationBgpConfiguration `pulumi:"bgpConfigurations"`
	// A Connect peer core network address.
	CoreNetworkAddress *string `pulumi:"coreNetworkAddress"`
	// The inside IP addresses used for BGP peering.
	InsideCidrBlocks []string `pulumi:"insideCidrBlocks"`
	// The Connect peer address.
	//
	// The following arguments are optional:
	PeerAddress *string `pulumi:"peerAddress"`
	Protocol    *string `pulumi:"protocol"`
}

type ConnectPeerConfigurationArgs struct {
	BgpConfigurations pulumix.Input[[]*ConnectPeerConfigurationBgpConfigurationArgs] `pulumi:"bgpConfigurations"`
	// A Connect peer core network address.
	CoreNetworkAddress pulumix.Input[*string] `pulumi:"coreNetworkAddress"`
	// The inside IP addresses used for BGP peering.
	InsideCidrBlocks pulumix.Input[[]string] `pulumi:"insideCidrBlocks"`
	// The Connect peer address.
	//
	// The following arguments are optional:
	PeerAddress pulumix.Input[*string] `pulumi:"peerAddress"`
	Protocol    pulumix.Input[*string] `pulumi:"protocol"`
}

func (ConnectPeerConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ConnectPeerConfiguration)(nil)).Elem()
}

func (i ConnectPeerConfigurationArgs) ToConnectPeerConfigurationOutput() ConnectPeerConfigurationOutput {
	return i.ToConnectPeerConfigurationOutputWithContext(context.Background())
}

func (i ConnectPeerConfigurationArgs) ToConnectPeerConfigurationOutputWithContext(ctx context.Context) ConnectPeerConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConnectPeerConfigurationOutput)
}

func (i *ConnectPeerConfigurationArgs) ToOutput(ctx context.Context) pulumix.Output[*ConnectPeerConfigurationArgs] {
	return pulumix.Val(i)
}

type ConnectPeerConfigurationOutput struct{ *pulumi.OutputState }

func (ConnectPeerConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ConnectPeerConfiguration)(nil)).Elem()
}

func (o ConnectPeerConfigurationOutput) ToConnectPeerConfigurationOutput() ConnectPeerConfigurationOutput {
	return o
}

func (o ConnectPeerConfigurationOutput) ToConnectPeerConfigurationOutputWithContext(ctx context.Context) ConnectPeerConfigurationOutput {
	return o
}

func (o ConnectPeerConfigurationOutput) ToOutput(ctx context.Context) pulumix.Output[ConnectPeerConfiguration] {
	return pulumix.Output[ConnectPeerConfiguration]{
		OutputState: o.OutputState,
	}
}

func (o ConnectPeerConfigurationOutput) BgpConfigurations() pulumix.GArrayOutput[ConnectPeerConfigurationBgpConfiguration, ConnectPeerConfigurationBgpConfigurationOutput] {
	value := pulumix.Apply[ConnectPeerConfiguration](o, func(v ConnectPeerConfiguration) []ConnectPeerConfigurationBgpConfiguration {
		return v.BgpConfigurations
	})
	return pulumix.GArrayOutput[ConnectPeerConfigurationBgpConfiguration, ConnectPeerConfigurationBgpConfigurationOutput]{OutputState: value.OutputState}
}

// A Connect peer core network address.
func (o ConnectPeerConfigurationOutput) CoreNetworkAddress() pulumix.Output[*string] {
	return pulumix.Apply[ConnectPeerConfiguration](o, func(v ConnectPeerConfiguration) *string { return v.CoreNetworkAddress })
}

// The inside IP addresses used for BGP peering.
func (o ConnectPeerConfigurationOutput) InsideCidrBlocks() pulumix.ArrayOutput[string] {
	value := pulumix.Apply[ConnectPeerConfiguration](o, func(v ConnectPeerConfiguration) []string { return v.InsideCidrBlocks })
	return pulumix.ArrayOutput[string]{OutputState: value.OutputState}
}

// The Connect peer address.
//
// The following arguments are optional:
func (o ConnectPeerConfigurationOutput) PeerAddress() pulumix.Output[*string] {
	return pulumix.Apply[ConnectPeerConfiguration](o, func(v ConnectPeerConfiguration) *string { return v.PeerAddress })
}

func (o ConnectPeerConfigurationOutput) Protocol() pulumix.Output[*string] {
	return pulumix.Apply[ConnectPeerConfiguration](o, func(v ConnectPeerConfiguration) *string { return v.Protocol })
}

type ConnectPeerConfigurationBgpConfiguration struct {
	// A Connect peer core network address.
	CoreNetworkAddress *string `pulumi:"coreNetworkAddress"`
	CoreNetworkAsn     *int    `pulumi:"coreNetworkAsn"`
	// The Connect peer address.
	//
	// The following arguments are optional:
	PeerAddress *string `pulumi:"peerAddress"`
	PeerAsn     *int    `pulumi:"peerAsn"`
}

type ConnectPeerConfigurationBgpConfigurationArgs struct {
	// A Connect peer core network address.
	CoreNetworkAddress pulumix.Input[*string] `pulumi:"coreNetworkAddress"`
	CoreNetworkAsn     pulumix.Input[*int]    `pulumi:"coreNetworkAsn"`
	// The Connect peer address.
	//
	// The following arguments are optional:
	PeerAddress pulumix.Input[*string] `pulumi:"peerAddress"`
	PeerAsn     pulumix.Input[*int]    `pulumi:"peerAsn"`
}

func (ConnectPeerConfigurationBgpConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ConnectPeerConfigurationBgpConfiguration)(nil)).Elem()
}

func (i ConnectPeerConfigurationBgpConfigurationArgs) ToConnectPeerConfigurationBgpConfigurationOutput() ConnectPeerConfigurationBgpConfigurationOutput {
	return i.ToConnectPeerConfigurationBgpConfigurationOutputWithContext(context.Background())
}

func (i ConnectPeerConfigurationBgpConfigurationArgs) ToConnectPeerConfigurationBgpConfigurationOutputWithContext(ctx context.Context) ConnectPeerConfigurationBgpConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConnectPeerConfigurationBgpConfigurationOutput)
}

func (i *ConnectPeerConfigurationBgpConfigurationArgs) ToOutput(ctx context.Context) pulumix.Output[*ConnectPeerConfigurationBgpConfigurationArgs] {
	return pulumix.Val(i)
}

type ConnectPeerConfigurationBgpConfigurationOutput struct{ *pulumi.OutputState }

func (ConnectPeerConfigurationBgpConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ConnectPeerConfigurationBgpConfiguration)(nil)).Elem()
}

func (o ConnectPeerConfigurationBgpConfigurationOutput) ToConnectPeerConfigurationBgpConfigurationOutput() ConnectPeerConfigurationBgpConfigurationOutput {
	return o
}

func (o ConnectPeerConfigurationBgpConfigurationOutput) ToConnectPeerConfigurationBgpConfigurationOutputWithContext(ctx context.Context) ConnectPeerConfigurationBgpConfigurationOutput {
	return o
}

func (o ConnectPeerConfigurationBgpConfigurationOutput) ToOutput(ctx context.Context) pulumix.Output[ConnectPeerConfigurationBgpConfiguration] {
	return pulumix.Output[ConnectPeerConfigurationBgpConfiguration]{
		OutputState: o.OutputState,
	}
}

// A Connect peer core network address.
func (o ConnectPeerConfigurationBgpConfigurationOutput) CoreNetworkAddress() pulumix.Output[*string] {
	return pulumix.Apply[ConnectPeerConfigurationBgpConfiguration](o, func(v ConnectPeerConfigurationBgpConfiguration) *string { return v.CoreNetworkAddress })
}

func (o ConnectPeerConfigurationBgpConfigurationOutput) CoreNetworkAsn() pulumix.Output[*int] {
	return pulumix.Apply[ConnectPeerConfigurationBgpConfiguration](o, func(v ConnectPeerConfigurationBgpConfiguration) *int { return v.CoreNetworkAsn })
}

// The Connect peer address.
//
// The following arguments are optional:
func (o ConnectPeerConfigurationBgpConfigurationOutput) PeerAddress() pulumix.Output[*string] {
	return pulumix.Apply[ConnectPeerConfigurationBgpConfiguration](o, func(v ConnectPeerConfigurationBgpConfiguration) *string { return v.PeerAddress })
}

func (o ConnectPeerConfigurationBgpConfigurationOutput) PeerAsn() pulumix.Output[*int] {
	return pulumix.Apply[ConnectPeerConfigurationBgpConfiguration](o, func(v ConnectPeerConfigurationBgpConfiguration) *int { return v.PeerAsn })
}

type CoreNetworkEdge struct {
	// ASN of a core network edge.
	Asn *int `pulumi:"asn"`
	// Region where a core network edge is located.
	EdgeLocation *string `pulumi:"edgeLocation"`
	// Inside IP addresses used for core network edges.
	InsideCidrBlocks []string `pulumi:"insideCidrBlocks"`
}

type CoreNetworkEdgeArgs struct {
	// ASN of a core network edge.
	Asn pulumix.Input[*int] `pulumi:"asn"`
	// Region where a core network edge is located.
	EdgeLocation pulumix.Input[*string] `pulumi:"edgeLocation"`
	// Inside IP addresses used for core network edges.
	InsideCidrBlocks pulumix.Input[[]string] `pulumi:"insideCidrBlocks"`
}

func (CoreNetworkEdgeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CoreNetworkEdge)(nil)).Elem()
}

func (i CoreNetworkEdgeArgs) ToCoreNetworkEdgeOutput() CoreNetworkEdgeOutput {
	return i.ToCoreNetworkEdgeOutputWithContext(context.Background())
}

func (i CoreNetworkEdgeArgs) ToCoreNetworkEdgeOutputWithContext(ctx context.Context) CoreNetworkEdgeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CoreNetworkEdgeOutput)
}

func (i *CoreNetworkEdgeArgs) ToOutput(ctx context.Context) pulumix.Output[*CoreNetworkEdgeArgs] {
	return pulumix.Val(i)
}

type CoreNetworkEdgeOutput struct{ *pulumi.OutputState }

func (CoreNetworkEdgeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CoreNetworkEdge)(nil)).Elem()
}

func (o CoreNetworkEdgeOutput) ToCoreNetworkEdgeOutput() CoreNetworkEdgeOutput {
	return o
}

func (o CoreNetworkEdgeOutput) ToCoreNetworkEdgeOutputWithContext(ctx context.Context) CoreNetworkEdgeOutput {
	return o
}

func (o CoreNetworkEdgeOutput) ToOutput(ctx context.Context) pulumix.Output[CoreNetworkEdge] {
	return pulumix.Output[CoreNetworkEdge]{
		OutputState: o.OutputState,
	}
}

// ASN of a core network edge.
func (o CoreNetworkEdgeOutput) Asn() pulumix.Output[*int] {
	return pulumix.Apply[CoreNetworkEdge](o, func(v CoreNetworkEdge) *int { return v.Asn })
}

// Region where a core network edge is located.
func (o CoreNetworkEdgeOutput) EdgeLocation() pulumix.Output[*string] {
	return pulumix.Apply[CoreNetworkEdge](o, func(v CoreNetworkEdge) *string { return v.EdgeLocation })
}

// Inside IP addresses used for core network edges.
func (o CoreNetworkEdgeOutput) InsideCidrBlocks() pulumix.ArrayOutput[string] {
	value := pulumix.Apply[CoreNetworkEdge](o, func(v CoreNetworkEdge) []string { return v.InsideCidrBlocks })
	return pulumix.ArrayOutput[string]{OutputState: value.OutputState}
}

type CoreNetworkSegment struct {
	// Regions where the edges are located.
	EdgeLocations []string `pulumi:"edgeLocations"`
	// Name of a core network segment.
	Name *string `pulumi:"name"`
	// Shared segments of a core network.
	SharedSegments []string `pulumi:"sharedSegments"`
}

type CoreNetworkSegmentArgs struct {
	// Regions where the edges are located.
	EdgeLocations pulumix.Input[[]string] `pulumi:"edgeLocations"`
	// Name of a core network segment.
	Name pulumix.Input[*string] `pulumi:"name"`
	// Shared segments of a core network.
	SharedSegments pulumix.Input[[]string] `pulumi:"sharedSegments"`
}

func (CoreNetworkSegmentArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CoreNetworkSegment)(nil)).Elem()
}

func (i CoreNetworkSegmentArgs) ToCoreNetworkSegmentOutput() CoreNetworkSegmentOutput {
	return i.ToCoreNetworkSegmentOutputWithContext(context.Background())
}

func (i CoreNetworkSegmentArgs) ToCoreNetworkSegmentOutputWithContext(ctx context.Context) CoreNetworkSegmentOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CoreNetworkSegmentOutput)
}

func (i *CoreNetworkSegmentArgs) ToOutput(ctx context.Context) pulumix.Output[*CoreNetworkSegmentArgs] {
	return pulumix.Val(i)
}

type CoreNetworkSegmentOutput struct{ *pulumi.OutputState }

func (CoreNetworkSegmentOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CoreNetworkSegment)(nil)).Elem()
}

func (o CoreNetworkSegmentOutput) ToCoreNetworkSegmentOutput() CoreNetworkSegmentOutput {
	return o
}

func (o CoreNetworkSegmentOutput) ToCoreNetworkSegmentOutputWithContext(ctx context.Context) CoreNetworkSegmentOutput {
	return o
}

func (o CoreNetworkSegmentOutput) ToOutput(ctx context.Context) pulumix.Output[CoreNetworkSegment] {
	return pulumix.Output[CoreNetworkSegment]{
		OutputState: o.OutputState,
	}
}

// Regions where the edges are located.
func (o CoreNetworkSegmentOutput) EdgeLocations() pulumix.ArrayOutput[string] {
	value := pulumix.Apply[CoreNetworkSegment](o, func(v CoreNetworkSegment) []string { return v.EdgeLocations })
	return pulumix.ArrayOutput[string]{OutputState: value.OutputState}
}

// Name of a core network segment.
func (o CoreNetworkSegmentOutput) Name() pulumix.Output[*string] {
	return pulumix.Apply[CoreNetworkSegment](o, func(v CoreNetworkSegment) *string { return v.Name })
}

// Shared segments of a core network.
func (o CoreNetworkSegmentOutput) SharedSegments() pulumix.ArrayOutput[string] {
	value := pulumix.Apply[CoreNetworkSegment](o, func(v CoreNetworkSegment) []string { return v.SharedSegments })
	return pulumix.ArrayOutput[string]{OutputState: value.OutputState}
}

type DeviceAwsLocation struct {
	// The Amazon Resource Name (ARN) of the subnet that the device is located in.
	SubnetArn *string `pulumi:"subnetArn"`
	// The Zone that the device is located in. Specify the ID of an Availability Zone, Local Zone, Wavelength Zone, or an Outpost.
	Zone *string `pulumi:"zone"`
}

type DeviceAwsLocationArgs struct {
	// The Amazon Resource Name (ARN) of the subnet that the device is located in.
	SubnetArn pulumix.Input[*string] `pulumi:"subnetArn"`
	// The Zone that the device is located in. Specify the ID of an Availability Zone, Local Zone, Wavelength Zone, or an Outpost.
	Zone pulumix.Input[*string] `pulumi:"zone"`
}

func (DeviceAwsLocationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceAwsLocation)(nil)).Elem()
}

func (i DeviceAwsLocationArgs) ToDeviceAwsLocationOutput() DeviceAwsLocationOutput {
	return i.ToDeviceAwsLocationOutputWithContext(context.Background())
}

func (i DeviceAwsLocationArgs) ToDeviceAwsLocationOutputWithContext(ctx context.Context) DeviceAwsLocationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceAwsLocationOutput)
}

func (i *DeviceAwsLocationArgs) ToOutput(ctx context.Context) pulumix.Output[*DeviceAwsLocationArgs] {
	return pulumix.Val(i)
}

type DeviceAwsLocationOutput struct{ *pulumi.OutputState }

func (DeviceAwsLocationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceAwsLocation)(nil)).Elem()
}

func (o DeviceAwsLocationOutput) ToDeviceAwsLocationOutput() DeviceAwsLocationOutput {
	return o
}

func (o DeviceAwsLocationOutput) ToDeviceAwsLocationOutputWithContext(ctx context.Context) DeviceAwsLocationOutput {
	return o
}

func (o DeviceAwsLocationOutput) ToOutput(ctx context.Context) pulumix.Output[DeviceAwsLocation] {
	return pulumix.Output[DeviceAwsLocation]{
		OutputState: o.OutputState,
	}
}

// The Amazon Resource Name (ARN) of the subnet that the device is located in.
func (o DeviceAwsLocationOutput) SubnetArn() pulumix.Output[*string] {
	return pulumix.Apply[DeviceAwsLocation](o, func(v DeviceAwsLocation) *string { return v.SubnetArn })
}

// The Zone that the device is located in. Specify the ID of an Availability Zone, Local Zone, Wavelength Zone, or an Outpost.
func (o DeviceAwsLocationOutput) Zone() pulumix.Output[*string] {
	return pulumix.Apply[DeviceAwsLocation](o, func(v DeviceAwsLocation) *string { return v.Zone })
}

type DeviceLocation struct {
	// The physical address.
	Address *string `pulumi:"address"`
	// The latitude.
	Latitude *string `pulumi:"latitude"`
	// The longitude.
	Longitude *string `pulumi:"longitude"`
}

type DeviceLocationArgs struct {
	// The physical address.
	Address pulumix.Input[*string] `pulumi:"address"`
	// The latitude.
	Latitude pulumix.Input[*string] `pulumi:"latitude"`
	// The longitude.
	Longitude pulumix.Input[*string] `pulumi:"longitude"`
}

func (DeviceLocationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceLocation)(nil)).Elem()
}

func (i DeviceLocationArgs) ToDeviceLocationOutput() DeviceLocationOutput {
	return i.ToDeviceLocationOutputWithContext(context.Background())
}

func (i DeviceLocationArgs) ToDeviceLocationOutputWithContext(ctx context.Context) DeviceLocationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeviceLocationOutput)
}

func (i *DeviceLocationArgs) ToOutput(ctx context.Context) pulumix.Output[*DeviceLocationArgs] {
	return pulumix.Val(i)
}

type DeviceLocationOutput struct{ *pulumi.OutputState }

func (DeviceLocationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeviceLocation)(nil)).Elem()
}

func (o DeviceLocationOutput) ToDeviceLocationOutput() DeviceLocationOutput {
	return o
}

func (o DeviceLocationOutput) ToDeviceLocationOutputWithContext(ctx context.Context) DeviceLocationOutput {
	return o
}

func (o DeviceLocationOutput) ToOutput(ctx context.Context) pulumix.Output[DeviceLocation] {
	return pulumix.Output[DeviceLocation]{
		OutputState: o.OutputState,
	}
}

// The physical address.
func (o DeviceLocationOutput) Address() pulumix.Output[*string] {
	return pulumix.Apply[DeviceLocation](o, func(v DeviceLocation) *string { return v.Address })
}

// The latitude.
func (o DeviceLocationOutput) Latitude() pulumix.Output[*string] {
	return pulumix.Apply[DeviceLocation](o, func(v DeviceLocation) *string { return v.Latitude })
}

// The longitude.
func (o DeviceLocationOutput) Longitude() pulumix.Output[*string] {
	return pulumix.Apply[DeviceLocation](o, func(v DeviceLocation) *string { return v.Longitude })
}

type LinkBandwidth struct {
	// Download speed in Mbps.
	DownloadSpeed *int `pulumi:"downloadSpeed"`
	// Upload speed in Mbps.
	UploadSpeed *int `pulumi:"uploadSpeed"`
}

type LinkBandwidthArgs struct {
	// Download speed in Mbps.
	DownloadSpeed pulumix.Input[*int] `pulumi:"downloadSpeed"`
	// Upload speed in Mbps.
	UploadSpeed pulumix.Input[*int] `pulumi:"uploadSpeed"`
}

func (LinkBandwidthArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LinkBandwidth)(nil)).Elem()
}

func (i LinkBandwidthArgs) ToLinkBandwidthOutput() LinkBandwidthOutput {
	return i.ToLinkBandwidthOutputWithContext(context.Background())
}

func (i LinkBandwidthArgs) ToLinkBandwidthOutputWithContext(ctx context.Context) LinkBandwidthOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LinkBandwidthOutput)
}

func (i *LinkBandwidthArgs) ToOutput(ctx context.Context) pulumix.Output[*LinkBandwidthArgs] {
	return pulumix.Val(i)
}

type LinkBandwidthOutput struct{ *pulumi.OutputState }

func (LinkBandwidthOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LinkBandwidth)(nil)).Elem()
}

func (o LinkBandwidthOutput) ToLinkBandwidthOutput() LinkBandwidthOutput {
	return o
}

func (o LinkBandwidthOutput) ToLinkBandwidthOutputWithContext(ctx context.Context) LinkBandwidthOutput {
	return o
}

func (o LinkBandwidthOutput) ToOutput(ctx context.Context) pulumix.Output[LinkBandwidth] {
	return pulumix.Output[LinkBandwidth]{
		OutputState: o.OutputState,
	}
}

// Download speed in Mbps.
func (o LinkBandwidthOutput) DownloadSpeed() pulumix.Output[*int] {
	return pulumix.Apply[LinkBandwidth](o, func(v LinkBandwidth) *int { return v.DownloadSpeed })
}

// Upload speed in Mbps.
func (o LinkBandwidthOutput) UploadSpeed() pulumix.Output[*int] {
	return pulumix.Apply[LinkBandwidth](o, func(v LinkBandwidth) *int { return v.UploadSpeed })
}

type SiteLocation struct {
	// Address of the location.
	Address *string `pulumi:"address"`
	// Latitude of the location.
	Latitude *string `pulumi:"latitude"`
	// Longitude of the location.
	Longitude *string `pulumi:"longitude"`
}

type SiteLocationArgs struct {
	// Address of the location.
	Address pulumix.Input[*string] `pulumi:"address"`
	// Latitude of the location.
	Latitude pulumix.Input[*string] `pulumi:"latitude"`
	// Longitude of the location.
	Longitude pulumix.Input[*string] `pulumi:"longitude"`
}

func (SiteLocationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SiteLocation)(nil)).Elem()
}

func (i SiteLocationArgs) ToSiteLocationOutput() SiteLocationOutput {
	return i.ToSiteLocationOutputWithContext(context.Background())
}

func (i SiteLocationArgs) ToSiteLocationOutputWithContext(ctx context.Context) SiteLocationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SiteLocationOutput)
}

func (i *SiteLocationArgs) ToOutput(ctx context.Context) pulumix.Output[*SiteLocationArgs] {
	return pulumix.Val(i)
}

type SiteLocationOutput struct{ *pulumi.OutputState }

func (SiteLocationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SiteLocation)(nil)).Elem()
}

func (o SiteLocationOutput) ToSiteLocationOutput() SiteLocationOutput {
	return o
}

func (o SiteLocationOutput) ToSiteLocationOutputWithContext(ctx context.Context) SiteLocationOutput {
	return o
}

func (o SiteLocationOutput) ToOutput(ctx context.Context) pulumix.Output[SiteLocation] {
	return pulumix.Output[SiteLocation]{
		OutputState: o.OutputState,
	}
}

// Address of the location.
func (o SiteLocationOutput) Address() pulumix.Output[*string] {
	return pulumix.Apply[SiteLocation](o, func(v SiteLocation) *string { return v.Address })
}

// Latitude of the location.
func (o SiteLocationOutput) Latitude() pulumix.Output[*string] {
	return pulumix.Apply[SiteLocation](o, func(v SiteLocation) *string { return v.Latitude })
}

// Longitude of the location.
func (o SiteLocationOutput) Longitude() pulumix.Output[*string] {
	return pulumix.Apply[SiteLocation](o, func(v SiteLocation) *string { return v.Longitude })
}

type VpcAttachmentOptions struct {
	// Indicates whether appliance mode is supported. If enabled, traffic flow between a source and destination use the same Availability Zone for the VPC attachment for the lifetime of that flow.
	ApplianceModeSupport *bool `pulumi:"applianceModeSupport"`
	// Indicates whether IPv6 is supported.
	Ipv6Support *bool `pulumi:"ipv6Support"`
}

type VpcAttachmentOptionsArgs struct {
	// Indicates whether appliance mode is supported. If enabled, traffic flow between a source and destination use the same Availability Zone for the VPC attachment for the lifetime of that flow.
	ApplianceModeSupport pulumix.Input[*bool] `pulumi:"applianceModeSupport"`
	// Indicates whether IPv6 is supported.
	Ipv6Support pulumix.Input[*bool] `pulumi:"ipv6Support"`
}

func (VpcAttachmentOptionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*VpcAttachmentOptions)(nil)).Elem()
}

func (i VpcAttachmentOptionsArgs) ToVpcAttachmentOptionsOutput() VpcAttachmentOptionsOutput {
	return i.ToVpcAttachmentOptionsOutputWithContext(context.Background())
}

func (i VpcAttachmentOptionsArgs) ToVpcAttachmentOptionsOutputWithContext(ctx context.Context) VpcAttachmentOptionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VpcAttachmentOptionsOutput)
}

func (i *VpcAttachmentOptionsArgs) ToOutput(ctx context.Context) pulumix.Output[*VpcAttachmentOptionsArgs] {
	return pulumix.Val(i)
}

type VpcAttachmentOptionsOutput struct{ *pulumi.OutputState }

func (VpcAttachmentOptionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VpcAttachmentOptions)(nil)).Elem()
}

func (o VpcAttachmentOptionsOutput) ToVpcAttachmentOptionsOutput() VpcAttachmentOptionsOutput {
	return o
}

func (o VpcAttachmentOptionsOutput) ToVpcAttachmentOptionsOutputWithContext(ctx context.Context) VpcAttachmentOptionsOutput {
	return o
}

func (o VpcAttachmentOptionsOutput) ToOutput(ctx context.Context) pulumix.Output[VpcAttachmentOptions] {
	return pulumix.Output[VpcAttachmentOptions]{
		OutputState: o.OutputState,
	}
}

// Indicates whether appliance mode is supported. If enabled, traffic flow between a source and destination use the same Availability Zone for the VPC attachment for the lifetime of that flow.
func (o VpcAttachmentOptionsOutput) ApplianceModeSupport() pulumix.Output[*bool] {
	return pulumix.Apply[VpcAttachmentOptions](o, func(v VpcAttachmentOptions) *bool { return v.ApplianceModeSupport })
}

// Indicates whether IPv6 is supported.
func (o VpcAttachmentOptionsOutput) Ipv6Support() pulumix.Output[*bool] {
	return pulumix.Apply[VpcAttachmentOptions](o, func(v VpcAttachmentOptions) *bool { return v.Ipv6Support })
}

type GetCoreNetworkPolicyDocumentAttachmentPolicy struct {
	// Action to take when a condition is true. Detailed Below.
	Action GetCoreNetworkPolicyDocumentAttachmentPolicyAction `pulumi:"action"`
	// Valid values include `and` or `or`. This is a mandatory parameter only if you have more than one condition. The `conditionLogic` apply to all of the conditions for a rule, which also means nested conditions of `and` or `or` are not supported. Use `or` if you want to associate the attachment with the segment by either the segment name or attachment tag value, or by the chosen conditions. Use `and` if you want to associate the attachment with the segment by either the segment name or attachment tag value and by the chosen conditions. Detailed Below.
	ConditionLogic *string `pulumi:"conditionLogic"`
	// A block argument. Detailed Below.
	Conditions []GetCoreNetworkPolicyDocumentAttachmentPolicyCondition `pulumi:"conditions"`
	// A user-defined description that further helps identify the rule.
	Description *string `pulumi:"description"`
	// An integer from `1` to `65535` indicating the rule's order number. Rules are processed in order from the lowest numbered rule to the highest. Rules stop processing when a rule is matched. It's important to make sure that you number your rules in the exact order that you want them processed.
	RuleNumber int `pulumi:"ruleNumber"`
}

type GetCoreNetworkPolicyDocumentAttachmentPolicyArgs struct {
	// Action to take when a condition is true. Detailed Below.
	Action pulumix.Input[*GetCoreNetworkPolicyDocumentAttachmentPolicyActionArgs] `pulumi:"action"`
	// Valid values include `and` or `or`. This is a mandatory parameter only if you have more than one condition. The `conditionLogic` apply to all of the conditions for a rule, which also means nested conditions of `and` or `or` are not supported. Use `or` if you want to associate the attachment with the segment by either the segment name or attachment tag value, or by the chosen conditions. Use `and` if you want to associate the attachment with the segment by either the segment name or attachment tag value and by the chosen conditions. Detailed Below.
	ConditionLogic pulumix.Input[*string] `pulumi:"conditionLogic"`
	// A block argument. Detailed Below.
	Conditions pulumix.Input[[]*GetCoreNetworkPolicyDocumentAttachmentPolicyConditionArgs] `pulumi:"conditions"`
	// A user-defined description that further helps identify the rule.
	Description pulumix.Input[*string] `pulumi:"description"`
	// An integer from `1` to `65535` indicating the rule's order number. Rules are processed in order from the lowest numbered rule to the highest. Rules stop processing when a rule is matched. It's important to make sure that you number your rules in the exact order that you want them processed.
	RuleNumber pulumix.Input[int] `pulumi:"ruleNumber"`
}

func (GetCoreNetworkPolicyDocumentAttachmentPolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetCoreNetworkPolicyDocumentAttachmentPolicy)(nil)).Elem()
}

func (i GetCoreNetworkPolicyDocumentAttachmentPolicyArgs) ToGetCoreNetworkPolicyDocumentAttachmentPolicyOutput() GetCoreNetworkPolicyDocumentAttachmentPolicyOutput {
	return i.ToGetCoreNetworkPolicyDocumentAttachmentPolicyOutputWithContext(context.Background())
}

func (i GetCoreNetworkPolicyDocumentAttachmentPolicyArgs) ToGetCoreNetworkPolicyDocumentAttachmentPolicyOutputWithContext(ctx context.Context) GetCoreNetworkPolicyDocumentAttachmentPolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetCoreNetworkPolicyDocumentAttachmentPolicyOutput)
}

func (i *GetCoreNetworkPolicyDocumentAttachmentPolicyArgs) ToOutput(ctx context.Context) pulumix.Output[*GetCoreNetworkPolicyDocumentAttachmentPolicyArgs] {
	return pulumix.Val(i)
}

type GetCoreNetworkPolicyDocumentAttachmentPolicyOutput struct{ *pulumi.OutputState }

func (GetCoreNetworkPolicyDocumentAttachmentPolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetCoreNetworkPolicyDocumentAttachmentPolicy)(nil)).Elem()
}

func (o GetCoreNetworkPolicyDocumentAttachmentPolicyOutput) ToGetCoreNetworkPolicyDocumentAttachmentPolicyOutput() GetCoreNetworkPolicyDocumentAttachmentPolicyOutput {
	return o
}

func (o GetCoreNetworkPolicyDocumentAttachmentPolicyOutput) ToGetCoreNetworkPolicyDocumentAttachmentPolicyOutputWithContext(ctx context.Context) GetCoreNetworkPolicyDocumentAttachmentPolicyOutput {
	return o
}

func (o GetCoreNetworkPolicyDocumentAttachmentPolicyOutput) ToOutput(ctx context.Context) pulumix.Output[GetCoreNetworkPolicyDocumentAttachmentPolicy] {
	return pulumix.Output[GetCoreNetworkPolicyDocumentAttachmentPolicy]{
		OutputState: o.OutputState,
	}
}

// Action to take when a condition is true. Detailed Below.
func (o GetCoreNetworkPolicyDocumentAttachmentPolicyOutput) Action() pulumix.GPtrOutput[GetCoreNetworkPolicyDocumentAttachmentPolicyAction, GetCoreNetworkPolicyDocumentAttachmentPolicyActionOutput] {
	value := pulumix.Apply[GetCoreNetworkPolicyDocumentAttachmentPolicy](o, func(v GetCoreNetworkPolicyDocumentAttachmentPolicy) GetCoreNetworkPolicyDocumentAttachmentPolicyAction {
		return v.Action
	})
	return pulumix.GPtrOutput[GetCoreNetworkPolicyDocumentAttachmentPolicyAction, GetCoreNetworkPolicyDocumentAttachmentPolicyActionOutput]{OutputState: value.OutputState}
}

// Valid values include `and` or `or`. This is a mandatory parameter only if you have more than one condition. The `conditionLogic` apply to all of the conditions for a rule, which also means nested conditions of `and` or `or` are not supported. Use `or` if you want to associate the attachment with the segment by either the segment name or attachment tag value, or by the chosen conditions. Use `and` if you want to associate the attachment with the segment by either the segment name or attachment tag value and by the chosen conditions. Detailed Below.
func (o GetCoreNetworkPolicyDocumentAttachmentPolicyOutput) ConditionLogic() pulumix.Output[*string] {
	return pulumix.Apply[GetCoreNetworkPolicyDocumentAttachmentPolicy](o, func(v GetCoreNetworkPolicyDocumentAttachmentPolicy) *string { return v.ConditionLogic })
}

// A block argument. Detailed Below.
func (o GetCoreNetworkPolicyDocumentAttachmentPolicyOutput) Conditions() pulumix.GArrayOutput[GetCoreNetworkPolicyDocumentAttachmentPolicyCondition, GetCoreNetworkPolicyDocumentAttachmentPolicyConditionOutput] {
	value := pulumix.Apply[GetCoreNetworkPolicyDocumentAttachmentPolicy](o, func(v GetCoreNetworkPolicyDocumentAttachmentPolicy) []GetCoreNetworkPolicyDocumentAttachmentPolicyCondition {
		return v.Conditions
	})
	return pulumix.GArrayOutput[GetCoreNetworkPolicyDocumentAttachmentPolicyCondition, GetCoreNetworkPolicyDocumentAttachmentPolicyConditionOutput]{OutputState: value.OutputState}
}

// A user-defined description that further helps identify the rule.
func (o GetCoreNetworkPolicyDocumentAttachmentPolicyOutput) Description() pulumix.Output[*string] {
	return pulumix.Apply[GetCoreNetworkPolicyDocumentAttachmentPolicy](o, func(v GetCoreNetworkPolicyDocumentAttachmentPolicy) *string { return v.Description })
}

// An integer from `1` to `65535` indicating the rule's order number. Rules are processed in order from the lowest numbered rule to the highest. Rules stop processing when a rule is matched. It's important to make sure that you number your rules in the exact order that you want them processed.
func (o GetCoreNetworkPolicyDocumentAttachmentPolicyOutput) RuleNumber() pulumix.Output[int] {
	return pulumix.Apply[GetCoreNetworkPolicyDocumentAttachmentPolicy](o, func(v GetCoreNetworkPolicyDocumentAttachmentPolicy) int { return v.RuleNumber })
}

type GetCoreNetworkPolicyDocumentAttachmentPolicyAction struct {
	// Defines how a segment is mapped. Values can be `constant` or `tag`. `constant` statically defines the segment to associate the attachment to. `tag` uses the value of a tag to dynamically try to map to a segment.reference_policies_elements_condition_operators.html) to evaluate.
	AssociationMethod string `pulumi:"associationMethod"`
	// Determines if this mapping should override the segment value for `requireAttachmentAcceptance`. You can only set this to `true`, indicating that this setting applies only to segments that have `requireAttachmentAcceptance` set to `false`. If the segment already has the default `requireAttachmentAcceptance`, you can set this to inherit segment’s acceptance value.
	RequireAcceptance *bool `pulumi:"requireAcceptance"`
	// Name of the `segment` to share as defined in the `segments` section. This is used only when the `associationMethod` is `constant`.
	Segment *string `pulumi:"segment"`
	// Maps the attachment to the value of a known key. This is used with the `associationMethod` is `tag`. For example a `tag` of `stage = “test”`, will map to a segment named `test`. The value must exactly match the name of a segment. This allows you to have many segments, but use only a single rule without having to define multiple nearly identical conditions. This prevents creating many similar conditions that all use the same keys to map to segments.
	TagValueOfKey *string `pulumi:"tagValueOfKey"`
}

type GetCoreNetworkPolicyDocumentAttachmentPolicyActionArgs struct {
	// Defines how a segment is mapped. Values can be `constant` or `tag`. `constant` statically defines the segment to associate the attachment to. `tag` uses the value of a tag to dynamically try to map to a segment.reference_policies_elements_condition_operators.html) to evaluate.
	AssociationMethod pulumix.Input[string] `pulumi:"associationMethod"`
	// Determines if this mapping should override the segment value for `requireAttachmentAcceptance`. You can only set this to `true`, indicating that this setting applies only to segments that have `requireAttachmentAcceptance` set to `false`. If the segment already has the default `requireAttachmentAcceptance`, you can set this to inherit segment’s acceptance value.
	RequireAcceptance pulumix.Input[*bool] `pulumi:"requireAcceptance"`
	// Name of the `segment` to share as defined in the `segments` section. This is used only when the `associationMethod` is `constant`.
	Segment pulumix.Input[*string] `pulumi:"segment"`
	// Maps the attachment to the value of a known key. This is used with the `associationMethod` is `tag`. For example a `tag` of `stage = “test”`, will map to a segment named `test`. The value must exactly match the name of a segment. This allows you to have many segments, but use only a single rule without having to define multiple nearly identical conditions. This prevents creating many similar conditions that all use the same keys to map to segments.
	TagValueOfKey pulumix.Input[*string] `pulumi:"tagValueOfKey"`
}

func (GetCoreNetworkPolicyDocumentAttachmentPolicyActionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetCoreNetworkPolicyDocumentAttachmentPolicyAction)(nil)).Elem()
}

func (i GetCoreNetworkPolicyDocumentAttachmentPolicyActionArgs) ToGetCoreNetworkPolicyDocumentAttachmentPolicyActionOutput() GetCoreNetworkPolicyDocumentAttachmentPolicyActionOutput {
	return i.ToGetCoreNetworkPolicyDocumentAttachmentPolicyActionOutputWithContext(context.Background())
}

func (i GetCoreNetworkPolicyDocumentAttachmentPolicyActionArgs) ToGetCoreNetworkPolicyDocumentAttachmentPolicyActionOutputWithContext(ctx context.Context) GetCoreNetworkPolicyDocumentAttachmentPolicyActionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetCoreNetworkPolicyDocumentAttachmentPolicyActionOutput)
}

func (i *GetCoreNetworkPolicyDocumentAttachmentPolicyActionArgs) ToOutput(ctx context.Context) pulumix.Output[*GetCoreNetworkPolicyDocumentAttachmentPolicyActionArgs] {
	return pulumix.Val(i)
}

type GetCoreNetworkPolicyDocumentAttachmentPolicyActionOutput struct{ *pulumi.OutputState }

func (GetCoreNetworkPolicyDocumentAttachmentPolicyActionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetCoreNetworkPolicyDocumentAttachmentPolicyAction)(nil)).Elem()
}

func (o GetCoreNetworkPolicyDocumentAttachmentPolicyActionOutput) ToGetCoreNetworkPolicyDocumentAttachmentPolicyActionOutput() GetCoreNetworkPolicyDocumentAttachmentPolicyActionOutput {
	return o
}

func (o GetCoreNetworkPolicyDocumentAttachmentPolicyActionOutput) ToGetCoreNetworkPolicyDocumentAttachmentPolicyActionOutputWithContext(ctx context.Context) GetCoreNetworkPolicyDocumentAttachmentPolicyActionOutput {
	return o
}

func (o GetCoreNetworkPolicyDocumentAttachmentPolicyActionOutput) ToOutput(ctx context.Context) pulumix.Output[GetCoreNetworkPolicyDocumentAttachmentPolicyAction] {
	return pulumix.Output[GetCoreNetworkPolicyDocumentAttachmentPolicyAction]{
		OutputState: o.OutputState,
	}
}

// Defines how a segment is mapped. Values can be `constant` or `tag`. `constant` statically defines the segment to associate the attachment to. `tag` uses the value of a tag to dynamically try to map to a segment.reference_policies_elements_condition_operators.html) to evaluate.
func (o GetCoreNetworkPolicyDocumentAttachmentPolicyActionOutput) AssociationMethod() pulumix.Output[string] {
	return pulumix.Apply[GetCoreNetworkPolicyDocumentAttachmentPolicyAction](o, func(v GetCoreNetworkPolicyDocumentAttachmentPolicyAction) string { return v.AssociationMethod })
}

// Determines if this mapping should override the segment value for `requireAttachmentAcceptance`. You can only set this to `true`, indicating that this setting applies only to segments that have `requireAttachmentAcceptance` set to `false`. If the segment already has the default `requireAttachmentAcceptance`, you can set this to inherit segment’s acceptance value.
func (o GetCoreNetworkPolicyDocumentAttachmentPolicyActionOutput) RequireAcceptance() pulumix.Output[*bool] {
	return pulumix.Apply[GetCoreNetworkPolicyDocumentAttachmentPolicyAction](o, func(v GetCoreNetworkPolicyDocumentAttachmentPolicyAction) *bool { return v.RequireAcceptance })
}

// Name of the `segment` to share as defined in the `segments` section. This is used only when the `associationMethod` is `constant`.
func (o GetCoreNetworkPolicyDocumentAttachmentPolicyActionOutput) Segment() pulumix.Output[*string] {
	return pulumix.Apply[GetCoreNetworkPolicyDocumentAttachmentPolicyAction](o, func(v GetCoreNetworkPolicyDocumentAttachmentPolicyAction) *string { return v.Segment })
}

// Maps the attachment to the value of a known key. This is used with the `associationMethod` is `tag`. For example a `tag` of `stage = “test”`, will map to a segment named `test`. The value must exactly match the name of a segment. This allows you to have many segments, but use only a single rule without having to define multiple nearly identical conditions. This prevents creating many similar conditions that all use the same keys to map to segments.
func (o GetCoreNetworkPolicyDocumentAttachmentPolicyActionOutput) TagValueOfKey() pulumix.Output[*string] {
	return pulumix.Apply[GetCoreNetworkPolicyDocumentAttachmentPolicyAction](o, func(v GetCoreNetworkPolicyDocumentAttachmentPolicyAction) *string { return v.TagValueOfKey })
}

type GetCoreNetworkPolicyDocumentAttachmentPolicyCondition struct {
	// string value
	Key *string `pulumi:"key"`
	// Valid values include: `equals`, `not-equals`, `contains`, `begins-with`.
	Operator *string `pulumi:"operator"`
	// Valid values include: `account-id`, `any`, `tag-value`, `tag-exists`, `resource-id`, `region`, `attachment-type`.
	Type string `pulumi:"type"`
	// string value
	Value *string `pulumi:"value"`
}

type GetCoreNetworkPolicyDocumentAttachmentPolicyConditionArgs struct {
	// string value
	Key pulumix.Input[*string] `pulumi:"key"`
	// Valid values include: `equals`, `not-equals`, `contains`, `begins-with`.
	Operator pulumix.Input[*string] `pulumi:"operator"`
	// Valid values include: `account-id`, `any`, `tag-value`, `tag-exists`, `resource-id`, `region`, `attachment-type`.
	Type pulumix.Input[string] `pulumi:"type"`
	// string value
	Value pulumix.Input[*string] `pulumi:"value"`
}

func (GetCoreNetworkPolicyDocumentAttachmentPolicyConditionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetCoreNetworkPolicyDocumentAttachmentPolicyCondition)(nil)).Elem()
}

func (i GetCoreNetworkPolicyDocumentAttachmentPolicyConditionArgs) ToGetCoreNetworkPolicyDocumentAttachmentPolicyConditionOutput() GetCoreNetworkPolicyDocumentAttachmentPolicyConditionOutput {
	return i.ToGetCoreNetworkPolicyDocumentAttachmentPolicyConditionOutputWithContext(context.Background())
}

func (i GetCoreNetworkPolicyDocumentAttachmentPolicyConditionArgs) ToGetCoreNetworkPolicyDocumentAttachmentPolicyConditionOutputWithContext(ctx context.Context) GetCoreNetworkPolicyDocumentAttachmentPolicyConditionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetCoreNetworkPolicyDocumentAttachmentPolicyConditionOutput)
}

func (i *GetCoreNetworkPolicyDocumentAttachmentPolicyConditionArgs) ToOutput(ctx context.Context) pulumix.Output[*GetCoreNetworkPolicyDocumentAttachmentPolicyConditionArgs] {
	return pulumix.Val(i)
}

type GetCoreNetworkPolicyDocumentAttachmentPolicyConditionOutput struct{ *pulumi.OutputState }

func (GetCoreNetworkPolicyDocumentAttachmentPolicyConditionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetCoreNetworkPolicyDocumentAttachmentPolicyCondition)(nil)).Elem()
}

func (o GetCoreNetworkPolicyDocumentAttachmentPolicyConditionOutput) ToGetCoreNetworkPolicyDocumentAttachmentPolicyConditionOutput() GetCoreNetworkPolicyDocumentAttachmentPolicyConditionOutput {
	return o
}

func (o GetCoreNetworkPolicyDocumentAttachmentPolicyConditionOutput) ToGetCoreNetworkPolicyDocumentAttachmentPolicyConditionOutputWithContext(ctx context.Context) GetCoreNetworkPolicyDocumentAttachmentPolicyConditionOutput {
	return o
}

func (o GetCoreNetworkPolicyDocumentAttachmentPolicyConditionOutput) ToOutput(ctx context.Context) pulumix.Output[GetCoreNetworkPolicyDocumentAttachmentPolicyCondition] {
	return pulumix.Output[GetCoreNetworkPolicyDocumentAttachmentPolicyCondition]{
		OutputState: o.OutputState,
	}
}

// string value
func (o GetCoreNetworkPolicyDocumentAttachmentPolicyConditionOutput) Key() pulumix.Output[*string] {
	return pulumix.Apply[GetCoreNetworkPolicyDocumentAttachmentPolicyCondition](o, func(v GetCoreNetworkPolicyDocumentAttachmentPolicyCondition) *string { return v.Key })
}

// Valid values include: `equals`, `not-equals`, `contains`, `begins-with`.
func (o GetCoreNetworkPolicyDocumentAttachmentPolicyConditionOutput) Operator() pulumix.Output[*string] {
	return pulumix.Apply[GetCoreNetworkPolicyDocumentAttachmentPolicyCondition](o, func(v GetCoreNetworkPolicyDocumentAttachmentPolicyCondition) *string { return v.Operator })
}

// Valid values include: `account-id`, `any`, `tag-value`, `tag-exists`, `resource-id`, `region`, `attachment-type`.
func (o GetCoreNetworkPolicyDocumentAttachmentPolicyConditionOutput) Type() pulumix.Output[string] {
	return pulumix.Apply[GetCoreNetworkPolicyDocumentAttachmentPolicyCondition](o, func(v GetCoreNetworkPolicyDocumentAttachmentPolicyCondition) string { return v.Type })
}

// string value
func (o GetCoreNetworkPolicyDocumentAttachmentPolicyConditionOutput) Value() pulumix.Output[*string] {
	return pulumix.Apply[GetCoreNetworkPolicyDocumentAttachmentPolicyCondition](o, func(v GetCoreNetworkPolicyDocumentAttachmentPolicyCondition) *string { return v.Value })
}

type GetCoreNetworkPolicyDocumentCoreNetworkConfiguration struct {
	// List of strings containing Autonomous System Numbers (ASNs) to assign to Core Network Edges. By default, the core network automatically assigns an ASN for each Core Network Edge but you can optionally define the ASN in the edge-locations for each Region. The ASN uses an array of integer ranges only from `64512` to `65534` and `4200000000` to `4294967294` expressed as a string like `"64512-65534"`. No other ASN ranges can be used.
	AsnRanges []string `pulumi:"asnRanges"`
	// A block value of AWS Region locations where you're creating Core Network Edges. Detailed below.
	EdgeLocations []GetCoreNetworkPolicyDocumentCoreNetworkConfigurationEdgeLocation `pulumi:"edgeLocations"`
	// The Classless Inter-Domain Routing (CIDR) block range used to create tunnels for AWS Transit Gateway Connect. The format is standard AWS CIDR range (for example, `10.0.1.0/24`). You can optionally define the inside CIDR in the Core Network Edges section per Region. The minimum is a `/24` for IPv4 or `/64` for IPv6. You can provide multiple `/24` subnets or a larger CIDR range. If you define a larger CIDR range, new Core Network Edges will be automatically assigned `/24` and `/64` subnets from the larger CIDR. an Inside CIDR block is required for attaching Connect attachments to a Core Network Edge.
	InsideCidrBlocks []string `pulumi:"insideCidrBlocks"`
	// Indicates whether the core network forwards traffic over multiple equal-cost routes using VPN. The value can be either `true` or `false`. The default is `true`.
	VpnEcmpSupport *bool `pulumi:"vpnEcmpSupport"`
}

type GetCoreNetworkPolicyDocumentCoreNetworkConfigurationArgs struct {
	// List of strings containing Autonomous System Numbers (ASNs) to assign to Core Network Edges. By default, the core network automatically assigns an ASN for each Core Network Edge but you can optionally define the ASN in the edge-locations for each Region. The ASN uses an array of integer ranges only from `64512` to `65534` and `4200000000` to `4294967294` expressed as a string like `"64512-65534"`. No other ASN ranges can be used.
	AsnRanges pulumix.Input[[]string] `pulumi:"asnRanges"`
	// A block value of AWS Region locations where you're creating Core Network Edges. Detailed below.
	EdgeLocations pulumix.Input[[]*GetCoreNetworkPolicyDocumentCoreNetworkConfigurationEdgeLocationArgs] `pulumi:"edgeLocations"`
	// The Classless Inter-Domain Routing (CIDR) block range used to create tunnels for AWS Transit Gateway Connect. The format is standard AWS CIDR range (for example, `10.0.1.0/24`). You can optionally define the inside CIDR in the Core Network Edges section per Region. The minimum is a `/24` for IPv4 or `/64` for IPv6. You can provide multiple `/24` subnets or a larger CIDR range. If you define a larger CIDR range, new Core Network Edges will be automatically assigned `/24` and `/64` subnets from the larger CIDR. an Inside CIDR block is required for attaching Connect attachments to a Core Network Edge.
	InsideCidrBlocks pulumix.Input[[]string] `pulumi:"insideCidrBlocks"`
	// Indicates whether the core network forwards traffic over multiple equal-cost routes using VPN. The value can be either `true` or `false`. The default is `true`.
	VpnEcmpSupport pulumix.Input[*bool] `pulumi:"vpnEcmpSupport"`
}

func (GetCoreNetworkPolicyDocumentCoreNetworkConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetCoreNetworkPolicyDocumentCoreNetworkConfiguration)(nil)).Elem()
}

func (i GetCoreNetworkPolicyDocumentCoreNetworkConfigurationArgs) ToGetCoreNetworkPolicyDocumentCoreNetworkConfigurationOutput() GetCoreNetworkPolicyDocumentCoreNetworkConfigurationOutput {
	return i.ToGetCoreNetworkPolicyDocumentCoreNetworkConfigurationOutputWithContext(context.Background())
}

func (i GetCoreNetworkPolicyDocumentCoreNetworkConfigurationArgs) ToGetCoreNetworkPolicyDocumentCoreNetworkConfigurationOutputWithContext(ctx context.Context) GetCoreNetworkPolicyDocumentCoreNetworkConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetCoreNetworkPolicyDocumentCoreNetworkConfigurationOutput)
}

func (i *GetCoreNetworkPolicyDocumentCoreNetworkConfigurationArgs) ToOutput(ctx context.Context) pulumix.Output[*GetCoreNetworkPolicyDocumentCoreNetworkConfigurationArgs] {
	return pulumix.Val(i)
}

type GetCoreNetworkPolicyDocumentCoreNetworkConfigurationOutput struct{ *pulumi.OutputState }

func (GetCoreNetworkPolicyDocumentCoreNetworkConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetCoreNetworkPolicyDocumentCoreNetworkConfiguration)(nil)).Elem()
}

func (o GetCoreNetworkPolicyDocumentCoreNetworkConfigurationOutput) ToGetCoreNetworkPolicyDocumentCoreNetworkConfigurationOutput() GetCoreNetworkPolicyDocumentCoreNetworkConfigurationOutput {
	return o
}

func (o GetCoreNetworkPolicyDocumentCoreNetworkConfigurationOutput) ToGetCoreNetworkPolicyDocumentCoreNetworkConfigurationOutputWithContext(ctx context.Context) GetCoreNetworkPolicyDocumentCoreNetworkConfigurationOutput {
	return o
}

func (o GetCoreNetworkPolicyDocumentCoreNetworkConfigurationOutput) ToOutput(ctx context.Context) pulumix.Output[GetCoreNetworkPolicyDocumentCoreNetworkConfiguration] {
	return pulumix.Output[GetCoreNetworkPolicyDocumentCoreNetworkConfiguration]{
		OutputState: o.OutputState,
	}
}

// List of strings containing Autonomous System Numbers (ASNs) to assign to Core Network Edges. By default, the core network automatically assigns an ASN for each Core Network Edge but you can optionally define the ASN in the edge-locations for each Region. The ASN uses an array of integer ranges only from `64512` to `65534` and `4200000000` to `4294967294` expressed as a string like `"64512-65534"`. No other ASN ranges can be used.
func (o GetCoreNetworkPolicyDocumentCoreNetworkConfigurationOutput) AsnRanges() pulumix.ArrayOutput[string] {
	value := pulumix.Apply[GetCoreNetworkPolicyDocumentCoreNetworkConfiguration](o, func(v GetCoreNetworkPolicyDocumentCoreNetworkConfiguration) []string { return v.AsnRanges })
	return pulumix.ArrayOutput[string]{OutputState: value.OutputState}
}

// A block value of AWS Region locations where you're creating Core Network Edges. Detailed below.
func (o GetCoreNetworkPolicyDocumentCoreNetworkConfigurationOutput) EdgeLocations() pulumix.GArrayOutput[GetCoreNetworkPolicyDocumentCoreNetworkConfigurationEdgeLocation, GetCoreNetworkPolicyDocumentCoreNetworkConfigurationEdgeLocationOutput] {
	value := pulumix.Apply[GetCoreNetworkPolicyDocumentCoreNetworkConfiguration](o, func(v GetCoreNetworkPolicyDocumentCoreNetworkConfiguration) []GetCoreNetworkPolicyDocumentCoreNetworkConfigurationEdgeLocation {
		return v.EdgeLocations
	})
	return pulumix.GArrayOutput[GetCoreNetworkPolicyDocumentCoreNetworkConfigurationEdgeLocation, GetCoreNetworkPolicyDocumentCoreNetworkConfigurationEdgeLocationOutput]{OutputState: value.OutputState}
}

// The Classless Inter-Domain Routing (CIDR) block range used to create tunnels for AWS Transit Gateway Connect. The format is standard AWS CIDR range (for example, `10.0.1.0/24`). You can optionally define the inside CIDR in the Core Network Edges section per Region. The minimum is a `/24` for IPv4 or `/64` for IPv6. You can provide multiple `/24` subnets or a larger CIDR range. If you define a larger CIDR range, new Core Network Edges will be automatically assigned `/24` and `/64` subnets from the larger CIDR. an Inside CIDR block is required for attaching Connect attachments to a Core Network Edge.
func (o GetCoreNetworkPolicyDocumentCoreNetworkConfigurationOutput) InsideCidrBlocks() pulumix.ArrayOutput[string] {
	value := pulumix.Apply[GetCoreNetworkPolicyDocumentCoreNetworkConfiguration](o, func(v GetCoreNetworkPolicyDocumentCoreNetworkConfiguration) []string { return v.InsideCidrBlocks })
	return pulumix.ArrayOutput[string]{OutputState: value.OutputState}
}

// Indicates whether the core network forwards traffic over multiple equal-cost routes using VPN. The value can be either `true` or `false`. The default is `true`.
func (o GetCoreNetworkPolicyDocumentCoreNetworkConfigurationOutput) VpnEcmpSupport() pulumix.Output[*bool] {
	return pulumix.Apply[GetCoreNetworkPolicyDocumentCoreNetworkConfiguration](o, func(v GetCoreNetworkPolicyDocumentCoreNetworkConfiguration) *bool { return v.VpnEcmpSupport })
}

type GetCoreNetworkPolicyDocumentCoreNetworkConfigurationEdgeLocation struct {
	// ASN of the Core Network Edge in an AWS Region. By default, the ASN will be a single integer automatically assigned from `asnRanges`
	Asn *string `pulumi:"asn"`
	// The local CIDR blocks for this Core Network Edge for AWS Transit Gateway Connect attachments. By default, this CIDR block will be one or more optional IPv4 and IPv6 CIDR prefixes auto-assigned from `insideCidrBlocks`.
	InsideCidrBlocks []string `pulumi:"insideCidrBlocks"`
	Location         string   `pulumi:"location"`
}

type GetCoreNetworkPolicyDocumentCoreNetworkConfigurationEdgeLocationArgs struct {
	// ASN of the Core Network Edge in an AWS Region. By default, the ASN will be a single integer automatically assigned from `asnRanges`
	Asn pulumix.Input[*string] `pulumi:"asn"`
	// The local CIDR blocks for this Core Network Edge for AWS Transit Gateway Connect attachments. By default, this CIDR block will be one or more optional IPv4 and IPv6 CIDR prefixes auto-assigned from `insideCidrBlocks`.
	InsideCidrBlocks pulumix.Input[[]string] `pulumi:"insideCidrBlocks"`
	Location         pulumix.Input[string]   `pulumi:"location"`
}

func (GetCoreNetworkPolicyDocumentCoreNetworkConfigurationEdgeLocationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetCoreNetworkPolicyDocumentCoreNetworkConfigurationEdgeLocation)(nil)).Elem()
}

func (i GetCoreNetworkPolicyDocumentCoreNetworkConfigurationEdgeLocationArgs) ToGetCoreNetworkPolicyDocumentCoreNetworkConfigurationEdgeLocationOutput() GetCoreNetworkPolicyDocumentCoreNetworkConfigurationEdgeLocationOutput {
	return i.ToGetCoreNetworkPolicyDocumentCoreNetworkConfigurationEdgeLocationOutputWithContext(context.Background())
}

func (i GetCoreNetworkPolicyDocumentCoreNetworkConfigurationEdgeLocationArgs) ToGetCoreNetworkPolicyDocumentCoreNetworkConfigurationEdgeLocationOutputWithContext(ctx context.Context) GetCoreNetworkPolicyDocumentCoreNetworkConfigurationEdgeLocationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetCoreNetworkPolicyDocumentCoreNetworkConfigurationEdgeLocationOutput)
}

func (i *GetCoreNetworkPolicyDocumentCoreNetworkConfigurationEdgeLocationArgs) ToOutput(ctx context.Context) pulumix.Output[*GetCoreNetworkPolicyDocumentCoreNetworkConfigurationEdgeLocationArgs] {
	return pulumix.Val(i)
}

type GetCoreNetworkPolicyDocumentCoreNetworkConfigurationEdgeLocationOutput struct{ *pulumi.OutputState }

func (GetCoreNetworkPolicyDocumentCoreNetworkConfigurationEdgeLocationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetCoreNetworkPolicyDocumentCoreNetworkConfigurationEdgeLocation)(nil)).Elem()
}

func (o GetCoreNetworkPolicyDocumentCoreNetworkConfigurationEdgeLocationOutput) ToGetCoreNetworkPolicyDocumentCoreNetworkConfigurationEdgeLocationOutput() GetCoreNetworkPolicyDocumentCoreNetworkConfigurationEdgeLocationOutput {
	return o
}

func (o GetCoreNetworkPolicyDocumentCoreNetworkConfigurationEdgeLocationOutput) ToGetCoreNetworkPolicyDocumentCoreNetworkConfigurationEdgeLocationOutputWithContext(ctx context.Context) GetCoreNetworkPolicyDocumentCoreNetworkConfigurationEdgeLocationOutput {
	return o
}

func (o GetCoreNetworkPolicyDocumentCoreNetworkConfigurationEdgeLocationOutput) ToOutput(ctx context.Context) pulumix.Output[GetCoreNetworkPolicyDocumentCoreNetworkConfigurationEdgeLocation] {
	return pulumix.Output[GetCoreNetworkPolicyDocumentCoreNetworkConfigurationEdgeLocation]{
		OutputState: o.OutputState,
	}
}

// ASN of the Core Network Edge in an AWS Region. By default, the ASN will be a single integer automatically assigned from `asnRanges`
func (o GetCoreNetworkPolicyDocumentCoreNetworkConfigurationEdgeLocationOutput) Asn() pulumix.Output[*string] {
	return pulumix.Apply[GetCoreNetworkPolicyDocumentCoreNetworkConfigurationEdgeLocation](o, func(v GetCoreNetworkPolicyDocumentCoreNetworkConfigurationEdgeLocation) *string { return v.Asn })
}

// The local CIDR blocks for this Core Network Edge for AWS Transit Gateway Connect attachments. By default, this CIDR block will be one or more optional IPv4 and IPv6 CIDR prefixes auto-assigned from `insideCidrBlocks`.
func (o GetCoreNetworkPolicyDocumentCoreNetworkConfigurationEdgeLocationOutput) InsideCidrBlocks() pulumix.ArrayOutput[string] {
	value := pulumix.Apply[GetCoreNetworkPolicyDocumentCoreNetworkConfigurationEdgeLocation](o, func(v GetCoreNetworkPolicyDocumentCoreNetworkConfigurationEdgeLocation) []string {
		return v.InsideCidrBlocks
	})
	return pulumix.ArrayOutput[string]{OutputState: value.OutputState}
}

func (o GetCoreNetworkPolicyDocumentCoreNetworkConfigurationEdgeLocationOutput) Location() pulumix.Output[string] {
	return pulumix.Apply[GetCoreNetworkPolicyDocumentCoreNetworkConfigurationEdgeLocation](o, func(v GetCoreNetworkPolicyDocumentCoreNetworkConfigurationEdgeLocation) string { return v.Location })
}

type GetCoreNetworkPolicyDocumentSegment struct {
	// List of strings of segment names that explicitly allows only routes from the segments that are listed in the array. Use the `allowFilter` setting if a segment has a well-defined group of other segments that connectivity should be restricted to. It is applied after routes have been shared in `segmentActions`. If a segment is listed in `allowFilter`, attachments between the two segments will have routes if they are also shared in the segment-actions area. For example, you might have a segment named "video-producer" that should only ever share routes with a "video-distributor" segment, no matter how many other share statements are created.
	AllowFilters []string `pulumi:"allowFilters"`
	// An array of segments that disallows routes from the segments listed in the array. It is applied only after routes have been shared in `segmentActions`. If a segment is listed in the `denyFilter`, attachments between the two segments will never have routes shared across them. For example, you might have a "financial" payment segment that should never share routes with a "development" segment, regardless of how many other share statements are created. Adding the payments segment to the deny-filter parameter prevents any shared routes from being created with other segments.
	DenyFilters []string `pulumi:"denyFilters"`
	// A user-defined string describing the segment.
	Description *string `pulumi:"description"`
	// A list of strings of AWS Region names. Allows you to define a more restrictive set of Regions for a segment. The edge location must be a subset of the locations that are defined for `edgeLocations` in the `coreNetworkConfiguration`.
	EdgeLocations []string `pulumi:"edgeLocations"`
	// This Boolean setting determines whether attachments on the same segment can communicate with each other. If set to `true`, the only routes available will be either shared routes through the share actions, which are attachments in other segments, or static routes. The default value is `false`. For example, you might have a segment dedicated to "development" that should never allow VPCs to talk to each other, even if they’re on the same segment. In this example, you would keep the default parameter of `false`.
	IsolateAttachments *bool `pulumi:"isolateAttachments"`
	// Unique name for a segment. The name is a string used in other parts of the policy document, as well as in the console for metrics and other reference points. Valid characters are a–z, and 0–9.
	Name string `pulumi:"name"`
	// This Boolean setting determines whether attachment requests are automatically approved or require acceptance. The default is `true`, indicating that attachment requests require acceptance. For example, you might use this setting to allow a "sandbox" segment to allow any attachment request so that a core network or attachment administrator does not need to review and approve attachment requests. In this example, `requireAttachmentAcceptance` is set to `false`.
	RequireAttachmentAcceptance *bool `pulumi:"requireAttachmentAcceptance"`
}

type GetCoreNetworkPolicyDocumentSegmentArgs struct {
	// List of strings of segment names that explicitly allows only routes from the segments that are listed in the array. Use the `allowFilter` setting if a segment has a well-defined group of other segments that connectivity should be restricted to. It is applied after routes have been shared in `segmentActions`. If a segment is listed in `allowFilter`, attachments between the two segments will have routes if they are also shared in the segment-actions area. For example, you might have a segment named "video-producer" that should only ever share routes with a "video-distributor" segment, no matter how many other share statements are created.
	AllowFilters pulumix.Input[[]string] `pulumi:"allowFilters"`
	// An array of segments that disallows routes from the segments listed in the array. It is applied only after routes have been shared in `segmentActions`. If a segment is listed in the `denyFilter`, attachments between the two segments will never have routes shared across them. For example, you might have a "financial" payment segment that should never share routes with a "development" segment, regardless of how many other share statements are created. Adding the payments segment to the deny-filter parameter prevents any shared routes from being created with other segments.
	DenyFilters pulumix.Input[[]string] `pulumi:"denyFilters"`
	// A user-defined string describing the segment.
	Description pulumix.Input[*string] `pulumi:"description"`
	// A list of strings of AWS Region names. Allows you to define a more restrictive set of Regions for a segment. The edge location must be a subset of the locations that are defined for `edgeLocations` in the `coreNetworkConfiguration`.
	EdgeLocations pulumix.Input[[]string] `pulumi:"edgeLocations"`
	// This Boolean setting determines whether attachments on the same segment can communicate with each other. If set to `true`, the only routes available will be either shared routes through the share actions, which are attachments in other segments, or static routes. The default value is `false`. For example, you might have a segment dedicated to "development" that should never allow VPCs to talk to each other, even if they’re on the same segment. In this example, you would keep the default parameter of `false`.
	IsolateAttachments pulumix.Input[*bool] `pulumi:"isolateAttachments"`
	// Unique name for a segment. The name is a string used in other parts of the policy document, as well as in the console for metrics and other reference points. Valid characters are a–z, and 0–9.
	Name pulumix.Input[string] `pulumi:"name"`
	// This Boolean setting determines whether attachment requests are automatically approved or require acceptance. The default is `true`, indicating that attachment requests require acceptance. For example, you might use this setting to allow a "sandbox" segment to allow any attachment request so that a core network or attachment administrator does not need to review and approve attachment requests. In this example, `requireAttachmentAcceptance` is set to `false`.
	RequireAttachmentAcceptance pulumix.Input[*bool] `pulumi:"requireAttachmentAcceptance"`
}

func (GetCoreNetworkPolicyDocumentSegmentArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetCoreNetworkPolicyDocumentSegment)(nil)).Elem()
}

func (i GetCoreNetworkPolicyDocumentSegmentArgs) ToGetCoreNetworkPolicyDocumentSegmentOutput() GetCoreNetworkPolicyDocumentSegmentOutput {
	return i.ToGetCoreNetworkPolicyDocumentSegmentOutputWithContext(context.Background())
}

func (i GetCoreNetworkPolicyDocumentSegmentArgs) ToGetCoreNetworkPolicyDocumentSegmentOutputWithContext(ctx context.Context) GetCoreNetworkPolicyDocumentSegmentOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetCoreNetworkPolicyDocumentSegmentOutput)
}

func (i *GetCoreNetworkPolicyDocumentSegmentArgs) ToOutput(ctx context.Context) pulumix.Output[*GetCoreNetworkPolicyDocumentSegmentArgs] {
	return pulumix.Val(i)
}

type GetCoreNetworkPolicyDocumentSegmentOutput struct{ *pulumi.OutputState }

func (GetCoreNetworkPolicyDocumentSegmentOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetCoreNetworkPolicyDocumentSegment)(nil)).Elem()
}

func (o GetCoreNetworkPolicyDocumentSegmentOutput) ToGetCoreNetworkPolicyDocumentSegmentOutput() GetCoreNetworkPolicyDocumentSegmentOutput {
	return o
}

func (o GetCoreNetworkPolicyDocumentSegmentOutput) ToGetCoreNetworkPolicyDocumentSegmentOutputWithContext(ctx context.Context) GetCoreNetworkPolicyDocumentSegmentOutput {
	return o
}

func (o GetCoreNetworkPolicyDocumentSegmentOutput) ToOutput(ctx context.Context) pulumix.Output[GetCoreNetworkPolicyDocumentSegment] {
	return pulumix.Output[GetCoreNetworkPolicyDocumentSegment]{
		OutputState: o.OutputState,
	}
}

// List of strings of segment names that explicitly allows only routes from the segments that are listed in the array. Use the `allowFilter` setting if a segment has a well-defined group of other segments that connectivity should be restricted to. It is applied after routes have been shared in `segmentActions`. If a segment is listed in `allowFilter`, attachments between the two segments will have routes if they are also shared in the segment-actions area. For example, you might have a segment named "video-producer" that should only ever share routes with a "video-distributor" segment, no matter how many other share statements are created.
func (o GetCoreNetworkPolicyDocumentSegmentOutput) AllowFilters() pulumix.ArrayOutput[string] {
	value := pulumix.Apply[GetCoreNetworkPolicyDocumentSegment](o, func(v GetCoreNetworkPolicyDocumentSegment) []string { return v.AllowFilters })
	return pulumix.ArrayOutput[string]{OutputState: value.OutputState}
}

// An array of segments that disallows routes from the segments listed in the array. It is applied only after routes have been shared in `segmentActions`. If a segment is listed in the `denyFilter`, attachments between the two segments will never have routes shared across them. For example, you might have a "financial" payment segment that should never share routes with a "development" segment, regardless of how many other share statements are created. Adding the payments segment to the deny-filter parameter prevents any shared routes from being created with other segments.
func (o GetCoreNetworkPolicyDocumentSegmentOutput) DenyFilters() pulumix.ArrayOutput[string] {
	value := pulumix.Apply[GetCoreNetworkPolicyDocumentSegment](o, func(v GetCoreNetworkPolicyDocumentSegment) []string { return v.DenyFilters })
	return pulumix.ArrayOutput[string]{OutputState: value.OutputState}
}

// A user-defined string describing the segment.
func (o GetCoreNetworkPolicyDocumentSegmentOutput) Description() pulumix.Output[*string] {
	return pulumix.Apply[GetCoreNetworkPolicyDocumentSegment](o, func(v GetCoreNetworkPolicyDocumentSegment) *string { return v.Description })
}

// A list of strings of AWS Region names. Allows you to define a more restrictive set of Regions for a segment. The edge location must be a subset of the locations that are defined for `edgeLocations` in the `coreNetworkConfiguration`.
func (o GetCoreNetworkPolicyDocumentSegmentOutput) EdgeLocations() pulumix.ArrayOutput[string] {
	value := pulumix.Apply[GetCoreNetworkPolicyDocumentSegment](o, func(v GetCoreNetworkPolicyDocumentSegment) []string { return v.EdgeLocations })
	return pulumix.ArrayOutput[string]{OutputState: value.OutputState}
}

// This Boolean setting determines whether attachments on the same segment can communicate with each other. If set to `true`, the only routes available will be either shared routes through the share actions, which are attachments in other segments, or static routes. The default value is `false`. For example, you might have a segment dedicated to "development" that should never allow VPCs to talk to each other, even if they’re on the same segment. In this example, you would keep the default parameter of `false`.
func (o GetCoreNetworkPolicyDocumentSegmentOutput) IsolateAttachments() pulumix.Output[*bool] {
	return pulumix.Apply[GetCoreNetworkPolicyDocumentSegment](o, func(v GetCoreNetworkPolicyDocumentSegment) *bool { return v.IsolateAttachments })
}

// Unique name for a segment. The name is a string used in other parts of the policy document, as well as in the console for metrics and other reference points. Valid characters are a–z, and 0–9.
func (o GetCoreNetworkPolicyDocumentSegmentOutput) Name() pulumix.Output[string] {
	return pulumix.Apply[GetCoreNetworkPolicyDocumentSegment](o, func(v GetCoreNetworkPolicyDocumentSegment) string { return v.Name })
}

// This Boolean setting determines whether attachment requests are automatically approved or require acceptance. The default is `true`, indicating that attachment requests require acceptance. For example, you might use this setting to allow a "sandbox" segment to allow any attachment request so that a core network or attachment administrator does not need to review and approve attachment requests. In this example, `requireAttachmentAcceptance` is set to `false`.
func (o GetCoreNetworkPolicyDocumentSegmentOutput) RequireAttachmentAcceptance() pulumix.Output[*bool] {
	return pulumix.Apply[GetCoreNetworkPolicyDocumentSegment](o, func(v GetCoreNetworkPolicyDocumentSegment) *bool { return v.RequireAttachmentAcceptance })
}

type GetCoreNetworkPolicyDocumentSegmentAction struct {
	// Action to take for the chosen segment. Valid values `create-route` or `share`.
	Action string `pulumi:"action"`
	// A user-defined string describing the segment action.
	Description *string `pulumi:"description"`
	// List of strings containing CIDRs. You can define the IPv4 and IPv6 CIDR notation for each AWS Region. For example, `10.1.0.0/16` or `2001:db8::/56`. This is an array of CIDR notation strings.
	DestinationCidrBlocks []string `pulumi:"destinationCidrBlocks"`
	// A list of strings. Valid values include `["blackhole"]` or a list of attachment ids.
	Destinations []string `pulumi:"destinations"`
	// String. This mode places the attachment and return routes in each of the `shareWith` segments. Valid values include: `attachment-route`.
	Mode *string `pulumi:"mode"`
	// Name of the segment.
	Segment string `pulumi:"segment"`
	// A set subtraction of segments to not share with.
	ShareWithExcepts []string `pulumi:"shareWithExcepts"`
	// A list of strings to share with. Must be a substring is all segments. Valid values include: `["*"]` or `["<segment-names>"]`.
	ShareWiths []string `pulumi:"shareWiths"`
}

type GetCoreNetworkPolicyDocumentSegmentActionArgs struct {
	// Action to take for the chosen segment. Valid values `create-route` or `share`.
	Action pulumix.Input[string] `pulumi:"action"`
	// A user-defined string describing the segment action.
	Description pulumix.Input[*string] `pulumi:"description"`
	// List of strings containing CIDRs. You can define the IPv4 and IPv6 CIDR notation for each AWS Region. For example, `10.1.0.0/16` or `2001:db8::/56`. This is an array of CIDR notation strings.
	DestinationCidrBlocks pulumix.Input[[]string] `pulumi:"destinationCidrBlocks"`
	// A list of strings. Valid values include `["blackhole"]` or a list of attachment ids.
	Destinations pulumix.Input[[]string] `pulumi:"destinations"`
	// String. This mode places the attachment and return routes in each of the `shareWith` segments. Valid values include: `attachment-route`.
	Mode pulumix.Input[*string] `pulumi:"mode"`
	// Name of the segment.
	Segment pulumix.Input[string] `pulumi:"segment"`
	// A set subtraction of segments to not share with.
	ShareWithExcepts pulumix.Input[[]string] `pulumi:"shareWithExcepts"`
	// A list of strings to share with. Must be a substring is all segments. Valid values include: `["*"]` or `["<segment-names>"]`.
	ShareWiths pulumix.Input[[]string] `pulumi:"shareWiths"`
}

func (GetCoreNetworkPolicyDocumentSegmentActionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetCoreNetworkPolicyDocumentSegmentAction)(nil)).Elem()
}

func (i GetCoreNetworkPolicyDocumentSegmentActionArgs) ToGetCoreNetworkPolicyDocumentSegmentActionOutput() GetCoreNetworkPolicyDocumentSegmentActionOutput {
	return i.ToGetCoreNetworkPolicyDocumentSegmentActionOutputWithContext(context.Background())
}

func (i GetCoreNetworkPolicyDocumentSegmentActionArgs) ToGetCoreNetworkPolicyDocumentSegmentActionOutputWithContext(ctx context.Context) GetCoreNetworkPolicyDocumentSegmentActionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetCoreNetworkPolicyDocumentSegmentActionOutput)
}

func (i *GetCoreNetworkPolicyDocumentSegmentActionArgs) ToOutput(ctx context.Context) pulumix.Output[*GetCoreNetworkPolicyDocumentSegmentActionArgs] {
	return pulumix.Val(i)
}

type GetCoreNetworkPolicyDocumentSegmentActionOutput struct{ *pulumi.OutputState }

func (GetCoreNetworkPolicyDocumentSegmentActionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetCoreNetworkPolicyDocumentSegmentAction)(nil)).Elem()
}

func (o GetCoreNetworkPolicyDocumentSegmentActionOutput) ToGetCoreNetworkPolicyDocumentSegmentActionOutput() GetCoreNetworkPolicyDocumentSegmentActionOutput {
	return o
}

func (o GetCoreNetworkPolicyDocumentSegmentActionOutput) ToGetCoreNetworkPolicyDocumentSegmentActionOutputWithContext(ctx context.Context) GetCoreNetworkPolicyDocumentSegmentActionOutput {
	return o
}

func (o GetCoreNetworkPolicyDocumentSegmentActionOutput) ToOutput(ctx context.Context) pulumix.Output[GetCoreNetworkPolicyDocumentSegmentAction] {
	return pulumix.Output[GetCoreNetworkPolicyDocumentSegmentAction]{
		OutputState: o.OutputState,
	}
}

// Action to take for the chosen segment. Valid values `create-route` or `share`.
func (o GetCoreNetworkPolicyDocumentSegmentActionOutput) Action() pulumix.Output[string] {
	return pulumix.Apply[GetCoreNetworkPolicyDocumentSegmentAction](o, func(v GetCoreNetworkPolicyDocumentSegmentAction) string { return v.Action })
}

// A user-defined string describing the segment action.
func (o GetCoreNetworkPolicyDocumentSegmentActionOutput) Description() pulumix.Output[*string] {
	return pulumix.Apply[GetCoreNetworkPolicyDocumentSegmentAction](o, func(v GetCoreNetworkPolicyDocumentSegmentAction) *string { return v.Description })
}

// List of strings containing CIDRs. You can define the IPv4 and IPv6 CIDR notation for each AWS Region. For example, `10.1.0.0/16` or `2001:db8::/56`. This is an array of CIDR notation strings.
func (o GetCoreNetworkPolicyDocumentSegmentActionOutput) DestinationCidrBlocks() pulumix.ArrayOutput[string] {
	value := pulumix.Apply[GetCoreNetworkPolicyDocumentSegmentAction](o, func(v GetCoreNetworkPolicyDocumentSegmentAction) []string { return v.DestinationCidrBlocks })
	return pulumix.ArrayOutput[string]{OutputState: value.OutputState}
}

// A list of strings. Valid values include `["blackhole"]` or a list of attachment ids.
func (o GetCoreNetworkPolicyDocumentSegmentActionOutput) Destinations() pulumix.ArrayOutput[string] {
	value := pulumix.Apply[GetCoreNetworkPolicyDocumentSegmentAction](o, func(v GetCoreNetworkPolicyDocumentSegmentAction) []string { return v.Destinations })
	return pulumix.ArrayOutput[string]{OutputState: value.OutputState}
}

// String. This mode places the attachment and return routes in each of the `shareWith` segments. Valid values include: `attachment-route`.
func (o GetCoreNetworkPolicyDocumentSegmentActionOutput) Mode() pulumix.Output[*string] {
	return pulumix.Apply[GetCoreNetworkPolicyDocumentSegmentAction](o, func(v GetCoreNetworkPolicyDocumentSegmentAction) *string { return v.Mode })
}

// Name of the segment.
func (o GetCoreNetworkPolicyDocumentSegmentActionOutput) Segment() pulumix.Output[string] {
	return pulumix.Apply[GetCoreNetworkPolicyDocumentSegmentAction](o, func(v GetCoreNetworkPolicyDocumentSegmentAction) string { return v.Segment })
}

// A set subtraction of segments to not share with.
func (o GetCoreNetworkPolicyDocumentSegmentActionOutput) ShareWithExcepts() pulumix.ArrayOutput[string] {
	value := pulumix.Apply[GetCoreNetworkPolicyDocumentSegmentAction](o, func(v GetCoreNetworkPolicyDocumentSegmentAction) []string { return v.ShareWithExcepts })
	return pulumix.ArrayOutput[string]{OutputState: value.OutputState}
}

// A list of strings to share with. Must be a substring is all segments. Valid values include: `["*"]` or `["<segment-names>"]`.
func (o GetCoreNetworkPolicyDocumentSegmentActionOutput) ShareWiths() pulumix.ArrayOutput[string] {
	value := pulumix.Apply[GetCoreNetworkPolicyDocumentSegmentAction](o, func(v GetCoreNetworkPolicyDocumentSegmentAction) []string { return v.ShareWiths })
	return pulumix.ArrayOutput[string]{OutputState: value.OutputState}
}

type GetDeviceAwsLocation struct {
	// ARN of the subnet that the device is located in.
	SubnetArn string `pulumi:"subnetArn"`
	// Zone that the device is located in.
	Zone string `pulumi:"zone"`
}

type GetDeviceAwsLocationArgs struct {
	// ARN of the subnet that the device is located in.
	SubnetArn pulumix.Input[string] `pulumi:"subnetArn"`
	// Zone that the device is located in.
	Zone pulumix.Input[string] `pulumi:"zone"`
}

func (GetDeviceAwsLocationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetDeviceAwsLocation)(nil)).Elem()
}

func (i GetDeviceAwsLocationArgs) ToGetDeviceAwsLocationOutput() GetDeviceAwsLocationOutput {
	return i.ToGetDeviceAwsLocationOutputWithContext(context.Background())
}

func (i GetDeviceAwsLocationArgs) ToGetDeviceAwsLocationOutputWithContext(ctx context.Context) GetDeviceAwsLocationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetDeviceAwsLocationOutput)
}

func (i *GetDeviceAwsLocationArgs) ToOutput(ctx context.Context) pulumix.Output[*GetDeviceAwsLocationArgs] {
	return pulumix.Val(i)
}

type GetDeviceAwsLocationOutput struct{ *pulumi.OutputState }

func (GetDeviceAwsLocationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetDeviceAwsLocation)(nil)).Elem()
}

func (o GetDeviceAwsLocationOutput) ToGetDeviceAwsLocationOutput() GetDeviceAwsLocationOutput {
	return o
}

func (o GetDeviceAwsLocationOutput) ToGetDeviceAwsLocationOutputWithContext(ctx context.Context) GetDeviceAwsLocationOutput {
	return o
}

func (o GetDeviceAwsLocationOutput) ToOutput(ctx context.Context) pulumix.Output[GetDeviceAwsLocation] {
	return pulumix.Output[GetDeviceAwsLocation]{
		OutputState: o.OutputState,
	}
}

// ARN of the subnet that the device is located in.
func (o GetDeviceAwsLocationOutput) SubnetArn() pulumix.Output[string] {
	return pulumix.Apply[GetDeviceAwsLocation](o, func(v GetDeviceAwsLocation) string { return v.SubnetArn })
}

// Zone that the device is located in.
func (o GetDeviceAwsLocationOutput) Zone() pulumix.Output[string] {
	return pulumix.Apply[GetDeviceAwsLocation](o, func(v GetDeviceAwsLocation) string { return v.Zone })
}

type GetDeviceLocation struct {
	// Physical address.
	Address string `pulumi:"address"`
	// Latitude.
	Latitude string `pulumi:"latitude"`
	// Longitude.
	Longitude string `pulumi:"longitude"`
}

type GetDeviceLocationArgs struct {
	// Physical address.
	Address pulumix.Input[string] `pulumi:"address"`
	// Latitude.
	Latitude pulumix.Input[string] `pulumi:"latitude"`
	// Longitude.
	Longitude pulumix.Input[string] `pulumi:"longitude"`
}

func (GetDeviceLocationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetDeviceLocation)(nil)).Elem()
}

func (i GetDeviceLocationArgs) ToGetDeviceLocationOutput() GetDeviceLocationOutput {
	return i.ToGetDeviceLocationOutputWithContext(context.Background())
}

func (i GetDeviceLocationArgs) ToGetDeviceLocationOutputWithContext(ctx context.Context) GetDeviceLocationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetDeviceLocationOutput)
}

func (i *GetDeviceLocationArgs) ToOutput(ctx context.Context) pulumix.Output[*GetDeviceLocationArgs] {
	return pulumix.Val(i)
}

type GetDeviceLocationOutput struct{ *pulumi.OutputState }

func (GetDeviceLocationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetDeviceLocation)(nil)).Elem()
}

func (o GetDeviceLocationOutput) ToGetDeviceLocationOutput() GetDeviceLocationOutput {
	return o
}

func (o GetDeviceLocationOutput) ToGetDeviceLocationOutputWithContext(ctx context.Context) GetDeviceLocationOutput {
	return o
}

func (o GetDeviceLocationOutput) ToOutput(ctx context.Context) pulumix.Output[GetDeviceLocation] {
	return pulumix.Output[GetDeviceLocation]{
		OutputState: o.OutputState,
	}
}

// Physical address.
func (o GetDeviceLocationOutput) Address() pulumix.Output[string] {
	return pulumix.Apply[GetDeviceLocation](o, func(v GetDeviceLocation) string { return v.Address })
}

// Latitude.
func (o GetDeviceLocationOutput) Latitude() pulumix.Output[string] {
	return pulumix.Apply[GetDeviceLocation](o, func(v GetDeviceLocation) string { return v.Latitude })
}

// Longitude.
func (o GetDeviceLocationOutput) Longitude() pulumix.Output[string] {
	return pulumix.Apply[GetDeviceLocation](o, func(v GetDeviceLocation) string { return v.Longitude })
}

type GetLinkBandwidth struct {
	// Download speed in Mbps.
	DownloadSpeed int `pulumi:"downloadSpeed"`
	// Upload speed in Mbps.
	UploadSpeed int `pulumi:"uploadSpeed"`
}

type GetLinkBandwidthArgs struct {
	// Download speed in Mbps.
	DownloadSpeed pulumix.Input[int] `pulumi:"downloadSpeed"`
	// Upload speed in Mbps.
	UploadSpeed pulumix.Input[int] `pulumi:"uploadSpeed"`
}

func (GetLinkBandwidthArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetLinkBandwidth)(nil)).Elem()
}

func (i GetLinkBandwidthArgs) ToGetLinkBandwidthOutput() GetLinkBandwidthOutput {
	return i.ToGetLinkBandwidthOutputWithContext(context.Background())
}

func (i GetLinkBandwidthArgs) ToGetLinkBandwidthOutputWithContext(ctx context.Context) GetLinkBandwidthOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetLinkBandwidthOutput)
}

func (i *GetLinkBandwidthArgs) ToOutput(ctx context.Context) pulumix.Output[*GetLinkBandwidthArgs] {
	return pulumix.Val(i)
}

type GetLinkBandwidthOutput struct{ *pulumi.OutputState }

func (GetLinkBandwidthOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetLinkBandwidth)(nil)).Elem()
}

func (o GetLinkBandwidthOutput) ToGetLinkBandwidthOutput() GetLinkBandwidthOutput {
	return o
}

func (o GetLinkBandwidthOutput) ToGetLinkBandwidthOutputWithContext(ctx context.Context) GetLinkBandwidthOutput {
	return o
}

func (o GetLinkBandwidthOutput) ToOutput(ctx context.Context) pulumix.Output[GetLinkBandwidth] {
	return pulumix.Output[GetLinkBandwidth]{
		OutputState: o.OutputState,
	}
}

// Download speed in Mbps.
func (o GetLinkBandwidthOutput) DownloadSpeed() pulumix.Output[int] {
	return pulumix.Apply[GetLinkBandwidth](o, func(v GetLinkBandwidth) int { return v.DownloadSpeed })
}

// Upload speed in Mbps.
func (o GetLinkBandwidthOutput) UploadSpeed() pulumix.Output[int] {
	return pulumix.Apply[GetLinkBandwidth](o, func(v GetLinkBandwidth) int { return v.UploadSpeed })
}

type GetSiteLocation struct {
	// Address of the location.
	Address string `pulumi:"address"`
	// Latitude of the location.
	Latitude string `pulumi:"latitude"`
	// Longitude of the location.
	Longitude string `pulumi:"longitude"`
}

type GetSiteLocationArgs struct {
	// Address of the location.
	Address pulumix.Input[string] `pulumi:"address"`
	// Latitude of the location.
	Latitude pulumix.Input[string] `pulumi:"latitude"`
	// Longitude of the location.
	Longitude pulumix.Input[string] `pulumi:"longitude"`
}

func (GetSiteLocationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetSiteLocation)(nil)).Elem()
}

func (i GetSiteLocationArgs) ToGetSiteLocationOutput() GetSiteLocationOutput {
	return i.ToGetSiteLocationOutputWithContext(context.Background())
}

func (i GetSiteLocationArgs) ToGetSiteLocationOutputWithContext(ctx context.Context) GetSiteLocationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetSiteLocationOutput)
}

func (i *GetSiteLocationArgs) ToOutput(ctx context.Context) pulumix.Output[*GetSiteLocationArgs] {
	return pulumix.Val(i)
}

type GetSiteLocationOutput struct{ *pulumi.OutputState }

func (GetSiteLocationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetSiteLocation)(nil)).Elem()
}

func (o GetSiteLocationOutput) ToGetSiteLocationOutput() GetSiteLocationOutput {
	return o
}

func (o GetSiteLocationOutput) ToGetSiteLocationOutputWithContext(ctx context.Context) GetSiteLocationOutput {
	return o
}

func (o GetSiteLocationOutput) ToOutput(ctx context.Context) pulumix.Output[GetSiteLocation] {
	return pulumix.Output[GetSiteLocation]{
		OutputState: o.OutputState,
	}
}

// Address of the location.
func (o GetSiteLocationOutput) Address() pulumix.Output[string] {
	return pulumix.Apply[GetSiteLocation](o, func(v GetSiteLocation) string { return v.Address })
}

// Latitude of the location.
func (o GetSiteLocationOutput) Latitude() pulumix.Output[string] {
	return pulumix.Apply[GetSiteLocation](o, func(v GetSiteLocation) string { return v.Latitude })
}

// Longitude of the location.
func (o GetSiteLocationOutput) Longitude() pulumix.Output[string] {
	return pulumix.Apply[GetSiteLocation](o, func(v GetSiteLocation) string { return v.Longitude })
}

func init() {
	pulumi.RegisterOutputType(ConnectAttachmentOptionsOutput{})
	pulumi.RegisterOutputType(ConnectPeerBgpOptionsOutput{})
	pulumi.RegisterOutputType(ConnectPeerConfigurationOutput{})
	pulumi.RegisterOutputType(ConnectPeerConfigurationBgpConfigurationOutput{})
	pulumi.RegisterOutputType(CoreNetworkEdgeOutput{})
	pulumi.RegisterOutputType(CoreNetworkSegmentOutput{})
	pulumi.RegisterOutputType(DeviceAwsLocationOutput{})
	pulumi.RegisterOutputType(DeviceLocationOutput{})
	pulumi.RegisterOutputType(LinkBandwidthOutput{})
	pulumi.RegisterOutputType(SiteLocationOutput{})
	pulumi.RegisterOutputType(VpcAttachmentOptionsOutput{})
	pulumi.RegisterOutputType(GetCoreNetworkPolicyDocumentAttachmentPolicyOutput{})
	pulumi.RegisterOutputType(GetCoreNetworkPolicyDocumentAttachmentPolicyActionOutput{})
	pulumi.RegisterOutputType(GetCoreNetworkPolicyDocumentAttachmentPolicyConditionOutput{})
	pulumi.RegisterOutputType(GetCoreNetworkPolicyDocumentCoreNetworkConfigurationOutput{})
	pulumi.RegisterOutputType(GetCoreNetworkPolicyDocumentCoreNetworkConfigurationEdgeLocationOutput{})
	pulumi.RegisterOutputType(GetCoreNetworkPolicyDocumentSegmentOutput{})
	pulumi.RegisterOutputType(GetCoreNetworkPolicyDocumentSegmentActionOutput{})
	pulumi.RegisterOutputType(GetDeviceAwsLocationOutput{})
	pulumi.RegisterOutputType(GetDeviceLocationOutput{})
	pulumi.RegisterOutputType(GetLinkBandwidthOutput{})
	pulumi.RegisterOutputType(GetSiteLocationOutput{})
}
