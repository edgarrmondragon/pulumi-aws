// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package emr

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-aws/sdk/v6/go/aws/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumix"
)

// Provides a Managed Scaling policy for EMR Cluster. With Amazon EMR versions 5.30.0 and later (except for Amazon EMR 6.0.0), you can enable EMR managed scaling to automatically increase or decrease the number of instances or units in your cluster based on workload. See [Using EMR Managed Scaling in Amazon EMR](https://docs.aws.amazon.com/emr/latest/ManagementGuide/emr-managed-scaling.html) for more information.
type ManagedScalingPolicy struct {
	pulumi.CustomResourceState

	// ID of the EMR cluster
	ClusterId pulumix.Output[string] `pulumi:"clusterId"`
	// Configuration block with compute limit settings. Described below.
	ComputeLimits pulumix.GArrayOutput[ManagedScalingPolicyComputeLimit, ManagedScalingPolicyComputeLimitOutput] `pulumi:"computeLimits"`
}

// NewManagedScalingPolicy registers a new resource with the given unique name, arguments, and options.
func NewManagedScalingPolicy(ctx *pulumi.Context,
	name string, args *ManagedScalingPolicyArgs, opts ...pulumi.ResourceOption) (*ManagedScalingPolicy, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ClusterId == nil {
		return nil, errors.New("invalid value for required argument 'ClusterId'")
	}
	if args.ComputeLimits == nil {
		return nil, errors.New("invalid value for required argument 'ComputeLimits'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource ManagedScalingPolicy
	err := ctx.RegisterResource("aws:emr/managedScalingPolicy:ManagedScalingPolicy", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetManagedScalingPolicy gets an existing ManagedScalingPolicy resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetManagedScalingPolicy(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ManagedScalingPolicyState, opts ...pulumi.ResourceOption) (*ManagedScalingPolicy, error) {
	var resource ManagedScalingPolicy
	err := ctx.ReadResource("aws:emr/managedScalingPolicy:ManagedScalingPolicy", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ManagedScalingPolicy resources.
type managedScalingPolicyState struct {
	// ID of the EMR cluster
	ClusterId *string `pulumi:"clusterId"`
	// Configuration block with compute limit settings. Described below.
	ComputeLimits []ManagedScalingPolicyComputeLimit `pulumi:"computeLimits"`
}

type ManagedScalingPolicyState struct {
	// ID of the EMR cluster
	ClusterId pulumix.Input[*string]
	// Configuration block with compute limit settings. Described below.
	ComputeLimits pulumix.Input[[]*ManagedScalingPolicyComputeLimitArgs]
}

func (ManagedScalingPolicyState) ElementType() reflect.Type {
	return reflect.TypeOf((*managedScalingPolicyState)(nil)).Elem()
}

type managedScalingPolicyArgs struct {
	// ID of the EMR cluster
	ClusterId string `pulumi:"clusterId"`
	// Configuration block with compute limit settings. Described below.
	ComputeLimits []ManagedScalingPolicyComputeLimit `pulumi:"computeLimits"`
}

// The set of arguments for constructing a ManagedScalingPolicy resource.
type ManagedScalingPolicyArgs struct {
	// ID of the EMR cluster
	ClusterId pulumix.Input[string]
	// Configuration block with compute limit settings. Described below.
	ComputeLimits pulumix.Input[[]*ManagedScalingPolicyComputeLimitArgs]
}

func (ManagedScalingPolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*managedScalingPolicyArgs)(nil)).Elem()
}

type ManagedScalingPolicyOutput struct{ *pulumi.OutputState }

func (ManagedScalingPolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ManagedScalingPolicy)(nil)).Elem()
}

func (o ManagedScalingPolicyOutput) ToManagedScalingPolicyOutput() ManagedScalingPolicyOutput {
	return o
}

func (o ManagedScalingPolicyOutput) ToManagedScalingPolicyOutputWithContext(ctx context.Context) ManagedScalingPolicyOutput {
	return o
}

func (o ManagedScalingPolicyOutput) ToOutput(ctx context.Context) pulumix.Output[ManagedScalingPolicy] {
	return pulumix.Output[ManagedScalingPolicy]{
		OutputState: o.OutputState,
	}
}

// ID of the EMR cluster
func (o ManagedScalingPolicyOutput) ClusterId() pulumix.Output[string] {
	value := pulumix.Apply[ManagedScalingPolicy](o, func(v ManagedScalingPolicy) pulumix.Output[string] { return v.ClusterId })
	return pulumix.Flatten[string, pulumix.Output[string]](value)
}

// Configuration block with compute limit settings. Described below.
func (o ManagedScalingPolicyOutput) ComputeLimits() pulumix.GArrayOutput[ManagedScalingPolicyComputeLimit, ManagedScalingPolicyComputeLimitOutput] {
	value := pulumix.Apply[ManagedScalingPolicy](o, func(v ManagedScalingPolicy) pulumix.GArrayOutput[ManagedScalingPolicyComputeLimit, ManagedScalingPolicyComputeLimitOutput] {
		return v.ComputeLimits
	})
	unwrapped := pulumix.Flatten[[]ManagedScalingPolicyComputeLimit, pulumix.GArrayOutput[ManagedScalingPolicyComputeLimit, ManagedScalingPolicyComputeLimitOutput]](value)
	return pulumix.GArrayOutput[ManagedScalingPolicyComputeLimit, ManagedScalingPolicyComputeLimitOutput]{OutputState: unwrapped.OutputState}
}

func init() {
	pulumi.RegisterOutputType(ManagedScalingPolicyOutput{})
}
