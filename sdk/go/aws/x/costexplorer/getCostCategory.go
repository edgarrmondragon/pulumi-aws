// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package costexplorer

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi-aws/sdk/v6/go/aws/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumix"
)

// Provides details about a specific CostExplorer Cost Category.
func LookupCostCategory(ctx *pulumi.Context, args *LookupCostCategoryArgs, opts ...pulumi.InvokeOption) (*LookupCostCategoryResult, error) {
	opts = internal.PkgInvokeDefaultOpts(opts)
	var rv LookupCostCategoryResult
	err := ctx.Invoke("aws:costexplorer/getCostCategory:getCostCategory", args, &rv, opts...)
	if err != nil {
		return nil, err
	}
	return &rv, nil
}

// A collection of arguments for invoking getCostCategory.
type LookupCostCategoryArgs struct {
	// Unique name for the Cost Category.
	CostCategoryArn string `pulumi:"costCategoryArn"`
	// Configuration block for the specific `Tag` to use for `Expression`. See below.
	Tags map[string]string `pulumi:"tags"`
}

// A collection of values returned by getCostCategory.
type LookupCostCategoryResult struct {
	CostCategoryArn string `pulumi:"costCategoryArn"`
	// Default value for the cost category.
	DefaultValue string `pulumi:"defaultValue"`
	// Effective end data of your Cost Category.
	EffectiveEnd string `pulumi:"effectiveEnd"`
	// Effective state data of your Cost Category.
	EffectiveStart string `pulumi:"effectiveStart"`
	// The provider-assigned unique ID for this managed resource.
	Id   string `pulumi:"id"`
	Name string `pulumi:"name"`
	// Rule schema version in this particular Cost Category.
	RuleVersion string `pulumi:"ruleVersion"`
	// Configuration block for the `Expression` object used to categorize costs. See below.
	Rules []GetCostCategoryRule `pulumi:"rules"`
	// Configuration block for the split charge rules used to allocate your charges between your Cost Category values. See below.
	SplitChargeRules []GetCostCategorySplitChargeRule `pulumi:"splitChargeRules"`
	// Configuration block for the specific `Tag` to use for `Expression`. See below.
	Tags map[string]string `pulumi:"tags"`
}

func LookupCostCategoryOutput(ctx *pulumi.Context, args LookupCostCategoryOutputArgs, opts ...pulumi.InvokeOption) LookupCostCategoryResultOutput {
	outputResult := pulumix.ApplyErr[*LookupCostCategoryArgs](args.ToOutput(), func(plainArgs *LookupCostCategoryArgs) (*LookupCostCategoryResult, error) {
		return LookupCostCategory(ctx, plainArgs, opts...)
	})

	return pulumix.Cast[LookupCostCategoryResultOutput, *LookupCostCategoryResult](outputResult)
}

// A collection of arguments for invoking getCostCategory.
type LookupCostCategoryOutputArgs struct {
	// Unique name for the Cost Category.
	CostCategoryArn pulumix.Input[string] `pulumi:"costCategoryArn"`
	// Configuration block for the specific `Tag` to use for `Expression`. See below.
	Tags pulumix.Input[map[string]string] `pulumi:"tags"`
}

func (args LookupCostCategoryOutputArgs) ToOutput() pulumix.Output[*LookupCostCategoryArgs] {
	allArgs := pulumix.All(
		args.CostCategoryArn.ToOutput(context.Background()).AsAny(),
		args.Tags.ToOutput(context.Background()).AsAny())
	return pulumix.Apply[[]any](allArgs, func(resolvedArgs []interface{}) *LookupCostCategoryArgs {
		return &LookupCostCategoryArgs{
			CostCategoryArn: resolvedArgs[0].(string),
			Tags:            resolvedArgs[1].(map[string]string),
		}
	})
}

type LookupCostCategoryResultOutput struct{ *pulumi.OutputState }

func (LookupCostCategoryResultOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LookupCostCategoryResult)(nil)).Elem()
}

func (o LookupCostCategoryResultOutput) ToOutput(context.Context) pulumix.Output[*LookupCostCategoryResult] {
	return pulumix.Output[*LookupCostCategoryResult]{
		OutputState: o.OutputState,
	}
}

func (o LookupCostCategoryResultOutput) CostCategoryArn() pulumix.Output[string] {
	return pulumix.Apply[*LookupCostCategoryResult](o, func(v *LookupCostCategoryResult) string { return v.CostCategoryArn })
}

func (o LookupCostCategoryResultOutput) DefaultValue() pulumix.Output[string] {
	return pulumix.Apply[*LookupCostCategoryResult](o, func(v *LookupCostCategoryResult) string { return v.DefaultValue })
}

func (o LookupCostCategoryResultOutput) EffectiveEnd() pulumix.Output[string] {
	return pulumix.Apply[*LookupCostCategoryResult](o, func(v *LookupCostCategoryResult) string { return v.EffectiveEnd })
}

func (o LookupCostCategoryResultOutput) EffectiveStart() pulumix.Output[string] {
	return pulumix.Apply[*LookupCostCategoryResult](o, func(v *LookupCostCategoryResult) string { return v.EffectiveStart })
}

func (o LookupCostCategoryResultOutput) Id() pulumix.Output[string] {
	return pulumix.Apply[*LookupCostCategoryResult](o, func(v *LookupCostCategoryResult) string { return v.Id })
}

func (o LookupCostCategoryResultOutput) Name() pulumix.Output[string] {
	return pulumix.Apply[*LookupCostCategoryResult](o, func(v *LookupCostCategoryResult) string { return v.Name })
}

func (o LookupCostCategoryResultOutput) RuleVersion() pulumix.Output[string] {
	return pulumix.Apply[*LookupCostCategoryResult](o, func(v *LookupCostCategoryResult) string { return v.RuleVersion })
}

func (o LookupCostCategoryResultOutput) Rules() pulumix.GArrayOutput[GetCostCategoryRule, GetCostCategoryRuleOutput] {
	value := pulumix.Apply[*LookupCostCategoryResult](o, func(v *LookupCostCategoryResult) []GetCostCategoryRule { return v.Rules })
	return pulumix.GArrayOutput[GetCostCategoryRule, GetCostCategoryRuleOutput]{
		OutputState: value.OutputState,
	}
}

func (o LookupCostCategoryResultOutput) SplitChargeRules() pulumix.GArrayOutput[GetCostCategorySplitChargeRule, GetCostCategorySplitChargeRuleOutput] {
	value := pulumix.Apply[*LookupCostCategoryResult](o, func(v *LookupCostCategoryResult) []GetCostCategorySplitChargeRule { return v.SplitChargeRules })
	return pulumix.GArrayOutput[GetCostCategorySplitChargeRule, GetCostCategorySplitChargeRuleOutput]{
		OutputState: value.OutputState,
	}
}

func (o LookupCostCategoryResultOutput) Tags() pulumix.MapOutput[string] {
	value := pulumix.Apply[*LookupCostCategoryResult](o, func(v *LookupCostCategoryResult) map[string]string { return v.Tags })
	return pulumix.MapOutput[string]{
		OutputState: value.OutputState,
	}
}
